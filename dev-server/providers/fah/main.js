(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
    (function (global){
    /* 3rd party */
    var $ = jQuery = require('jquery');
    var $j = jQuery.noConflict();
    var bootstrap = require('bootstrap');
    
    /* utils */
    var equalizer = require('./utils/equalizer.js');
    var koCustom = require("./utils/knockout-custom.js");
    var optAdd = require("./utils/optgroup-adder.js");
    var returnToTop = require("./utils/return-to-top.js");
    global.moment = require('moment');                      // ui accessible
    //var cropper = require('./utils/cropper.js');
    //var FlowupLabels = require('./utils/FlowupLabels.js');
    require('./utils/FlowupLabels.js');
    require('./utils/cropper.js');
    
    
    /* modules */
    var Globals = require('./modules/globals.js');
    var HomepageVideo = require('./modules/homepage-video.js');
    var Sliders = require('./modules/sliders.js');
    var PetTypeCapture = require('./modules/pet-type-capture.js');
    var ImageGallery = require('./modules/image-gallery.js');
    var MobileNavMenu = require('./modules/mobile-nav-menu.js');
    var dbLanding = require('./modules/db-landing.js');
    var Animations = require('./modules/animations.js');
    var LoadMore = require('./modules/generic-callout-load-more.js');
    var SingleMap = require('./modules/single-hospital-map.js');
    var FacetModules = require('./modules/facet-modules.js');
    var Recaptcha = require('./modules/recaptcha.js');
    var Validator = require('./modules/validator.js');
    var Typeahead = require('./modules/type-ahead.js');
    var PetAdoption = require('./modules/pet-adoption.js');
    var ServiceCategory = require('./modules/service-category.js');
    var EmailCaptureCTA = require('./modules/email-capture-cta.js');
    var FreeFirstExam = require('./modules/free-first-exam.js');
    var AlertMessage = require('./modules/alert-message.js');
    var SiteSearch = require('./modules/site-search.js');
    var Appointments = require('./modules/appointments.js');
    var AppointmentCTA = require('./modules/appointment-cta.js');
    var FaHospital = require('./modules/fa-hospital.js');
    var DotDotDot = require('./modules/dot-dot-dot.js');
    var Login = require('./modules/login.js');
    var Register = require('./modules/register.js');
    var ClientNotFound = require('./modules/clientNotFound.js');
    var PasswordConfirm = require('./modules/passwordConfirm.js');
    var ManageAccount = require('./modules/manage-account.js');
    var ManagePet = require('./modules/manage-pet.js');
    var Header = require('./modules/header.js');
    var InfoBar = require('./modules/information-bar.js');
    var Affiliations = require('./modules/affiliations.js');
    var TeamPerson = require('./modules/team-person.js');
    var Dashboard = require('./modules/dashboard.js');
    
    /* modules: ADA */
    var ADA = require('./modules/ada.js');
    var dayTripper = require('./modules/ui-datepicker-deque.js');
    
    /* auto run modules (pass in no-conflict jQuery) */
    (function () {
        //FlowupLabels.init($j);
        //cropper.init($j);
        koCustom.init($j);
        Globals.init($j);
        Recaptcha.init($j);
        Sliders.init($j);
        PetTypeCapture.init($j);
        ImageGallery.init($j);
        FaHospital.init($j);
        dbLanding.init();
        HomepageVideo.init($j);
        MobileNavMenu.init($j);
        Animations.init($j);
        LoadMore.init($j);
        SingleMap.init($j);
        FacetModules.init($j);
        Validator.init($j);
        PetAdoption.init($j);
        //ServiceCategory.init($j);
        EmailCaptureCTA.init($j);
        FreeFirstExam.init($j);
        AlertMessage.init($j);
        Appointments.init($j);
        AppointmentCTA.init($j);
        SiteSearch.init($j);
        DotDotDot.init($j);
        Login.init($j);
        PasswordConfirm.init($j);
        Register.init($j);
        ClientNotFound.init($j);
        ManageAccount.init($j);
        ManagePet.init($j);
        ADA.init($j);
        optAdd.init($j);
        returnToTop.init($j);
        Header.init($j);
        InfoBar.init($j);
        Affiliations.init($j);
        Dashboard.init($j);    
    })($j);
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    },{"./modules/ada.js":2,"./modules/affiliations.js":3,"./modules/alert-message.js":4,"./modules/animations.js":5,"./modules/appointment-cta.js":6,"./modules/appointments.js":7,"./modules/clientNotFound.js":8,"./modules/dashboard.js":9,"./modules/db-landing.js":10,"./modules/dot-dot-dot.js":11,"./modules/email-capture-cta.js":12,"./modules/fa-hospital.js":13,"./modules/facet-modules.js":14,"./modules/free-first-exam.js":15,"./modules/generic-callout-load-more.js":16,"./modules/globals.js":17,"./modules/header.js":19,"./modules/homepage-video.js":20,"./modules/image-gallery.js":21,"./modules/information-bar.js":22,"./modules/login.js":23,"./modules/manage-account.js":24,"./modules/manage-pet.js":25,"./modules/mobile-nav-menu.js":26,"./modules/passwordConfirm.js":27,"./modules/pet-adoption.js":28,"./modules/pet-type-capture.js":29,"./modules/recaptcha.js":30,"./modules/register.js":31,"./modules/service-category.js":32,"./modules/single-hospital-map.js":33,"./modules/site-search.js":34,"./modules/sliders.js":35,"./modules/team-person.js":36,"./modules/type-ahead.js":37,"./modules/ui-datepicker-deque.js":38,"./modules/validator.js":39,"./utils/FlowupLabels.js":40,"./utils/cropper.js":41,"./utils/equalizer.js":43,"./utils/knockout-custom.js":45,"./utils/optgroup-adder.js":47,"./utils/return-to-top.js":49,"bootstrap":51,"jquery":63,"moment":65}],2:[function(require,module,exports){
    /* requires */
    var helper = require('helper');
    
    exports.init = function ($) {
    
        var lastFocusEl;
    
        // modal ada: focus states and tabbing
        function setModalEvents() {
    
            $('.modal').on('shown.bs.modal', function (e) {
                var $this = $(this);
                //var $modalContent = $this.find('.modal-content');
    
                lastFocusEl = document.activeElement;
    
                $this.attr('tabindex', '0');
            });
    
            $('.modal').on('hidden.bs.modal', function (e) {
                var $this = $(this);
    
                $this.attr('tabindex', '-1');
    
                if ($(lastFocusEl).is(':visible')) {
                    lastFocusEl.focus();
                }
            });
        }
    
        // input ada: focus classes
        function setInputFocusEvents() {
            // Add the "focus" value to class attribute 
            $(document).on("focusin", ".radio-button", function () {
                $(this).addClass('focus');
            });
    
            // Remove the "focus" value to class attribute 
            $(document).on("focusout", ".radio-button", function () {
                $(this).removeClass('focus');
            });
        }
    
        // triggers a click event on an element.trigger-click when enter key is pressed
        function setupFocusTriggers() {
            $('.trigger-click').keypress(function (e) {
    
                var $this = $(this);
                var code = e.which;
    
                if (code === 13 || code === 32) {
    
                    // if space key only, return non-space key presses naturally
                    if ($this.hasClass('key-32') && code !== 32) {
                        return;
                    }
    
                    $this.click();
    
                    if (code === 32) {
                        e.preventDefault();
                    }
                }
            });
        }
    
        // wffm ada
        function setupWFFMAria() {
            $('form[data-wffm] [data-val-required]').attr('aria-required', 'true');
    
            var $requiredInputLabels = $('form[data-wffm] .required-field .control-label');
            if (helper.exists($requiredInputLabels)) {
                var $spanAst = $("<span>", { "class": "ast", "aria-hidden": "true" }).text("*");
                $requiredInputLabels.prepend($spanAst);
            }
        }
    
        setModalEvents();
        setInputFocusEvents();
        setupFocusTriggers();
        setupWFFMAria();
    };
    },{"helper":44}],3:[function(require,module,exports){
    
    exports.init = function ($) {
    
        var affiliations = (function () {
    
            function initialize() {
    
                $('.carousel-showmanymoveone').carousel({
                    interval: false
                });
            }
            return {
                init: initialize
            };
    
        })();
    
        affiliations.init();
    };
    },{}],4:[function(require,module,exports){
    var cookie = require('cookie');
    
    exports.init = function ($) {
    
        var AlertMessage = (function () {
    
            var closerClass = '.alert-dismiss';
            var alertClass = '.alert-bar';
    
            function bindAlertMessage() {
    
                $(alertClass).each(function () {
                    var c = Cookies.get(this.id);
                    if (c == undefined)
                        $(this).show();
                });
    
                $(closerClass).on('click',function () {
                    var id = $(this).data('alert');
                    $('#' + id).hide();
                    Cookies.set(id, '', { expires: 365 });
                });
            }
    
            function initialize() {
                bindAlertMessage();
            }
    
            return {
                init: initialize
            };
    
        })();
    
        AlertMessage.init();
    };
    },{"cookie":55}],5:[function(require,module,exports){
    
    exports.init = function ($) {
    
        var Animations = (function () {
    
            //global vars
            var $desktop_pushdowns = $(".links [data-panel]"); //$(".top-nav .links [data-panel]");
            var $desktop_pushdown_carrots = $(".utility-content-area .carrot");
            var $all_pushdowns = $(".utility-content-area div[data-panel]");
            var $vca_accordion = $(".vca-accordion");
            var current_row_position = 0;
            var time_offset = 0;
    
            // animation helpers
            var helpers = {
                distMetric: function (x, y, x2, y2) {
                    var xDiff = x - x2;
                    var yDiff = y - y2;
                    return (xDiff * xDiff) + (yDiff * yDiff);
                },
                closestEdge: function (x, y, w, h) {
                    var topEdgeDist = this.distMetric(x, y, w / 2, 0);
                    var bottomEdgeDist = this.distMetric(x, y, w / 2, h);
                    var leftEdgeDist = this.distMetric(x, y, 0, h / 2);
                    var rightEdgeDist = this.distMetric(x, y, w, h / 2);
    
                    var min = Math.min(topEdgeDist, bottomEdgeDist, leftEdgeDist, rightEdgeDist);
                    switch (min) {
                        case leftEdgeDist:
                            return "left";
                        case rightEdgeDist:
                            return "right";
                        case topEdgeDist:
                            return "top";
                        case bottomEdgeDist:
                            return "bottom";
                    }
                },
                animateOverlay: function ($overlay, edge, isHoverOut) {
                    var height = $overlay.height();
                    var width = $overlay.width();
    
                    // if mouseleave, clear inline styles top and right
                    if (isHoverOut) {
                        $overlay.css({ 'top': '0', 'right': 'inherit' });
                    }
    
                    /*
                    * do animations based on edge:
                    *  mouseenter: animate to mouseenter direction
                    *  mouseleave: set correct direction opposite of, show, animate back to 0
                    */
                    switch (edge) {
                        case "left":
                            if (isHoverOut) {
                                $overlay.css('right', "-" + width + "px");
                                $overlay.show();
                                $overlay.animate({
                                    right: "0px"
                                }, 500, function () {
    
                                });
                            } else {
                                $overlay.animate({
                                    right: "-" + width + "px"
                                }, 500, function () {
                                    $(this).hide();
                                });
                            }
                            break;
                        case "right":
                            if (isHoverOut) {
                                $overlay.css('right', width + "px");
                                $overlay.show();
                                $overlay.animate({
                                    right: "0px"
                                }, 500, function () {
    
                                });
                            } else {
                                $overlay.animate({
                                    right: width + "px"
                                }, 500, function () {
                                    $(this).hide();
                                });
                            }
                            break;
                        case "top":
                            if (isHoverOut) {
                                $overlay.css('top', height + "px");
                                $overlay.show();
                                $overlay.animate({
                                    top: "0px"
                                }, 500, function () {
    
                                });
                            } else {
                                $overlay.animate({
                                    top: height + "px"
                                }, 500, function () {
                                    $(this).hide();
                                });
                            }
                            break;
                        case "bottom":
                            if (isHoverOut) {
                                $overlay.css('top', "-" + height + "px");
                                $overlay.show();
                                $overlay.animate({
                                    top: "0px"
                                }, 500, function () {
    
                                });
                            } else {
                                $overlay.animate({
                                    top: "-" + height + "px"
                                }, 500, function () {
                                    $(this).hide();
                                });
                            }
                            break;
                    }
                },
                togglePins: function ($container) {
    
                    var start = 0;
                    var is_mobile = ($(window).width() <= 750);
    
                    $container.find(".pin-placement").each(function () {
                        var $this = $(this);
                        var top = (is_mobile && (typeof $this.data("mobile-top") !== "undefined")) ? $this.data("mobile-top") : $this.data("top");
                        var left = (is_mobile && (typeof $this.data("mobile-left") !== "undefined")) ? $this.data("mobile-left") : $this.data("left");
    
                        setTimeout(function () {
                            $this.css({ "top": top + "%", "left": left + "%" });
                            $this.addClass("shown");
                        }, start);
    
                        start += 50;
                    });
    
                    $container.addClass("shown");
                }
            }
    
            function setUpOverlayAnimations() {
    
                // hover categories instead of overlay, as we need to determine when the user hovers out of category
                var $categories = $(".facet-categories").not(".no-animate").find(".category");
                $categories.on('mouseenter mouseleave', function (e) {
                    var $this = $(this);
                    var $overlay = $this.find('.overlay');
                    var position = $this.offset();
                    var hoverEdge = helpers.closestEdge(e.pageX - position.left, e.pageY - position.top, $this.width(), $this.height());
                    var isMouseLeave = e.type === "mouseleave";
    
                    if (e.type === "mouseenter") {
                        $overlay.addClass("moved");
                    } else if (isMouseLeave) {
                        $overlay.stop(true, true);
                        $overlay.removeClass("moved");
                    }
    
                    helpers.animateOverlay($overlay, hoverEdge, isMouseLeave);
                });
            }
    
            function setUpFadeInOnScrollAnimations() {
                $(window).on("scroll", function () {
                    $(".facet-module.fade-in-blocks .category").each(function () {
                        var $this = $(this);
    
                        if (!$this.hasClass("shown")) {
                            var offset = $this.offset().top;
                            if (($(window).scrollTop() + $(window).height() > (offset + ($this.height() / 2)))) {
    
                                if (offset > current_row_position) {
                                    time_offset = 0;
                                    current_row_position = offset;
                                }
                                else if (offset === current_row_position)
                                    time_offset += 100;
    
                                $this.addClass("shown");
                                setTimeout(function () {
                                    $this.animate({
                                        opacity: 1
                                    }, 500);
                                }, time_offset);
                            }
                        }
                    });
                })
            }
    
            function setUpFullWidthMapPinAnimations() {
    
                $(window).on("scroll", function () {
                    $(".full-width-center-text").each(function () {
                        var $this = $(this);
                        if (!$this.hasClass("shown")) {
                            if ($(window).scrollTop() > ($this.offset().top - ($this.height() / 2)))
                                helpers.togglePins($this);
                        }
                    });
                });
    
                $(window).resize(function () {
                    var is_mobile = ($(window).width() <= 750);
                    $(".full-width-center-text .pin-placement").each(function () {
                        var $this = $(this);
                        if ($this.hasClass("shown")) {
                            var top = is_mobile ? $this.data("mobile-top") : $this.data("top");
                            var left = is_mobile ? $this.data("mobile-left") : $this.data("left");
    
                            $this.css({ "top": top + "%", "left": left + "%" });
                        }
                    });
                });
            }
    
            // desktop drawer pushdowns
            function setUpDesktopPushdowns() {
                $desktop_pushdowns.on("click", function (e) {
                    var isMobile = $(".mobile-nav").is(":visible");
                    if (!isMobile) {
                        window.scrollTo(0, 0);
                        var $this = $(this);
                        var $links = $this.parent();
    
                        //check if link pressed is from footer
                        if ($this.closest(".footer-wrapper").length > 0) {
                            $links = $(".top-nav .links");
                        }
    
                        var panel_name = $this.data("panel");
                        if (!panel_name) {
                            return;
                        }
    
                        //get top nav and footer elements
                        var $topThis = $(".top-nav .links ." + panel_name);
                        var $footerThis = $(".footer-wrapper .links ." + panel_name);
    
                        var $panel = $(".utility-content-area div[data-panel='" + panel_name + "']");
    
                        if ($links.hasClass("open")) {
                            if ($panel.hasClass("shown")) {
                                $links.removeClass("open");
                                //$this.removeClass("selected");
                                $topThis.removeClass("selected");
                                $footerThis.removeClass("selected");
                                $panel.removeClass("shown");
                                $panel.slideToggle();
                            }
                            else {
                                $all_pushdowns.hide();
                                $all_pushdowns.removeClass("shown");
                                $desktop_pushdowns.removeClass("selected");
                                $panel.addClass("shown");
                                //$this.addClass("selected");
                                $topThis.addClass("selected");
                                $footerThis.addClass("selected");
                                $panel.show(0,'', function () {
                                    if ($panel.children().hasClass('search')) {
                                        $panel.find('input[type="text"]').focus();
                                    } else {
                                        $($panel.find('a').get(0)).focus();
                                    }
                                });
                            }
                        }
                        else {
                            $links.addClass("open");
                            $desktop_pushdowns.removeClass("selected");
                            //$this.addClass("selected");
                            $topThis.addClass("selected");
                            $footerThis.addClass("selected");
                            $panel.addClass("shown");
                            $panel.slideToggle('400', function () {
                                if ($panel.children().hasClass('search')) {
                                    $panel.find('input[type="text"]').focus();
                                } else {
                                    $($panel.find('a').get(0)).focus();
                                }
                            });
                        }
                        e.stopPropagation();
                        e.preventDefault();
                    }//end of isMobile
                });
            }
    
            function setUp5050TextAnimation() {
    
                function check5050TextBlocks() {
                    $(".image-text-50-50 .text-block .content").each(function () {
                        var $this = $(this);
                        if (!$this.hasClass("shown")) {
                            var offset = $this.offset().top;
                            if ($(window).scrollTop() + $(window).height() > (offset + ($this.height() / 2))) {
                                $this.addClass("shown");
                                $this.animate({
                                    opacity: 1,
                                    top: "0px"
                                }, 500);
                            }
                        }
                    });
                }
    
                $(window).on("scroll", function () {
                    check5050TextBlocks();
                });
    
                check5050TextBlocks();
            }
    
            function setUpInfoGraphicAnimation() {
                $(window).on("scroll", function () {
                    var timer = 0;
                    $(".infographic-panel li").each(function () {
                        var $this = $(this);
                        if (!$this.hasClass("shown")) {
                            var offset = $this.offset().top;
                            if ($(window).scrollTop() + $(window).height() > (offset + ($this.height() / 2))) {
                                $this.addClass("shown");
                                setTimeout(function () {
                                    $this.animate({
                                        opacity: 1,
                                        top: "0px"
                                    }, 500);
                                }, timer);
                                timer += 100;
                            }
                        }
                    });
                });
            }
    
            function setUpCalloutAccordions() {
                $(".mobile-accordion h3").on("click", function () {
                    var $this = $(this);
    
                    $this.parent().toggleClass("open");
                    $this.siblings("p").slideToggle();
                });
            }
    
            function setUpLocationDirectory() {
                if ($vca_accordion.length > 0) {
                    $vca_accordion.find(".content-wrapper .title a").on("click", function () {
                        var $this = $(this);
                        var $title = $this.closest('.title');
                        var $content = $title.siblings(".content");
    
                        $title.toggleClass("open");
                        $content.slideToggle();
    
                        if ($title.hasClass('open')) {
                            $this.attr('aria-expanded', 'true');
                        } else {
                            $this.attr('aria-expanded', 'false');
                        }
    
                        return false;
                    });
    
                    $(".mobile-dropdown-selector select").on("change", function () {
                        $vca_accordion.find(".tab-pane").removeClass("in active");
                        $vca_accordion.find("#" + $(this).val()).addClass("in active");
                    });
                }
            }
    
            function setUpPersonAccordionAnimation() {
                $(".person-accordion .header-section a").on("click", function (e) {
                    e.preventDefault();
                    var $this = $(this);
                    $this.parent().parent().find(".button").toggle();
                    var delay = 0;
    
                    if (!$this.closest(".person-accordion").hasClass("open")) {
                        $this.closest(".person-accordion").find(".list .person").each(function (index, element) {
                            setTimeout(function () {
                                $(element).fadeIn();
                            }, delay);
                            delay += 50;
                        });
                    } else {
                        $this.closest(".person-accordion").find(".list .person").hide();
                    }
    
                    $this.closest(".person-accordion").toggleClass("open");
                });
            }
    
            function initialize() {
                setUpOverlayAnimations();
                setUpFadeInOnScrollAnimations();
                setUpFullWidthMapPinAnimations();
                setUpDesktopPushdowns();
                //setUp5050TextAnimation();
                setUpInfoGraphicAnimation();
                setUpCalloutAccordions();
                setUpLocationDirectory();
                setUpPersonAccordionAnimation();
            }
    
            return {
                init: initialize()
            };
    
        })();
    };
    },{}],6:[function(require,module,exports){
    var $ = require("jquery");
    
    exports.init = function () {
    
        function AppointmentCTA() {
            var $module = $('.appointment-module');
            var isMobile = $(".mobile-nav").is(":visible");
        
            if (isMobile) {
                $module.find('.appointment-panel.appt-type_request').each(function(index, element) {
                    if ($(element).hasClass("mobile")) {
                        if (!$(element).hasClass("open")) {
                            $(element).addClass("open");
                        }
                    } else {
                        $(element).removeClass("open");
                    }
    
                });
    
                $module.find('.appointment-panel.appt-type_book').each(function (index, element) {
                    if ($(element).hasClass("mobile")) {
                        if (!$(element).hasClass("open")) {
                            $(element).addClass("open");
                        }
                    } else {
                        $(element).removeClass("open");
                    }
    
                });
             
            } else {
    
    
                $module.find('.appointment-panel.appt-type_request').each(function (index, element) {
                    if ($(element).hasClass("mobile")) {
                        if ($(element).hasClass("open")) {
                            $(element).removeClass("open");
                        }
                    } else {
                        $(element).addClass("open");
                    }
    
                });
    
                $module.find('.appointment-panel.appt-type_book').each(function (index, element) {
                    if ($(element).hasClass("mobile")) {
                        if ($(element).hasClass("open")) {
                            $(element).removeClass("open");
                        }
                    } else {
                        $(element).addClass("open");
                    }
    
                });
    
            }
    
        }//end of AppointmentCTA
    
        AppointmentCTA();
    };
    },{"jquery":63}],7:[function(require,module,exports){
    require('jquery-ui');
    var helper = require("helper");
    var _ = require("underscore");
    var ko = require("knockout");
    var formValidator = require('jqueryFormValidator');
    
    exports.init = function ($) {
    
        var Appointment = (function () {
    
            // vars
            var viewModel, hospitalId;
            var $module, $datepicker, $modalBookingExpiration, $modalGoBackFromDraftAppt, $modalValidationFailure, $modalServiceGeneric;
    
            var Settings = {
                BookingControllerUrl: "/api/Woofware/AppointmentBooking/",
                RequestControllerUrl: "/api/Woofware/AppointmentRequest/",
                NewClientTypeVal: "new",
                ExistingClientTypeVal: "existing",
                ApptTypeOtherVal: "Appointment Type Other",
                ApptTypeEmergencyVal: "Appointment Type Emergency",
                ApptTypeCallUsVal: "Appointment Type Other",
                TotalApptDays: 1,
                ApptNotesCharLimit: 0,
                OtherApptNotesCharLimit: 0,
                NoPreferenceResourceVal: -1,
                BookingSettings: {
                    DatasourceId: null,
                    Hospital: null,
                    HospitalBusinessDays: null,
                    HospitalHomeUrl: null,
                    AppointmentTypes: null,
                    SSOClient: null,
                    IsPrimaryHospital: null,
                    WWClient: null,
                    BookApptLeadTypeId: null,
                    ReqApptLeadTypeId: null,
                    IsRequestApptPage: null,
                    DisplayReqAppt: null,
                    PetTypes: null,
                    OtherTimePeriods: null
                },
                PanelClasses: {
                    ApptTypes: "step-appt-types",
                    Emergency: "step-emergency",
                    CallUs: "step-call-us",
                    Other: "step-other",
                    ReasonResource: "step-appt-reason-resource",
                    BookingApptNotes: "step-booking-appt-notes",
                    Availability: "step-availability",
                    BookingConfirmation: "step-confirmation",
                    ExistingClientForm: "existing-client-form",
                    NewClientForm: "new-client-form",
                    BookingFinish: "step-finish"
                }
            }
    
            /**
             * UI Helpers
             */
            function countdown(elementName, minutes, seconds) {
    
                var hours, mins, msLeft, time;
                var element = $(elementName)[0];
                var endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;
                var msStarted = ((seconds / 60) + minutes) * 60000;
                var indicatorColor = undefined;
    
                function twoDigits(n) {
                    return (n <= 9 ? "0" + n : n);
                };
    
                function updateTimer(start) {
                    msLeft = endTime - (+new Date);
                    if (msLeft < 1000) {
                        element.innerHTML = "0:00";
    
                        $modalGoBackFromDraftAppt.modal('hide');
                        $modalBookingExpiration.modal();
                        clearInterval(viewModel.countdownTimer);
                    } else {
                        time = new Date(msLeft);
                        hours = time.getUTCHours();
                        mins = time.getUTCMinutes();
    
                        // get percentage complete for indicator color
                        var percent = (msLeft / msStarted) * 100;
                        var isHit = false;
                        if (percent >= 50 && indicatorColor !== "high") {
                            indicatorColor = "high";
                            isHit = true;
                        } else if (percent >= 25 && percent < 50 && indicatorColor !== "medium") {
                            indicatorColor = "medium";
                            isHit = true;
                        } else if (percent < 25 && indicatorColor !== "low") {
                            indicatorColor = "low";
                            isHit = true;
                        }
    
                        if (isHit) {
                            $(element).closest('.time-left').addClass(indicatorColor);
                            viewModel.expirationClass(indicatorColor);
                        }
                        element.innerHTML = (hours ? hours + ':' + twoDigits(mins) : mins) + ':' + twoDigits(time.getUTCSeconds());
    
                        if (start) {
                            // if this is a reset, clear the old interval
                            if (viewModel.countdownTimer != null) {
                                clearInterval(viewModel.countdownTimer);
                                $(element).closest('.time-left').removeClass('low medium');
                            }
    
                            viewModel.countdownTimer = setInterval(function () { updateTimer(false) }, time.getUTCMilliseconds() + 500);
                        }
                    }
                };
    
                updateTimer(true);
            };
            function getCurrentHospitalBussinessDay() {
                return viewModel != null ?
                    _.find(Settings.BookingSettings.HospitalBusinessDays, function (bd) {
                        return bd.Day === moment(viewModel.selectedDate().toISOString()).day();
                    }) : null;
            };
    
            /**
             * DatePicker KO bindingHandler
             */
            var today = moment().format("D-M-Y");
            var prevMonth = moment().month() + 1;
            var prevYear = moment().year();
            var monthClickIncrement = 0;
            var isDatepickerReopening = false;
    
            ko.bindingHandlers.datepicker = {
                init: function (element, valueAccessor, allBindingsAccessor) {
                    var value = ko.utils.unwrapObservable(valueAccessor()),
                        $el = $(element);
    
                    // initialize datepicker with some optional options, restricted date range, date format to match service
                    var options = allBindingsAccessor().datepickerOptions || {};
                    if (_.isEmpty(options)) {
                        options = {
                            showOn: "button",
                            buttonImageOnly: false,
                            buttonText: "<i class='fa fa-calendar'><span class='sr-only'>Launch Date Picker</span></i>",
                            dayNamesShort: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                            showButtonPanel: true,
                            closeText: 'Close',
                            minDate: 0,
                            maxDate: '+11m',
                            dateFormat: "mm-dd-yy",
                            beforeShow: function (input, inst) {
                                if (!helper.exists(viewModel.selectedApptType()) || viewModel.selectedApptType().TemplateType === Settings.ApptTypeOtherVal) {
                                    return;
                                }
    
                                if (!isDatepickerReopening) {
                                    isDatepickerReopening = true;
                                } else if ((inst.currentMonth + 1) !== prevMonth) {     // else if: current month is not the previously opened month
                                    viewModel.updateApptSlots(null, moment(viewModel.selectedDate()).date(1).toDate()); // update calendar date slots
                                }
    
                                // reset prevMonth to selected date's month
                                prevMonth = (viewModel.selectedDate().getMonth()) + 1;
    
                                setTimeout(function () {
                                    // set aria-disabled
                                    inst.dpDiv.find('.ui-datepicker-header > a').attr('aria-disabled', function (index, attr) {
                                        return $(this).hasClass('ui-state-disabled');
                                    });
                                }, 0);
                            },
                            beforeShowDay: function (dateText, obj) {
                                if (!helper.exists(viewModel.selectedApptType()) || viewModel.selectedApptType().TemplateType === Settings.ApptTypeOtherVal) {
                                    return [true, ""];
                                }
                                var dmy = dateText.getDate() + "-" + (dateText.getMonth() + 1) + "-" + dateText.getFullYear();
                                if (!helper.exists(viewModel) || viewModel.selectedDoctor() == null || $.inArray(dmy, viewModel.selectedDoctor().SlotDates()) === -1) {
                                    return [false, "nonAvailDate", "Unavailable"];
                                } else {
                                    if (dmy === today)
                                        return [true, "todayAvailDate"];
                                    return [true, "availDate"];
                                }
                            },
                            onChangeMonthYear: function (y, m, inst) {
                                if (!helper.exists(viewModel.selectedApptType()) || viewModel.selectedApptType().TemplateType === Settings.ApptTypeOtherVal || m === prevMonth) {
                                    return;
                                }
    
                                var day = inst.selectedDay;
                                var currMonth = m;
                                var currYear = y;
    
                                // update calendar slot dates
                                viewModel.updateApptSlots(null, new Date(currYear, currMonth - 1));
    
                                //$(this).datepicker('setDate', new Date(y, m - 1, day));
    
                                //isPreviousClick = (currMonth < prevMonth && currYear <= prevYear) || (currYear < prevYear && currMonth > prevMonth);
                                //if (isPreviousClick) {upd
                                //    if (monthClickIncrement !== 0) {
                                //        monthClickIncrement--;
                                //    }
                                //} else {
                                //    monthClickIncrement++;
                                //}
    
                                //var isPreviousLoad = isPreviousClick && monthClickIncrement % 1 === 0;
                                //if (monthClickIncrement !== 0 && (monthClickIncrement % 2 === 0 || isPreviousLoad)) {
                                //    if (isPreviousLoad) {
                                //        var tempDateM = moment().year(currYear).month(currMonth - 1);
                                //        currMonth = tempDateM.month();
                                //        currYear = tempDateM.year();
                                //    }
                                //    viewModel.updateApptSlots(null, new Date(currYear, currMonth));
                                //}
    
                                prevMonth = m;
                                prevYear = y;
    
                                setTimeout(function () {
                                    // set aria-disabled
                                    inst.dpDiv.find('.ui-datepicker-header > a').attr('aria-disabled', function (index, attr) {
                                        return $(this).hasClass('ui-state-disabled');
                                    });
                                }, 100);
                            },
                            onClose: function () {
                                monthClickIncrement = 0;
                                $("[dp-container]").removeAttr('aria-hidden');      // make the rest of the page accessible again:
                            }
                        }
                    }
    
                    // init datepicker and set date
                    $el.datepicker(options);
                    if (helper.exists(value)) {
                        $el.datepicker("setDate", value);
                    }
    
                    // Add aria-describedby to the button referring to the label
                    var $dpWrapper = $el.closest('.date-picker');
                    $dpWrapper.find('.ui-datepicker-trigger').attr('aria-describedby', $dpWrapper.find('label').attr('id'));
    
                    // handle the field changing
                    ko.utils.registerEventHandler(element, "change", function () {
                        var observable = valueAccessor();
                        observable($el.datepicker("getDate"));
                    });
    
                    // handle disposal (if KO removes by the template binding)
                    ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                        $el.datepicker("destroy");
                    });
    
                },
                update: function (element, valueAccessor) {
                    var value = ko.utils.unwrapObservable(valueAccessor()),
                        $el = $(element),
                        current = $el.datepicker("getDate");
    
                    if (typeof value === "string") {
                        value = new Date(value);
                    }
    
                    // if the updated value is different than the current value, set the datepicker date
                    if (!moment(value).isSame(moment(current), 'day')) {
                        $el.datepicker("setDate", value);
                    }
                }
            };
    
            /**
             * KO Constructors
             * @description mapping json to js objects mainly for additional UI observables and abstraction
             */
            var Resource = function (rJSON, displayName, appointmentTypeId) {
                if (rJSON !== undefined && rJSON != null) {
                    this.ResourceId = rJSON.ResourceId;
                    this.FirstName = rJSON.FirstName;
                    this.LastName = rJSON.LastName;
                    this.Title = rJSON.Title;
                    this.DisplayName = rJSON.DisplayName;
                    this.ADUsername = rJSON.ADUsername;
                    this.ResourceTypeId = rJSON.ResourceTypeId;
                    this.AppointmentTypeId = rJSON.AppointmentTypeId;
                    this.UserId = rJSON.ResourceRefId;
    
                    this.AppointmentSlots = ko.observableArray([]);
                } else {
                    this.ResourceId = Settings.NoPreferenceResourceVal;
                    this.AppointmentTypeId = appointmentTypeId;
                    this.DisplayName = displayName !== undefined ? displayName : null;
                    this.ADUsername = displayName !== undefined ? displayName : null;
                }
                this.SlotDates = ko.observableArray([]);
                this.BookNowApptSlot = ko.observable(null);
                this.IsFirstAvailableQueried = false;
            };
            var AppointmentType = function (apptTypeJSON) {
                this.HospitalId = apptTypeJSON.HospitalId;
                this.AppointmentTypeId = apptTypeJSON.AppointmentTypeId;
                this.Title = apptTypeJSON.Title;
                this.AppointmentReasons = apptTypeJSON.AppointmentReasons;
    
                this.AppointmentTypeImage = apptTypeJSON.AppointmentTypeImage;
                this.AppointmentTypeBackgroundColor = apptTypeJSON.AppointmentTypeBackgroundColor;
                this.AppointmentTypeIconClass = apptTypeJSON.AppointmentTypeIconClass;
    
                this.TemplateType = apptTypeJSON.TemplateType;
                this.AppointmentResources = ko.observableArray(_.map(apptTypeJSON.AppointmentResources, function (r) {
                    return new Resource(r);
                }));
            };
            var OtherResource = function (rJSON, displayName) {
                if (rJSON !== undefined && rJSON != null) {
                    this.RoleName = rJSON.RoleName;
                    this.LoginName = rJSON.LoginName;
                    this.Email = rJSON.Email;
                    this.DisplayName = rJSON.LoginName != null ? rJSON.LoginName.replace(/\./g, ' ') : null;
                } else {
                    this.DisplayName = displayName !== undefined ? displayName : null;
                }
                this.IsNoPreference = rJSON === undefined;
            };
            var ProgressNode = function (index) {
                var self = this;
    
                this.id = index;
                this.alt = ko.observable(index + 1);
                this.isActive = ko.observable(helper.exists(index) && index === 0);
    
                this.classVal = ko.pureComputed(function() {
                    var c = "";
                    if (self.isActive()) {
                        c = "active";
                        // only progress node that needs expiration colors is 3 (select client type, info form)
                        if (self.id === 3 && helper.exists(viewModel) && viewModel.expirationClass().length) {
                            c = c + " " + viewModel.expirationClass();
                        }
                    }
                    return c;
                });
            };
            var NameValuePair = function (rJson) {
                this.ItemName = rJson.ItemName;
                this.Value = rJson.Value;
            };
    
            /**
             * KO ViewModel
             * @description ABS UI is driven from the ViewModel observables and functions
             */
            var ViewModel = function (newValue) {
                var self = this;
    
                // ui panels
                self.panelHeadline = ko.observable(true);
                self.panelApptTypes = ko.observable(true);
                self.panelEmergency = ko.observable(false);
                self.panelCallUs = ko.observable(false);
                self.panelOther = ko.observable(false);
                self.panelOtherDescribeVisit = ko.observable(false);
                self.panelOtherResources = ko.observable(false);
                self.panelOtherDates = ko.observable(false);
                self.panelOtherInput = ko.observable(false);
                self.panelOtherRequested = ko.observable(false);
                self.panelOtherRequestedSuccess = ko.observable(false);
                self.panelApptReasonResource = ko.observable(false);
                self.panelApptNotes = ko.observable(false);
                self.panelAvailability = ko.observable(false);
                self.panelConfirmation = ko.observable(false);
                self.panelSecurityQuestions = ko.observable(false);
                self.panelClientNotFound = ko.observable(false);
                self.panelFinish = ko.observable(false);
    
                // progress
                self.progressNodes = ko.observableArray(_.map(_.range(5), function(i) {
                    return new ProgressNode(i);
                }));
                self.expirationClass = ko.observable("");
                self.setProgressNode = function(isNext, isReset) {
                    var activeNodeIndex = _.findIndex(self.progressNodes(), function(p) {
                        return p.isActive();
                    });
                    if (activeNodeIndex === -1) {
                        return;
                    }
    
                    var activeNode = self.progressNodes()[activeNodeIndex];
                    if (helper.exists(activeNode)) {
    
                        if (isReset) {
                            activeNode.isActive(false);
                            self.progressNodes()[0].isActive(true);
                        } else {
                            // new node is either previous or next
                            var index = isNext ? 1 : -1;
                            var newNode = self.progressNodes()[activeNodeIndex + (index)];
    
                            if (helper.exists(newNode)) {
                                activeNode.isActive(false);
                                newNode.isActive(true);
                            }
                        }
                    }
                }
    
                // back buttons
                self.backToApptType = function (data, event) {
                    self.selectedApptType(null);
                    self.panelApptReasonResource(false);
                    self.panelApptTypes(true);
                    self.setProgressNode(false);
                    $module.focus();
                };
                self.backToReasonResource = function (data, event) {
                    if (self.selectedDoctor()) {
                        self.selectedDoctor().IsFirstAvailableQueried = false;
                    }
                    self.dateAlreadyQueried = false;
                    self.panelApptNotes(false);
                    self.panelApptReasonResource(true);
                };
                self.backToApptNotes = function (data, event) {
                    self.selectedDoctor().IsFirstAvailableQueried = false;
                    self.panelAvailability(false);
                    self.panelApptNotes(true);
                    self.setProgressNode(false);
    
                    $module.find('.' + Settings.PanelClasses.BookingApptNotes).find('textarea').focus();
                };
                self.backToApptConfirmationX = function (data, event) {
                    // if no client type selected, go back to availability
                    if (self.clientType() === "") {
    
                        // warn user about losing current appt slow
                        $modalGoBackFromDraftAppt.modal();
                    } else {
                        // client type selected, go back from on of the below panels
                        if (self.panelClientNotFound()) {
                            self.panelClientNotFound(false);
                            self.panelSecurityQuestions(true);
                        }
                        else if (self.panelSecurityQuestions()) {
                            self.tempClientIsAddress(null);
                            self.selectedTempClientPet(null);
                            self.tempClient(null);
    
                            self.panelSecurityQuestions(false);
    
                            if (self.isActuallyExistingClientFromNewClient()) {
                                self.showNewClientInfoForm(true);
                                $($module.find('.' + Settings.PanelClasses.NewClientForm).find('input').get(0)).focus();
                            } else {
                                self.showExistingClientInfoForm(true);
                                $($module.find('.' + Settings.PanelClasses.ExistingClientForm).find('input').get(0)).focus();
                            }
                        }
                        else if (self.showNewClientInfoForm() || self.showExistingClientInfoForm()) {
                            self.clientType("");
                            self.showNewClientInfoForm(false);
                            self.showExistingClientInfoForm(false);
                            self.showSelectClientType(true);
    
                            $($module.find('.' + Settings.PanelClasses.BookingConfirmation).find('.client button').get(0)).focus();
                        }
                        else {
                            // going back from existing client pet selection
                            self.isClientMatchSuccess(false);
                            self.isPetSelectionRequired(false);
                            self.panelSecurityQuestions(true);
                        }
                    }
                };
                self.backToReqAppt = function (data, event) {
                    // handles which part of req appt client goes back to
                    if (self.panelOtherInput()) {
                        self.panelOtherInput(false);
                        self.panelOtherDates(true);
                    } else if (self.panelOtherDates()) {
                        self.panelOtherDates(false);
                        self.panelOtherResources(true);
                    } else if (self.panelOtherResources()) {
                        self.panelOtherResources(false);
                        self.panelOtherDescribeVisit(true);
                    } else if (self.panelOtherDescribeVisit()) {
                        self.panelOtherDescribeVisit(false);
                        self.panelOther(false);
                        self.panelApptTypes(true);
                        self.selectedApptType(null);
                    }
                    self.setProgressNode(false);
                };
                self.backToApptTypeFromEmergency = function (data, event) {
                    self.selectedApptType(null);
                    self.panelEmergency(false);
                    self.panelCallUs(false);
                    self.panelApptTypes(true);
                };
                self.backToApptTypeFromCallUs = function (data, event) {
                    self.selectedApptType(null);
                    self.panelEmergency(false);
                    self.panelCallUs(false);
                    self.panelApptTypes(true);
                };
                self.backToReqApptClasses = ko.pureComputed(function() {
                    return self.panelOtherRequested() || (Settings.BookingSettings.IsRequestApptPage && self.panelOtherDescribeVisit()) ?
                        "hidden" : "back";
                });
    
                // appt flow
                self.countdownTimer = null;
    
                self.selectedApptType = ko.observable(null);
                self.selectedReason = ko.observable(null);
    
                self.apptNotes = ko.observable("");
                self.apptNotesCount = ko.computed(function () {
                    return Settings.ApptNotesCharLimit - self.apptNotes().length;
                });
                self.bookingApptNotesAriaLive = ko.pureComputed(function () {
    
                    if (self.apptNotesCount() === Settings.ApptNotesCharLimit) {
                        return "polite";
                    }
                    if (self.apptNotesCount() > 70) {
                        return null;
                    }
                    if (self.apptNotesCount() > 20) {
                        return "polite";
                    }
                    return "assertive";
                });
                self.bookingApptNotesAriaAtomic = ko.pureComputed(function () {
                    // ada ref: https://dequeuniversity.com/library/aria/counters/sf-characters-remaining
    
                    if (self.apptNotesCount() > 70) {
                        return null;
                    }
                    if (self.apptNotesCount() > 60) {
                        return "true";
                    }
                    if (self.apptNotesCount() > 20) {
                        return "false";
                    }
                    return "true";
                });
                self.selectApptNotesContinue = function (formElement) {
                    var $form = $(formElement);
                    var $apptNotesTextArea = $form.find('textarea');
    
                    $apptNotesTextArea.validate(function (valid, elem) {
                        if (valid) {
                            self.panelApptNotes(false);
                            self.panelAvailability(true);
                            self.setProgressNode(true);
    
                            isDatepickerReopening = false;
                            $module.find('.' + Settings.PanelClasses.Availability).find('.book-now button').focus();
                        }
                    });
                };
    
                self.selectedDate = ko.observable(null);
                self.selectedDate.subscribe(function (newDate) {
                    self.updateApptSlots();
                });
                self.selectedTime = ko.observable(null);
                self.selectedTime.subscribe(function (newValue) {
                    if (newValue != null && typeof newValue === "object") {
                        self.panelAvailability(false);
                        self.panelConfirmation(true);
    
                        countdown(".time-left span", Settings.BookingSettings.Hospital.OnlineAppointmentExpirationTimeInMinutes, 0);
                        $module.find('.' + Settings.PanelClasses.BookingConfirmation).find('.client > button').focus();
                    }
                    else
                        self.panelConfirmation(false);
                });
    
                self.hospital = Settings.BookingSettings.Hospital;
                self.client = ko.observable(null);
                self.previouslyBooked = false;
                self.tempClient = ko.observable(null);
                self.searchClients = null;
                self.clientPets = ko.pureComputed(function () {
                    return self.client() != null ? self.client().Pets : null;
                });
                self.selectedPet = ko.observable(null);
                self.selectedPetType = ko.observable(null);
                self.newClientSelectedPetType = ko.observable(null);
                self.newClientSubmittedBookingErrorMsgs = ko.observableArray([]);
    
                // user input
                self.firstName = ko.observable("").extend({ titlecase: true });
                self.lastName = ko.observable("").extend({ titlecase: true });
                self.email = ko.observable("");
                self.phone = ko.observable("");
                self.tempPhoneVal = "";
                self.phone.subscribe(function (newVal) {
                    var isSameVal = newVal === self.tempPhoneVal;
                    if (newVal.replace(/[^0-9]/g, "").length === 10 && !isSameVal && self.clientType() === Settings.NewClientTypeVal) {
    
                        var sentParams = {
                            hospitalId: hospitalId,
                            phoneNum: self.phone()
                        };
    
                        // AppointmentRequest
                        $.ajax({
                            url: Settings.BookingControllerUrl + "CarrierLookUp",
                            dataType: 'json',
                            type: 'POST',
                            data: sentParams,
                            success: function (data) {
    
                                if (data) {
                                    self.showCarrierOptIn(true);
                                } else {
                                    self.showCarrierOptIn(false);
                                }
                            },
                            error: function (jqXHR, status, err) {
                                console.log(jqXHR.status + "," + jqXHR.responseText + "," + status + "," + err);
                            }
                        });
                    } else if (!isSameVal) {
                        self.showCarrierOptIn(false);
                    }
                    self.tempPhoneVal = newVal;
                });
                self.carrierOptIn = ko.observable(false);
                self.newPetName = ko.observable("").extend({ titlecase: true });
    
                self.newClientTypeVal = Settings.NewClientTypeVal;              // only used for booking confirmation message in sitecore
                self.clientType = ko.observable("");
                self.clientType.subscribe(function (newValue) {
                    var isNewClient = typeof newValue === "string" && newValue === Settings.NewClientTypeVal;
                    self.showNewClientInfoForm(isNewClient);
                    self.showExistingClientInfoForm(!isNewClient);
                });
                self.isActuallyExistingClientFromNewClient = ko.observable(null);
    
                // appt flow: other
                self.otherApptNotes = ko.observable("");
                self.otherApptNotesAriaLive = ko.pureComputed(function () {
                    //polite
                    if (self.otherApptNotesCount() === Settings.OtherApptNotesCharLimit) {
                        return "polite";
                    }
                    if (self.otherApptNotesCount() > 70) {
                        return null;
                    }
                    if (self.otherApptNotesCount() > 20) {
                        return "polite";
                    }
                    return "assertive";
                });
                self.otherApptNotesAriaAtomic = ko.pureComputed(function () {
                    // ada ref: https://dequeuniversity.com/library/aria/counters/sf-characters-remaining
    
                    if (self.otherApptNotesCount() > 70) {
                        return null;
                    }
                    if (self.otherApptNotesCount() > 60) {
                        return "true";
                    }
                    if (self.otherApptNotesCount() > 20) {
                        return "false";
                    }
                    return "true";
                });
                self.otherApptNotesCount = ko.pureComputed(function () {
                    return Settings.OtherApptNotesCharLimit - self.otherApptNotes().length;
                });
                self.selectOtherApptNotesContinue = function (formElement) {
                    var $form = $(formElement);
                    var $otherApptNotesTextArea = $form.find('textarea');
    
                    $otherApptNotesTextArea.validate(function (valid, elem) {
                        if (valid) {
                            self.panelOtherDescribeVisit(false);
                            self.panelOtherResources(true);
                            self.setProgressNode(true);
                        }
                    });
                }
                self.viewOtherDoctors = ko.observableArray([new OtherResource(null, "No Preference")]);
                self.selectedOtherDoctor = ko.observable(null);
                self.changeOtherDoctor = function (data, event) {
                    self.selectedOtherDoctor(data);
                    $(event.target).closest('.radio-button').find("input").prop("checked", true);
    
                    self.panelOtherResources(false);
                    self.panelOtherDates(true);
                    self.setProgressNode(true);
                }
                self.otherDoctorsQueried = false;
                self.otherTimePeriods = ko.observableArray(Settings.BookingSettings.OtherTimePeriods);
    
                self.getOtherTimePeriodNameByTime = function (time) {
                    var matchingPeriod = _.find(self.otherTimePeriods(), function (tp) { return tp.Value === time });
                    if (matchingPeriod) {
                        return matchingPeriod.ItemName;
                    } 
                };
    
                self.otherPrefDate1 = ko.observable(new Date());
                self.otherPrefTimeOfDay1 = ko.observable(null);
                self.otherPrefDate2 = ko.observable();
                self.otherPrefTimeOfDay2 = ko.observable(null);
                self.otherPrefDate3 = ko.observable();
                self.otherPrefTimeOfDay3 = ko.observable(null);
    
                self.selectOtherApptDatesContinue = function (data, event) {
                    var $target = $(event.target);
    
                    self.panelOtherDates(false);
                    self.panelOtherInput(true);
                    self.setProgressNode(true);
                };
    
                self.otherFirstName = ko.observable("").extend({ titlecase: true });
                self.otherLastName = ko.observable("").extend({ titlecase: true });;
                self.otherEmail = ko.observable("");
                self.otherPhone = ko.observable("");
                self.otherNewPetName = ko.observable("").extend({ titlecase: true });;
                self.otherSelectedPetType = ko.observable("");
                self.selectedOtherClientType = ko.observable("");
    
                self.submitRequest = function (form) {
    
                    // trigger form validation
                    //if (form != null) {
                    //    var isValid = self.validateForm(form);
                    //    if (!isValid) {
                    //        return false;
                    //    }
                    //}
    
                    var sentParams = {
                        HospitalId: hospitalId,
                        HospitalName: Settings.BookingSettings.Hospital.HospitalName,
                        HospitalEmail: Settings.BookingSettings.Hospital.Email,
                        Sitename: VCA.ContextSiteName,
                        OtherClient_FirstName: self.otherFirstName(),
                        OtherClient_LastName: self.otherLastName(),
                        OtherClient_UserName: self.otherEmail(),
                        OtherClient_PhoneNumber: self.otherPhone(),
                        OtherClient_PatientName: self.otherNewPetName(),
                        OtherClient_PatientSpeciesId: self.otherSelectedPetType().SpeciesId,
                        OtherClient_PatientSpeciesName: self.otherSelectedPetType().SpeciesName,
                        OtherClient_ClientType: self.selectedOtherClientType(),
                        OtherClient_PreferredDoctor: self.selectedOtherDoctor().DisplayName,
                        OtherClient_VisitReason: self.otherApptNotes(),
                        OtherClient_PreferredDateTime1: typeof self.otherPrefDate1() !== "undefined" ? moment(self.otherPrefDate1()).format('LL') : null,
                        OtherClient_PreferredDateTime2: typeof self.otherPrefDate2() !== "undefined" ? moment(self.otherPrefDate2()).format('LL') : null,
                        OtherClient_PreferredDateTime3: typeof self.otherPrefDate3() !== "undefined" ? moment(self.otherPrefDate3()).format('LL') : null,
                        OtherClient_PrefTimeOfDay1: self.otherPrefTimeOfDay1(),
                        OtherClient_PrefTimeOfDay2: self.otherPrefTimeOfDay2(),
                        OtherClient_PrefTimeOfDay3: self.otherPrefTimeOfDay3(),
                        LeadTypeId: Settings.BookingSettings.ReqApptLeadTypeId,
                        ReferrerUrl: document.referrer,
                        TrackingUrl: window.location.href
                        // APIUrl: window.location.host + Settings.RequestControllerUrl + "SubmitRequestAppointment"
                    };
    
                    // AppointmentRequest
                    $.ajax({
                        url: Settings.RequestControllerUrl + "SubmitRequestAppointment",
                        dataType: 'json',
                        type: 'POST',
                        data: sentParams,
                        cache: false,
                        success: function (data) {
                            var requestAppt = data;
    
                            self.panelHeadline(false);
                            self.panelApptTypes(false);
                            self.panelOtherInput(false);
                            self.panelOtherDescribeVisit(false);
                            self.panelOtherDates(false);
                            self.panelOtherResources(false);
                            
                            if (requestAppt) {
                                self.panelOtherRequested(true);
                                self.panelOtherRequestedSuccess(true);
    
                                window.dataLayer.push({
                                    'event': 'offer-submission',
                                    'offer-type': 'Request an Appointment',
                                    'appointment-type': 'other',
                                    'appointment-reason': self.otherApptNotes(),
                                    'appointment-client-type': self.selectedOtherClientType(),
                                    'customer-postal-code': '',
                                    'pet-type': self.otherSelectedPetType().SpeciesId,
                                    'lead-type-id': Settings.BookingSettings.ReqApptLeadTypeId,
                                    'lead-type': ''
                                });
                            } else {
                                self.panelOtherRequested(true);
                                self.panelOtherRequestedSuccess(false);
                            }
                        },
                        error: function (jqXHR, status, err) {
    
                            self.panelOther(false);
                            self.bookingIsServiceError(true);
                            console.log(jqXHR.status + "," + jqXHR.responseText + "," + status + "," + err);
                        }
                    });
                    return false;
                };
                self.requestAnotherAppt = function (data, event) {
                    self.resetForm();
                };
    
                // lists
                self.apptTypes = ko.observableArray(_.map(Settings.BookingSettings.AppointmentTypes, function (apptType) { return new AppointmentType(apptType); }));
                self.apptReasons = ko.observableArray([]);
    
                self.viewDoctors = ko.observableArray([]);
                self.selectedDoctor = ko.observable(null);
    
                self.dateAlreadyQueried = false;
                // updates the current selected resource's appt slots
                self.updateApptSlots = function (isNoLongerAvailable, calendarMonthChangeDate) {
                    isNoLongerAvailable = isNoLongerAvailable || false;
                    calendarMonthChangeDate = calendarMonthChangeDate || null;
    
                    var resource = self.selectedDoctor();
                    if (resource === null || typeof resource === "undefined") return;
    
                    if (self.dateAlreadyQueried) {
                        self.dateAlreadyQueried = false;
                        return;
                    }
    
                    // return if setting the first selected date. updateApptSlots will be called again on that subscription
                    if (self.selectedDate() == null) {
                        self.selectedDate(new Date());
                        return;
                    }
    
                    var isNoPreference = resource.ResourceId === Settings.NoPreferenceResourceVal;
                    var totalDaysToFetch = resource.IsFirstAvailableQueried && !calendarMonthChangeDate ? Settings.TotalApptDays : Settings.BookingSettings.Hospital.OnlineAppointmentPreloadingDays;
    
                    var mSelectedDate;
                    if (calendarMonthChangeDate) {
                        mSelectedDate = moment(calendarMonthChangeDate).utc();
                    } else {
                        mSelectedDate = moment(self.selectedDate()).utc();
                    }
    
                    var sentParams = {
                        appointmentTypeId: resource.AppointmentTypeId,
                        resourceId: resource.ResourceId,
                        startDate: mSelectedDate.format(),
                        timeZone: Settings.BookingSettings.Hospital.StandardTimeZoneName,
                        totalDays: totalDaysToFetch,
                        HospitalId: hospitalId
                    };
    
                    // service call to /GetSlots
                    $.ajax({
                        url: Settings.BookingControllerUrl + "GetSlots",
                        dataType: 'json',
                        type: 'POST',
                        data: sentParams,
                        cache: false,
                        success: function (data) {
                            var newSlots = data;
    
                            if (newSlots && newSlots.length) {
    
                                var uniqueSlots, tempSlotDates;
    
                                // if no preference, get first available slot where a matching resourceId is found in the doctor list
                                if (isNoPreference) {
                                    
                                    var matchingFirstSlot = _.find(newSlots, function (s) {
                                        return _.find(self.selectedApptType().AppointmentResources(), function (r) {
                                            return r.ResourceId === s.ResourceId;
                                        });
                                    });
    
                                    // set the selected resource to the matched first slot resource
                                    var matchingResourceToNoPref = _.find(self.selectedApptType().AppointmentResources(), function (r) {
                                        return r.ResourceId === matchingFirstSlot.ResourceId;
                                    });
    
                                    if (matchingResourceToNoPref != null) {
    
                                        var noPrefDocSlots = _.where(newSlots,
                                            { ResourceId: matchingResourceToNoPref.ResourceId }
                                        );
    
                                        // set no preference doctor's book now slot, appt slots, and calendar slot dates
                                        matchingResourceToNoPref.BookNowApptSlot(matchingFirstSlot);
                                        matchingResourceToNoPref.AppointmentSlots(noPrefDocSlots);
    
                                        uniqueSlots = _.uniq(newSlots, function (s) { return s.CalendarDate; });
                                        tempSlotDates = _.map(uniqueSlots, function (s) {
                                            return moment(s.StartTime).format("D-M-Y");
                                        });
                                        matchingResourceToNoPref.SlotDates(tempSlotDates);
    
                                        self.selectedDoctor(matchingResourceToNoPref);
                                    } else {
                                        // no preference could not find a first available resource
                                    }
                                } else {
                                    
                                    // if getting available dates for calendar (month update change)
                                    if (calendarMonthChangeDate) {
                                        uniqueSlots = _.uniq(newSlots, function (s) { return s.CalendarDate; });
                                        tempSlotDates = _.map(uniqueSlots, function (s) {
                                            return moment(s.StartTime).format("D-M-Y");
                                        });
                                        resource.SlotDates(tempSlotDates);
                                    }
                                    else {
                                        var mSelectedDateStart = moment(self.selectedDate()).startOf('day');
    
                                        resource.AppointmentSlots(newSlots);
    
                                        if (!resource.IsFirstAvailableQueried) {
                                            resource.IsFirstAvailableQueried = true;
    
                                            // if the first available date is different from selected date, change selected date to first available appt slot
                                            resource.BookNowApptSlot(newSlots[0]);
                                            var firstAvailDate = newSlots[0].CalendarDate.replace(/Z$/, '');
                                            var firstAvailDateM = moment(firstAvailDate);
    
                                            if (!firstAvailDateM.isSame(mSelectedDateStart, 'day')) {
                                                self.dateAlreadyQueried = true;
                                                self.selectedDate(firstAvailDateM.toDate());
                                            }
                                        }
    
                                        // update calendar slot dates for resource
                                        if (!resource.SlotDates().length) {
                                            uniqueSlots = _.uniq(newSlots, function (s) { return s.CalendarDate; });
                                            tempSlotDates = _.map(uniqueSlots, function (s) {
                                                return moment(s.StartTime).format("D-M-Y");
                                            });
                                            resource.SlotDates(tempSlotDates);
                                        }
                                    }
    
                                    $datepicker.datepicker("refresh");
                                }
                            }
    
                            // make UI changes
                            if (self.selectedReason() != null) {
                                self.panelApptReasonResource(false);
    
                                // only show appt notes panel if not already selecting a time
                                if (!self.panelAvailability()) {
                                    self.panelApptNotes(true);
                                    $module.find('.' + Settings.PanelClasses.BookingApptNotes).find('.back > a').focus();
                                }
                                else if (!$('#ui-datepicker-div').is(':visible')) {
    
                                    // ada: if selected a date from datepicker, set focus to first available appt time slot for date
                                    $module.find('.button-selection button').first().focus();
                                }
                            }
                            // if going back from a selected time/draft appt
                            if (isNoLongerAvailable) {
                                clearInterval(self.countdownTimer);
                                self.panelApptNotes(false);
                                viewModel.panelConfirmation(false);
                                viewModel.panelAvailability(true);
                                $modalGoBackFromDraftAppt.modal('toggle');
                                $module.find('.' + Settings.PanelClasses.Availability).find('.book-now button').focus();
                            }
                        },
                        error: function (jqXHR, status, err) {
                            self.bookingIsServiceError(true);
                            console.log(jqXHR.status + "," + jqXHR.responseText + "," + status + "," + err);
                        }
                    });
                };
                
    
                self.submitReasonAndDoctor = function($form) {
    
                    if (self.selectedDoctor() != null && self.selectedReason() != null) {
                        self.selectedDate(null);
                        self.updateApptSlots();
                    }
                };
    
                self.availableDates = ko.observableArray([]);
                self.availableTimes = ko.computed(function () {
    
                    if (self.selectedDoctor() == null || typeof self.selectedDoctor().AppointmentSlots === "undefined" || self.selectedDoctor().AppointmentSlots().length === 0 || typeof self.selectedDate() !== "object")
                        return [];
    
                    // removed sitecore hospital hours logic, handled by woofware api
                    //var currHospitalBusinessDay = getCurrentHospitalBussinessDay();
    
                    //if (typeof currHospitalBusinessDay === "undefined" || currHospitalBusinessDay == null)
                    //    return [];
    
                    //var openHoursAndMin = currHospitalBusinessDay.OpenTime.split(':');
                    //var closedHoursAndMin = currHospitalBusinessDay.CloseTime.split(':');
                    //if (openHoursAndMin.length < 2 || closedHoursAndMin.length < 2)
                    //    return [];
    
                    // filter by selected date, selected time period, and between hospital hours
                    var apptSlotsBySelectedDateAndHospitalHours = _.filter(self.selectedDoctor().AppointmentSlots(), function (apptSlot) {
    
                        var isSameDate = moment(apptSlot.CalendarDate.replace(/Z$/, '')).isSame(moment(self.selectedDate()), 'day');
                        if (!isSameDate || !apptSlot.IsAvailable) {
                            return false;
                        }
                        return true;
                    });
    
                    return apptSlotsBySelectedDateAndHospitalHours;
                });
                self.petTypes = ko.observableArray(Settings.BookingSettings.PetTypes);
    
                // security questions
                self.tempClientIsAddress = ko.observable(null);
                self.selectedTempClientPet = ko.observable(null);
                self.verifySecurityQuestions = function (data, event) {
    
                    // validate inputs (cant use built in validator..)
                    var isValid = (self.tempClientIsAddress() != null || self.tempClient().Addresses == null) && self.selectedTempClientPet() != null;
                    if (!isValid) {
                        self.securityNotAnswered(true);
                        return;
                    }
                    self.securityNotAnswered(false);
    
                    var patientName = '';
                    var bookAsNewClient = false;
                    var isComingFromNewClient = self.isActuallyExistingClientFromNewClient();       // just like POC's 'model.NewClientInfo'
    
                    var selectedPatientId = self.selectedTempClientPet() != null ? self.selectedTempClientPet().PatientId : 0;
                    var matchingPatient = _.chain(self.searchClients).pluck('Pets').flatten().findWhere({ PatientId: selectedPatientId }).value();
                    if (typeof matchingPatient != "undefined" && matchingPatient != null) {
                        patientName = matchingPatient.PatientName;
                    }
    
                    // find clients by pet that matches selected pet name or client that has no pets that selected 'none of the above' for pet name
                    var matchingClients = _.filter(self.searchClients, function (sc) {
                        var hasNoPetsButSelectedNone = sc.Pets == null && selectedPatientId === 0;
                        if (hasNoPetsButSelectedNone) {
                            return true;
                        }
                        var petMatch = _.find(sc.Pets, function (p) {
                            return p.PatientName === patientName;
                        });
                        return helper.exists(petMatch);
                    });
    
                    // if no matching clients
                    if (typeof matchingClients == "undefined" || matchingClients == null || !matchingClients.length) {
                        if (!isComingFromNewClient) {
                            // client not found
                            self.panelSecurityQuestions(false);
                            self.isClientMatchSuccess(false);
                            self.panelClientNotFound(true);
                            return;
                        }
                        bookAsNewClient = true;
                    }
    
                    // if not booking as new client (after finding an existing client for new client)
                    if (!bookAsNewClient) {
                        // if there's only 1 search client and the mailing address was a no
                        var addressAnsweredNo = self.tempClientIsAddress() != null && !self.tempClientIsAddress();
                        if (self.searchClients.length === 1 && addressAnsweredNo) {
                            if (!isComingFromNewClient) {
                                // client no found
                                self.panelSecurityQuestions(false);
                                self.isClientMatchSuccess(false);
                                self.panelClientNotFound(true);
                                return;
                            }
                            bookAsNewClient = true;
                        }
                    }
    
                    // if not booking as new client (again, because we possibly set this to true above)
                    if (!bookAsNewClient) {
                        // first client has highest weightage, so it aligns with a yes on the mailing address
                        var firstClientId = self.searchClients[0].ClientId;
    
                        // if mailing address is a yes
                        if (self.tempClientIsAddress()) {
    
                            var matchingAddressClient = _.find(matchingClients, function (c) {
                                return c.ClientId === firstClientId;
                            });
    
                            if (helper.exists(matchingAddressClient)) {
                                // client found
                                self.client(matchingAddressClient);
                            } else {
                                if (!isComingFromNewClient) {
                                    // client not found
                                    self.panelSecurityQuestions(false);
                                    self.isClientMatchSuccess(false);
                                    self.panelClientNotFound(true);
                                    return;
                                }
                                bookAsNewClient = true;
                            }
                        }
                        else {    // mailing address is a no
                            var clientWithDifferentAddressMatchingPet = matchingClients.length > 1 ?
                                _.find(matchingClients, function (c) { return c.ClientId !== firstClientId }) :
                                matchingClients[0];
    
                            self.client(clientWithDifferentAddressMatchingPet);
                        }
                    }
    
                    // if not booking as new client (again, last time)
                    if (!bookAsNewClient) {
                        if (self.client() != null) {
                            // set client found panel
                            self.panelSecurityQuestions(false);
                            self.isClientMatchSuccess(true);
    
                            // prepopulate the 'new pet' name and species info
                            if (helper.exists(self.newClientSelectedPetType())) {
                                self.selectedPetType(self.newClientSelectedPetType());
                            }
                        } else {
                            // client not found
                            self.panelSecurityQuestions(false);
                            self.isClientMatchSuccess(false);
                            self.panelClientNotFound(true);
                            return;
                        }
                    }
    
                    // if the new client that was pushed to verify an existing count actually is a new client
                    if (isComingFromNewClient && !helper.exists(self.client())) {
                        // book appointment
                        self.bookAppointment(null);
                    }
                };
    
                // ui helpers
                self.showSelectClientType = ko.observable(true);
                self.showNewClientInfoForm = ko.observable(false);
                self.showExistingClientInfoForm = ko.observable(false);
                self.isClientMatchSuccess = ko.observable(false);
                self.showCarrierOptIn = ko.observable(false);
                self.securityNotAnswered = ko.observable(false);
    
                // ui helpers: booking flow
                self.bookingValidationMessage = ko.observable("");
                self.bookingIsServiceError = ko.observable(false);
                self.bookingIsNoLongerAvailable = ko.observable(false);
                self.bookingIsSessionTimeOut = ko.observable(false);
                self.bookingIsAppointmentBooked = ko.observable(false);
    
                self.showExistingClientNewPetSelection = ko.pureComputed(function () {
                    return (self.clientPets() != null && self.clientPets().length > 0) || (self.isActuallyExistingClientFromNewClient() != null && !self.isActuallyExistingClientFromNewClient());
                });
    
                self.setOptionValue = function (propId) {
                    return function (option, item) {
                        if (item === undefined) {
                            option.value = "";
                        } else {
                            option.value = item[propId];
                        }
                    }
                };
                self.hospitalDirectionsUrl = function () {
                    var hospital = Settings.BookingSettings.Hospital;
                    var address = hospital.HospitalName + hospital.AddressLine1 + ", " + hospital.City + ", " + hospital.State + ", " + hospital.ZipCode;
                    return 'http://maps.google.com/?daddr=' + address;
                }
                self.resetApptTypePanels = function () {
                    self.panelOther(false);
                    self.panelCallUs(false);
                    self.panelApptNotes(false);
                    self.panelEmergency(false);
                    self.panelApptReasonResource(false);
                }
                self.formattedTime = function (startTime, momentStringFormat) {
                    momentStringFormat = momentStringFormat || "h:mm A";
                    return moment(startTime).format(momentStringFormat);
                };
                self.iconClasses = function (apptType) {
                    return $.grep([apptType.AppointmentTypeBackgroundColor, apptType.AppointmentTypeIconClass], Boolean).join(" ");
                };
                self.resetForm = function () {
    
                    self.panelApptReasonResource(false);
                    self.panelAvailability(false);
                    self.panelConfirmation(false);
                    self.panelFinish(false);
    
                    self.panelHeadline(true);
                    self.panelApptTypes(true);
    
                    self.selectedApptType(null);
                    self.selectedDoctor(null);
                    self.selectedReason(null);
                    self.selectedTime(null);
                    self.selectedDate(null);
                    self.isPetSelectionRequired(false);
                    self.clientType("");
                    $module.find("input[type=radio]").prop("checked", false);
    
                    // reset date queries and progress node
                    self.dateAlreadyQueried = false;
                    self.setProgressNode(false, true);
    
                    // other client type
                    self.panelOther(false);
                    self.panelOtherDescribeVisit(false);
                    self.panelOtherResources(false);
                    self.panelOtherDates(false);
                    self.panelOtherInput(false);
                    self.panelOtherRequested(false);
                    self.otherFirstName("");
                    self.otherLastName("");
                    self.otherEmail("");
                    self.otherPhone("");
                    self.otherNewPetName("");
                    self.otherSelectedPetType("");
                    self.selectedOtherClientType("");
    
                    // ada
                    $module.focus();
                };
                self.changeDoctor = function (doctor, event) {
    
                    self.selectedDoctor(doctor);
    
                    if (doctor == null && typeof event === "undefined") {
                        $('.step-appt-reason-resource .doctors .radio-button input').prop("checked", false);
                    } else if (typeof event !== "undefined" && event != null) {
                        $(event.target).closest('.radio-button').find("input").prop("checked", true);
                    }
                };
                self.changeReason = function (reason, event) {
                    self.selectedReason(reason);
                    $(event.target).closest('.radio-button').find("input").prop("checked", true);
                };
                self.changeApptType = function (type) {
                    if (type === self.selectedApptType()) {
                        return;
                    }
    
                    self.selectedApptType(type);
                    self.panelApptTypes(false);
                    
                    if (Settings.BookingSettings.IsRequestApptPage && Settings.BookingSettings.DisplayReqAppt) {
                        Settings.ApptTypeOtherVal = "Appointment Type Other";
                        Settings.ApptTypeCallUsVal = "Appointment Other";
                    }
                    else{
                        Settings.ApptTypeCallUsVal="Appointment Type Other";
                        Settings.ApptTypeOtherVal = "Appointment Other";
                    }
                  
    
                    //check if Call Us panel should be displayed 
                    if (type.TemplateType === Settings.ApptTypeEmergencyVal) {
                        self.panelEmergency(true);
                    } else if (type.TemplateType === Settings.ApptTypeCallUsVal) {
                        self.panelCallUs(true);
                    }
                    else if (type.TemplateType === Settings.ApptTypeOtherVal) {
                        if (!self.otherDoctorsQueried) {
                            
                            var sentParams = { Roles: VCA.BookingSettings.ReqApptRole, Operations: null, HospitalId: hospitalId, Sitename: VCA.ContextSiteName };
                            $.ajax({
                                url: Settings.BookingControllerUrl + "GetStaffMembers",
                                dataType: 'json',
                                type: 'POST',
                                data: sentParams,
                                success: function (result) {
                                    var staffs = result;
    
                                    if (staffs != null) {
                                        self.viewOtherDoctors.pushAll(_.map(staffs, function (s) { return new OtherResource(s); }));
                                    }
                                    self.panelOther(true);
                                    self.panelOtherDescribeVisit(true);
                                    self.setProgressNode(true);
                                },
                                error: function (jqXHR, status, err) {
                                    console.log(jqXHR.status + "," + jqXHR.responseText + "," + status + "," + err);
    
                                    self.bookingIsServiceError(true);
                                }
                            }).done(function () { self.otherDoctorsQueried = true; });
                        } else {
                            self.panelOther(true);
                            self.panelOtherDescribeVisit(true);
                            self.setProgressNode(true);
                        }
                        } 
                    else {
                        self.panelApptReasonResource(true);
                        self.setProgressNode(true);
                    }
    
                    // set corresponding appt reasons and selected resources
                    self.apptReasons(type.AppointmentReasons);
                    self.selectedReason(null);
                    self.apptNotes('');
                    self.viewDoctors.removeAll();
                    self.viewDoctors.push(new Resource(null, "No Preference", self.selectedApptType().AppointmentTypeId));
                    ko.utils.arrayPushAll(self.viewDoctors, type.AppointmentResources());
                };
                self.selectTime = function (time, event) {
    
                    if (self.selectedTime() !== null && self.selectedTime() === time) {
                        return false;
                    }
    
                    // set booking placeholder
                    var sentParams = {
                        HospitalId: hospitalId,
                        Resource: self.selectedDoctor(),
                        AppointmentTypeId: self.selectedApptType().AppointmentTypeId,
                        AppointmentReasonId: self.selectedReason().AppointmentReasonId,
                        AppointmentNotes: self.apptNotes(),
                        BookingStartDateTime: time.StartTime,
                        BookingEndDateTime: time.EndTime,
                        HospitalExpirationTimeInMinutes: Settings.BookingSettings.Hospital.OnlineAppointmentExpirationTimeInMinutes
                    };
    
                    // API/Appointments: POST, API/BookDraftAppointment: PUT
                    $.ajax({
                        url: Settings.BookingControllerUrl + "BookDraftAppointment",
                        dataType: 'json',
                        type: 'POST',
                        data: sentParams,
                        cache: false,
                        success: function (data) {
                            var draftAppt = data;
    
                            // if already taken or service error w/ this time slot
                            if (draftAppt.IsServiceError) {
    
                                // show generic service error msg modal
                                if (draftAppt.GenericServiceErrorMessage != null) {
                                    $modalServiceGeneric.find('.modal-body').empty().append($('<p>').text(draftAppt.GenericServiceErrorMessage));
                                }
                                // reload doctors appt slots
                                self.updateApptSlots(true);
    
                                return;
                            } else {
                                // set selected time and move on to appt details
                                self.selectedTime(time);
                                self.setProgressNode(true);
                            }
    
                        },
                        error: function (jqXHR, status, err) {
    
                            self.bookingIsServiceError(true);
                            console.log(jqXHR.status + "," + jqXHR.responseText + "," + status + "," + err);
                        }
                    });
    
                    return false;
                };
                self.selectExistingClient = function () {
                    self.clientType(Settings.ExistingClientTypeVal);
                    self.showSelectClientType(false);
    
                    self.showNewClientInfoForm(false);
                    self.showExistingClientInfoForm(true);
    
                    $($module.find('.' + Settings.PanelClasses.ExistingClientForm).find('input').get(0)).focus();
                };
                self.selectNewClient = function () {
                    self.clientType(Settings.NewClientTypeVal);
                    self.showSelectClientType(false);
    
                    self.showExistingClientInfoForm(false);
                    self.showNewClientInfoForm(true);
    
                    $($module.find('.' + Settings.PanelClasses.NewClientForm).find('input').get(0)).focus();
                };
                self.bookAsNewClient = function (data, event) {
                    self.isClientMatchSuccess(false);
                    self.panelClientNotFound(false);
                    self.selectNewClient();
                }
                self.selectExistingClientLookup = function ($form) {
    
                    var isNewClientCheck = !$form;
                    if (!isNewClientCheck) {
                        // existing client form validation before booking submit
                        var isValid = self.validateForm($form);
                        if (!isValid) {
                            return;
                        }
                    }
    
                    // API: SearchClient: POST
                    var sentParams = {
                        HospitalId: hospitalId,
                        FirstName: self.firstName(),
                        LastName: self.lastName(),
                        Email: self.email(),
                        PhoneNumber: self.phone()
                    }
    
                    $.ajax({
                        url: Settings.BookingControllerUrl + "SearchClient",
                        dataType: 'json',
                        type: 'POST',
                        data: sentParams,
                        cache: false,
                        success: function (result) {
    
                            self.searchClients = result.SearchClients;
                            if (self.searchClients != null && self.searchClients.length) {
    
                                // push 'none' pet to radio btn options
                                if (result.TempClient != null) {
                                    result.TempClient.Pets.push({ PatientId: 0, PatientName: "None of these are my pet", ClientId: 0 });
                                    self.tempClient(result.TempClient);
                                }
    
                                // new client may actually be existing, change to existing state (for security questions)
                                if (isNewClientCheck) {
                                    self.clientType(Settings.ExistingClientTypeVal);
                                    self.isActuallyExistingClientFromNewClient(true);
                                } else {
                                    self.isActuallyExistingClientFromNewClient(false);
                                }
    
                                // security panel to identify actual client
                                self.showNewClientInfoForm(false);
                                self.showExistingClientInfoForm(false);
                                
                                self.panelSecurityQuestions(true);
                            } else {
                                // no client found. 
                                self.isClientMatchSuccess(false);
    
                                // if coming from new client check, we can now book appt
                                if (isNewClientCheck) {
                                    self.isActuallyExistingClientFromNewClient(false);
                                    self.bookAppointment(null);
                                } else {
                                    self.showNewClientInfoForm(false);
                                    self.showExistingClientInfoForm(false);
                                    self.panelClientNotFound(true);
                                }
                            }
                        },
                        error: function (jqXHR, status, err) {
                            self.bookingIsServiceError(true);
                            console.log(jqXHR.status + "," + jqXHR.responseText + "," + status + "," + err);
                        }
                    });
                }
                self.selectExistingPet = function (pet) {
                    $(event.target).closest('.existing-client_pet-selection').find('.new-pet-group').removeClass('fade-in').addClass('hide');
                    self.selectedPet(pet);
                }
                self.selectNewPet = function (data, event) {
                    self.selectedPet(0);
                    self.isPetSelectionRequired(false);
    
                    // show 'add your pets info' form fields
                    $(event.target).closest('.existing-client_pet-selection').find('.new-pet-group').removeClass('hide').addClass('fade-in');
                }
                self.isPetSelectionRequired = ko.observable(false);
    
                // create and book appointment
                self.bookAppointment = function (form) {
    
                    // if client type is 'new'
                    if (self.clientType() === Settings.NewClientTypeVal) {
    
                        // if haven't check that new client isn't actually 'existing'
                        if (self.isActuallyExistingClientFromNewClient() == null) {
    
                            self.selectExistingClientLookup(null);
                            return false;
                        }
                    } else {
                        // client type 'existing': if not selecting a new pet, an existing pet selection is required
                        if (self.selectedPet() !== 0 && self.selectedPet() == null) {
                            self.isPetSelectionRequired(true);
                            return false;
                        }
                    }
    
                    // BookApptParams
                    var sentParams = {
                        DatasourceId: Settings.BookingSettings.DatasourceId,
                        HospitalId: hospitalId,
                        Client: self.client(),
                        NewClientFirstName: self.firstName(),
                        NewClientLastName: self.lastName(),
                        NewClientUserName: self.email(),
                        NewClientPhoneNumber: self.phone(),
                        IsTextOptIn: self.carrierOptIn(),
                        IsCellPhoneType: self.showCarrierOptIn(),
                        Resource: self.selectedDoctor(),
                        PatientId: self.selectedPet() ? self.selectedPet().PatientId : 0,
                        NewPatientName: self.newPetName(),
                        NewPatientSpeciesId: self.selectedPetType() ?
                            self.selectedPetType().SpeciesId : self.newClientSelectedPetType() ? self.newClientSelectedPetType().SpeciesId : 0,
                        NewPatientSpeciesName: self.selectedPetType() ?
                            self.selectedPetType().SpeciesName : self.newClientSelectedPetType() ? self.newClientSelectedPetType().SpeciesName : "Other",
                        VerifyExistingAppointment: true,
                        IsPrimaryHospital: Settings.BookingSettings.IsPrimaryHospital,
                        ReferrerUrl: document.referrer,
                        TrackingUrl: window.location.href,
                        ReasonText: self.selectedReason().Reason
                    }
    
                    // API/Appointments: POST, API/BookAppointment: PUT
                    $.ajax({
                        url: Settings.BookingControllerUrl + "BookAppointment",
                        dataType: 'json',
                        type: 'POST',
                        data: sentParams,
                        cache: false,
                        success: function (data) {
                            var appt = data;
    
                            if (appt == null) {
                                self.bookingIsServiceError(true);
                                return;
                            }
    
                            if (appt.InputErrorMessages != null) {
                                self.newClientSubmittedBookingErrorMsgs(appt.InputErrorMessages);
                                return;
                            }
    
                            self.bookingValidationMessage(appt.ValidationMessage);
                            self.bookingIsAppointmentBooked(appt.IsAppointmentBooked);
                            self.bookingIsNoLongerAvailable(appt.IsNoLongerAvailable);
                            self.bookingIsServiceError(appt.IsServiceError);
                            self.bookingIsSessionTimeOut(appt.IsSessionTimeOut);
    
                            // if validation failure, show modal w/ validation message
                            if (appt.ValidationMessage != null && appt.ValidationMessage.length) {
    
                                // append service message
                                var $p = $('<p>').text(self.bookingValidationMessage());
    
                                $modalValidationFailure.find('.modal-body').empty().append($p);
                                $modalValidationFailure.modal({
                                    keyboard: false,
                                    backdrop: 'static'
                                });
                            }
    
                            // show finished panel
                            self.finish(!appt.IsServiceError && appt.ValidationMessage == null);
    
                            // if appt is booked
                            if (appt.IsAppointmentBooked) {
    
                                addthisevent.refresh();
    
                                try {
                                    // datalayer push
                                    var clientAddressWithZip = self.client() != null ? _.find(self.client().Addresses, function (a) {
                                        return a.ZipCode.length;
                                    }) : null;
    
                                    // pet type options: existing client pet type, existing client new pet type, new client pet type
                                    var petType = self.selectedPet() ? self.selectedPet().SpeciesId :
                                        self.selectedPetType() ? self.selectedPetType().SpeciesId :
                                        self.newClientSelectedPetType() ? self.newClientSelectedPetType().SpeciesId : 0;
    
                                    window.dataLayer.push({
                                        'event': 'offer-submission',
                                        'offer-type': 'Book an Appointment',
                                        'appointment-type': self.selectedApptType() ? self.selectedApptType().Title : null,
                                        'appointment-reason': self.selectedReason() ? self.selectedReason().Reason : null,
                                        'appointment-client-type': self.clientType(),
                                        'customer-postal-code': clientAddressWithZip ? clientAddressWithZip.ZipCode : null,
                                        'pet-type': petType,
                                        'lead-type-id': Settings.BookingSettings.BookApptLeadTypeId,
                                        'lead-type': ''
                                    });
                                } catch (e) {
                                    console.log("bookAppointment dataLayer push failed: " + e.message);
                                }
                            }
    
                        },
                        error: function (jqXHR, status, err) {
    
                            self.bookingIsServiceError(true);
                            console.log(jqXHR.status + "," + jqXHR.responseText + "," + status + "," + err);
                        }
                    });
                    return false;
                };
    
                self.expediteExistingClient = function (newClient) {
                    self.client(newClient);
    
                    self.showNewClientInfoForm(false);
                    self.showExistingClientInfoForm(false);
    
                    self.showSelectClientType(false);
                    self.isClientMatchSuccess(true);
                };
    
                // validator.js handles form fields
                self.validateForm = function (form) {
                    var myLang = {}, myConf = {};
                    if (!$(form).isValid(myLang, myConf)) {
                        return false;
                    }
                    return true;
                }
                self.checkInputs = function () {
                    var valid = true;
    
                    // pet type selection: based on new vs existing client
                    if (self.clientType() === Settings.NewClientTypeVal) {
                        if (self.newPetName().length < 0)
                            valid = false;
                        if (self.newClientSelectedPetType() == null || self.newClientSelectedPetType().length < 0)
                            valid = false;
                    } else {
                        if (!(self.selectedPetType().length > 0)) {
                            valid = false;
                        }
                    }
    
                    return valid;
                };
                // show finished panel if no service errors (finished panel includes non-booked sections aswell)
                self.finish = function (isNotServiceError) {
                    isNotServiceError = isNotServiceError == null ? true : isNotServiceError;
    
                    self.panelApptTypes(false);
                    self.panelApptReasonResource(false);
                    self.panelApptNotes(false);
                    self.panelAvailability(false);
                    self.panelConfirmation(false);
                    self.panelHeadline(!self.bookingIsAppointmentBooked);
                    self.panelFinish(isNotServiceError);
    
                    if (isNotServiceError) {
                        self.setProgressNode(true);
                    }
    
                    clearInterval(self.countdownTimer);
                    $(".time-left").attr('class', 'time-left');     // clear time-left color classes
                };
    
                // addthisevent data-bindings
                self.addthisevent_title = ko.pureComputed(function() {
                    var petName = self.selectedPet() != null && self.selectedPet() !== 0 ? self.selectedPet().PatientName : self.newPetName();
                    return VCA.BookingSettings.AddThisEvent.Title.replace(VCA.BookingSettings.Tokens.PetName, petName);
                });
                self.addthisevent_description = ko.pureComputed(function () {
                    var description = "";
                    var doctorName = self.selectedDoctor() != null ? self.selectedDoctor().DisplayName : '';
                    var apptReason = self.selectedReason() != null && self.selectedReason().Reason !== '' ? self.selectedReason().Reason : null;
                    var apptNotes = self.apptNotes();
    
                    if (helper.exists(VCA.BookingSettings.AddThisEvent)) {
                        if (apptReason != null) {
                            description = VCA.BookingSettings.AddThisEvent.DescriptionWithReason;
                        } else if (apptNotes !== "") {
                            description = VCA.BookingSettings.AddThisEvent.DescriptionWithUnknownReason;
                        } else {
                            description = VCA.BookingSettings.AddThisEvent.DescriptionWithUnknownReasonAndNoNotes;
                        }
                    }
    
                    var updatedDescr = description
                        .replace(VCA.BookingSettings.Tokens.Doctor, doctorName)
                        .replace(VCA.BookingSettings.Tokens.AppointmentReason, apptReason)
                        .replace(VCA.BookingSettings.Tokens.AppointmentNotes, apptNotes);
                    return updatedDescr;
                });
            }
    
            function setVars() {
                if (typeof VCA === "undefined" || typeof VCA.BookingSettings === "undefined")
                    return false;
    
                hospitalId = VCA.HospitalId;
    
                $module = $('.appointment-module');
                $datepicker = $('#datepicker-booking');
                $modalBookingExpiration = $('.modal-booking-expiration');
                $modalGoBackFromDraftAppt = $('.modal-draft-appt-back');
                $modalValidationFailure = $('.modal-validation-failure');
                $modalServiceGeneric = $('.modal-service-generic');
    
                // set data from view (not setting whole object incase data needs js sanitation)
                Settings.BookingSettings.DatasourceId = VCA.BookingSettings.DatasourceId;
                Settings.BookingSettings.Hospital = VCA.BookingSettings.Hospital;
                Settings.BookingSettings.HospitalBusinessDays = VCA.BookingSettings.HospitalBusinessDays;
                Settings.BookingSettings.HospitalHomeUrl = VCA.BookingSettings.HospitalHomeUrl;
                Settings.BookingSettings.AppointmentTypes = VCA.BookingSettings.AppointmentTypes;
    
                Settings.BookingSettings.SSOClient = VCA.BookingSettings.SSOClient;
                Settings.BookingSettings.IsPrimaryHospital = VCA.BookingSettings.IsPrimaryHospital;
                Settings.BookingSettings.WWClient = VCA.BookingSettings.WWClient;
    
                Settings.BookingSettings.BookApptLeadTypeId = VCA.BookingSettings.BookApptLeadTypeId;
                Settings.BookingSettings.ReqApptLeadTypeId = VCA.BookingSettings.ReqApptLeadTypeId;
                Settings.BookingSettings.IsRequestApptPage = VCA.BookingSettings.IsRequestApptPage;
                Settings.BookingSettings.DisplayReqAppt = VCA.BookingSettings.DisplayReqAppt;
                Settings.BookingSettings.PetTypes = VCA.BookingSettings.PetTypes;
                Settings.BookingSettings.OtherTimePeriods = VCA.BookingSettings.OtherTimePeriods;
    
                Settings.ApptNotesCharLimit = VCA.BookingSettings.ApptNotesCharLimit;
                Settings.OtherApptNotesCharLimit = VCA.BookingSettings.OtherApptNotesCharLimit;
    
                if (!helper.exists(hospitalId) || !helper.exists($module) || !helper.exists($datepicker))
                    return false;
    
                return true;
            }
    
            function setEvents() {
                $modalBookingExpiration.on('hide.bs.modal', function () {
                    viewModel.resetForm();
                });
    
                $modalGoBackFromDraftAppt.find('button.back').on('click', function (e) {
    
                    // if back accepted, reload current days appt slots so that the draft appt slot is gone and the first available is refreshed
                    viewModel.selectedDoctor().IsFirstAvailableQueried = false;
                    viewModel.dateAlreadyQueried = true;
                    viewModel.selectedDate(new Date());
                    viewModel.updateApptSlots(true);        // we manually call this method after changing the date to today. we don't want to auto-call it by changing the selected date above (wouldn't be able to pass in params)
                    viewModel.setProgressNode(false);
                });
    
                $modalValidationFailure.find('button').on('click', function (e) {
                    // redirect to hospital home
                    window.location.href = Settings.BookingSettings.HospitalHomeUrl;
                });
            }
    
            /**
             * Module Start
             */
            function init() {
    
                var isReady = setVars();
                if (isReady) {
    
                    // ko databind
                    viewModel = new ViewModel();
                    ko.applyBindings(viewModel, $module.get(0));
    
                    // if client booking again, expediate process to select pet and submit booking (after required selections)
                    var alreadyExpedited = false;
                    if (Settings.BookingSettings.SSOClient !== null) {
    
                        // if logged-in user and primary hospital
                        if (Settings.BookingSettings.IsPrimaryHospital) {
                            alreadyExpedited = true;
                            viewModel.expediteExistingClient(Settings.BookingSettings.SSOClient);
                        }
                        else if (Settings.BookingSettings.WWClient == null) {
                            // logged-in user on other hospital that hasn't booked here yet: force to 'new client' and populate inputs
                            viewModel.selectNewClient();
                        }
    
                        // pre-fill user ko fields
                        var pEmail = _.find(Settings.BookingSettings.SSOClient.ClientEmails, function (e) {
                            return e.IsPrimary && e.Email != null && e.Email.length;
                        });
    
                        viewModel.firstName(Settings.BookingSettings.SSOClient.FirstName);
                        viewModel.lastName(Settings.BookingSettings.SSOClient.LastName);
                        viewModel.email(pEmail);
                    }
                    if (!alreadyExpedited && Settings.BookingSettings.WWClient != null) {
    
                        viewModel.expediteExistingClient(Settings.BookingSettings.WWClient);
                        viewModel.firstName(Settings.BookingSettings.WWClient.FirstName);
                        viewModel.lastName(Settings.BookingSettings.WWClient.LastName);
                    }
    
                    // if req appt page
                    if (Settings.BookingSettings.IsRequestApptPage) {
                        viewModel.changeApptType(_.find(viewModel.apptTypes(), function (a) {
                            return a.TemplateType === Settings.ApptTypeOtherVal;
                        }));
                        viewModel.panelApptTypes(false);
                    } else {
                        // if appt-type in query string, pre-select
                        var preselect = helper.getURIParameterByName("apptType");
                        if (preselect != null) {
                            var matchingApptType = _.find(viewModel.apptTypes(), function (aptType) { return aptType.Title.toLowerCase() === preselect.toLowerCase() });
                            if (typeof matchingApptType !== "undefined") {
                                viewModel.changeApptType(matchingApptType);
                            }
                        }
                    }
    
                    setEvents();
                }
            }
    
            return {
                init: init()
            }
        })();
    };
    },{"helper":44,"jquery-ui":61,"jqueryFormValidator":53,"knockout":64,"underscore":66}],8:[function(require,module,exports){
    var ko = require("knockout");
    var _ = require("underscore");
    var helper = require("helper");
    
    exports.init = function ($) {
    
        var ClientNotFound = (function () {
    
            var $module;
    
            function setVars() {
    
                // elements
                $module = $('.client-not-found-page');
    
                if ($module.length > 0) {
                    return true;
                }
            };
    
            function init() {
                try {
                    var isReady = setVars();
                    if (isReady) {
                        if (window.dataLayer){
                            var authMethod = $('#auth-method').val();
                            console.log('authMethod', authMethod);
                            dataLayer.push({
                                'event': 'sign-up-auth',
                                'auth-method': authMethod,
                                'auth-status': 'fail'
                                });
                        }
                    }
                } catch (ex) {
                    console.log("Client Not Found Component error: " + ex);
                   $module.find('.technical-error').addClass('active');
                }
            };
    
            return {
                init: init()
            }
        })();
    };
    },{"helper":44,"knockout":64,"underscore":66}],9:[function(require,module,exports){
    var ko = require("knockout");
    var _ = require("underscore");
    var helper = require("helper");
    
    exports.init = function ($) {
        
    
    
        var Dashboard = (function () {
            var $module;
    
            
            // ko viewmodel
            var ViewModel = function (obj) {
                var self = this;
    
                self.clickPet = function(item, event){
                    if (window.dataLayer) {
                        window.dataLayer.push({ 'event': 'pet-profile', 'userAction': 'click' });
                    }
                    setTimeout(function(){
                        var url = $(event.target).attr('href');
                        window.location = url;
                    },500);
                };
            };
    
            function setEvents() {
                
            };
    
            function setVars() {
                
                // elements
                $module = $('.main-dash-board');
    
                if ($module.length > 0) {
                    return true;
                }
            };
    
            function setBgImg() {
                var mq = window.matchMedia('(max-width: 1023px) and (min-width: 0px)');
                var profileComponent = $('.profile-component');
                var myvcaProfileTop = $('.myvca-profile-top');
                var profileComponentHeight = profileComponent.height();
                var profileComponentWidth = profileComponent.width();
                var myvcaProfileTopHeight = myvcaProfileTop.height();
    
                var mainDashBg = $('.main-dash-bg,.main-dash-bg-bg');
                mainDashBg.width(profileComponentWidth);
    
                if (mq.matches) {
                    mainDashBg.height(Math.floor(myvcaProfileTopHeight*0.75));
                } else {
                    mainDashBg.height(profileComponentHeight);
                }
            }
    
            function init() {
                try {
                    var isReady = setVars();
                    if (isReady) {
    
                        setEvents();
                        setBgImg();
                        $(window).on('resize', function(){
                            setBgImg();
                        });
                        
                        if (window.dataLayer){
                            var authMethod = $('#auth-method').val();
                            var numProfiles = $('#num-profiles').val();
                            console.log('authMethod', authMethod);
                            console.log('numProfiles', numProfiles);
                            dataLayer.push({
                                'event': 'login-auth',
                                'auth-method': authMethod,
                                'number-profiles': numProfiles
                            });
                        }
                        
                    }
                } catch (ex) {
                    console.log("Dashboard error: " + ex);
                    $module.find('.technical-error').addClass('active');
                }
            };
    
            return {
                init: init()
            }
    
        })();
    
    };
    },{"helper":44,"knockout":64,"underscore":66}],10:[function(require,module,exports){
    var $ = require("jquery");
    var helper = require('../utils/helper.js');
    var ko = require("knockout");
    var _ = require("underscore");
    
    exports.init = function () {
        
        function BreedListing() {
            var $module = $('.dog-breed');
            var $navTabs = $module.find('.db-tabs .nav-tabs .clickable');
            var $tabContent = $module.find('.tab-content');
    
            $navTabs.on('click', function (e) {
                var selectedLetter = $(this).text();
                //console.log($tabContent.find("#" + selectedLetter).attr('id'));
                $.each($('#' + selectedLetter + ' .breed-info-block img'), function (ind, elem) {
                    var attr = $(elem).attr('data-breed-img-src');
                    $(elem).attr('src', attr);
                });
            });
    
            $module.find('.filter.mobile-only select').on('change', function() {
                var $this = $(this);
                var $tab = $this.closest('.db-tabs').find(".nav-tabs > li > a[aria-controls='" + $this.val() + "']");
    
                if ($tab.length) {
                    $tab.first().trigger('click');
                }
            });
        }//end of breed listing
    
        BreedListing();
    };
    },{"../utils/helper.js":44,"jquery":63,"knockout":64,"underscore":66}],11:[function(require,module,exports){
    var viewport = require("../utils/viewport");
    var helper = require("helper");
    require("dotdotdot");
    
    exports.init = function ($) {
    
        var vWidth = viewport.get().width;
        function setUpDotDotDot() {
            $(".featured-content-listing .content p").dotdotdot({
                height: 50
            });
    
            $(".featured-staff-detail .content").dotdotdot({
                height: 450,
                after: "a.fancy"
            });
    
            $(".vet-resource-listing .generic-callout p").dotdotdot({
                height: 60
            });
    
            $(".callout-list-wrapper:not(.unique) .generic-callout p").dotdotdot({
                height: 100
            });
    
            $(".pet-health-tabbed-listing .generic-callout p").dotdotdot({
                height: 80
            });
    
            $('.pet-health-tabbed-listing a[data-toggle="tab"]').on('shown.bs.tab', function (e) {
                var $currentTab = $(e.target),
                    $allTabs = $('.pet-health-tabbed-listing a[data-toggle="tab"]');
    
                $allTabs.attr("aria-selected", "false");
    
                $currentTab.attr("aria-selected", "true");
    
                $(".pet-health-tabbed-listing .generic-callout p").dotdotdot({
                    height: 80
                });
            });
    
            // 50-50 rich-text-contente area
            var $imageText5050 = $(".image-text-50-50 .rich-text-panel");
            if (vWidth <= helper.maxTabletPortraitBreakpoint) {
                $imageText5050.dotdotdot({
                    height: 160
                });
            } else if (vWidth <= helper.maxTabletBreakpoint) {
                $imageText5050.dotdotdot({
                    height: 245
                });
            } else if (vWidth <= helper.desktopContainerBreakpoint) {
                $imageText5050.dotdotdot({
                    height: 325
                });
            }
        };
        
        setUpDotDotDot();
    };
    },{"../utils/viewport":50,"dotdotdot":57,"helper":44}],12:[function(require,module,exports){
    var _ = require("underscore");
    
    // TODO: are we tracking cookies to stay in submitted state?
    exports.init = function ($) {
    
        var $module;
    
        function setVars() {
            $module = $('.email-capture');
        }
    
        function setEmailCapture() {
            var $form = $module.find('form');
            if ($form.length) {
                $form.on('submit', function() {
                    var $this = $(this);
    
                    var email = '';
                    var $email = $this.find('input[data-validation="email"]');
                    if ($email.length) {
                        email = $email.val();
                    }
    
                    $.ajax({
                        url: '/api/Forms/EmailCaptureCTA/SubmitEmailCapture',
                        dataType: 'json',
                        type: 'POST',
                        data: { "": email },
                        cache: false,
                        success: function (data) {
                            var test = data;
                        },
                        error: function (jqXHR, status, err) {
                            console.log(jqXHR.status + "," + jqXHR.responseText + "," + status + "," + err);
                        }
                    });
    
                    return false;
                });
            }
        }
    
        function init() {
            setVars();
            if ($module.length) {
                setEmailCapture();
            }
        }
    
        init();
    };
    },{"underscore":66}],13:[function(require,module,exports){
    var helper = require("helper");
    var ko = require("knockout");
    var _ = require("underscore");
    var location = require("location");
    var GoogleMapsLoader = require('google-maps');
    var GMapStyles = require("./google-map-styles");
    
    exports.init = function ($) {
    
        var FindAHospital = (function () {
            var $module, $navTabs;
    
            var map, bounds, infowindow, geocoder;
            var markers = [];
    
            //map variables
            var initMapZoomSetting, afterSearchMapZoomMin;      // sitecore managed
            var isFetching;
            var isZoomOrPan = false, hasManualZoomed = false,
                hasUserSearched = false, isUserSearch = false,
                isLoadMoreButton = false, isTabChange = false;
    
            var viewModel;
            var navTabsClass = '.fa-hospital .nav-tabs li[data-id]';
            var previousSearchVal = null;
    
            // settings
            var Settings = {
                LoadMoreCount: 1,           // sitecore managed, used on loading more
                GetMoreCount: 5,            // sitecore managed, used on initial search
                MaxRadius: 10,              // sitecore managed
                CorpCountry: "",
                InitialLocationSearchTerm: "",
                CurrentHospitalTypeIds: [],
    
                UserBounds: {
                    MinLatitude: 0,
                    MaxLatitude: 0,
                    MinLongitude: 0,
                    MaxLongitude: 0
                }
            }
    
            // get gmap style
            var google_map_styles = GMapStyles().FAHospital;
    
            // gmap helpers
            function setUpMarkers($container) {
                if ($container.length !== 0) {
                    bounds = bounds || new google.maps.LatLngBounds();
                    infowindow = infowindow || new google.maps.InfoWindow();
    
                    $container.each(function (i, v) {
                        var $this = $(this);
    
                        if ($.isNumeric($this.data("lat"))) {
                            // make a marker
                            var marker = new google.maps.Marker({
                                position: { lat: parseFloat($this.data("lat")), lng: parseFloat($this.data("long")) },
                                map: map,
                                animation: google.maps.Animation.DROP,
                                title: $this.data("title"),
                                label: {
                                    text: String($this.data("index")),
                                    color: 'white'
                                },
                                icon: '../../Includes/_images/custom-map-pin.png'
                            });
    
                            // extend the bounds of the initial map to include new marker                        
                            bounds.extend(marker.position);
    
                            // add click listener to show tooltip
                            google.maps.event.addListener(marker, 'click', (function (marker, i) {
                                return function () {
                                    infowindow.setContent(marker.title);
                                    infowindow.open(map, marker);
                                }
                            })(marker, i));
    
                            // add to marker array (not sure if we need this yet)
                            markers.push(marker);
                        }
                    });
                }
    
                // wrap bounds of initial map around all points currently on map 
                if (!isZoomOrPan) {
                    map.setCenter(bounds.getCenter());
                    map.fitBounds(bounds);
                }
    
                // reset event flags
                if (isUserSearch) {
                    isUserSearch = false;
                }
                if (isLoadMoreButton) {
                    isLoadMoreButton = false;
                }
                if (isTabChange) {
                    isTabChange = false;
                }
                if (isZoomOrPan) {
                    isZoomOrPan = false;
                }
            }
    
            function clearMarkers() {
                for (var i = 0; i < markers.length; i++) {
                    markers[i].setMap(null);
                }
                markers = [];
            }
    
            function getMarker(title) {
                var marker = "";
                $.each(markers, function (i, v) {
                    if (v.title === title)
                        marker = v;
                });
    
                return marker;
            }
    
            function moveToMarker($container) {
    
                var marker = getMarker($container.data("title"));
                infowindow.close();
                infowindow.setContent(marker.title);
                infowindow.open(map, marker);
                $(document).scrollTop($("#map").offset().top);
            }
    
            function setUpScrollPins() {
                $(window).on("scroll", function () {
                    $(".hospital-info-block").each(function () {
                        var $this = $(this);
                        if (!$this.find(".cc-marker").hasClass("shown") && $this.is(":visible")) {
                            if ($(window).scrollTop() + $(window).height() > ($this.offset().top + ($this.height() / 2))) {
                                var $marker = $this.find(".cc-marker");
                                $marker.css({ top: $marker.parent().offset().top, left: $marker.parent().offset().left + 10 });
                                setTimeout(function () {
                                    $marker.addClass("shown");
                                }, 1000);
                            }
                        }
                    });
                });
    
                $(window).resize(function () {
                    $(".hospital-info-block").each(function () {
                        var $this = $(this);
                        if ($this.find(".cc-marker").hasClass("shown")) {
                            var $marker = $this.find(".cc-marker");
                            $marker.css({ top: $marker.parent().offset().top, left: $marker.parent().offset().left + 10 });
                        }
                    });
                });
            }
    
            function refreshActiveMarkers() {
                var activeIndex = $navTabs.filter('.active').index();
                var $activePane = $($navTabs.closest('.fa-tabs').find('.tab-content .tab-pane').get(activeIndex));
    
                clearMarkers();
                setUpMarkers($activePane.find('.hospital-info-block'));
            }
    
            function initMapAndMarkers() {
                if (typeof window.google !== 'undefined' && $("#map").length > 0) {
    
                    //setUpMarkers($($(".fa-hospital .fa-tabs li.active a").attr("href")).find(".hospital-info-block"));
    
                    $(".fa-hospital .tab-content").on("click", ".pin-location", function () {
                        moveToMarker($(this).closest(".hospital-info-block"));
                    });
                }
            }
    
            function getMatchingHospitalType() {
                return _.find(viewModel.uniqueHospitalTypes(), function (ht) {
                    return _.contains(Settings.CurrentHospitalTypeIds, ht.ID);
                });
            }
    
            // reset each hospital type settings
            function resetHospitalTypeVMSettings() {
                _.each(viewModel.uniqueHospitalTypes(), function (h, index, list) {
                    h.CurrentResultCount = 0;
                    h.HasMoreResults(true);
                    h.Hospitals([]);
                });
            }
    
            // service call
            function getData(currResultCount, isLoadMore, isMapListener) {
    
                currResultCount = currResultCount || 0;
    
                // add POST params to json obj
                var sentParams = {
                    MinLatitude: Settings.UserBounds.MinLatitude,
                    MaxLatitude: Settings.UserBounds.MaxLatitude,
                    MinLongitude: Settings.UserBounds.MinLongitude,
                    MaxLongitude: Settings.UserBounds.MaxLongitude,
                    CorpCountry: Settings.CorpCountry,
                    GetMoreCount: isLoadMore ? Settings.LoadMoreCount : Settings.GetMoreCount,
                    ResultCount: currResultCount,
                    CurrentHospitalType: Settings.CurrentHospitalTypeIds
                };
    
                isFetching = true;
    
                $.ajax({
                    url: '/api/Search/HospitalSearch/GetHospitals',
                    dataType: 'json',
                    type: 'POST',
                    data: sentParams,
                    cache: false,
                    success: function (data) {
    
                        // get primary matching hospital type
                        var matchingHospitalType = getMatchingHospitalType();
    
                        // no current results
                        if (!data.TotalResults) {
                            viewModel.hasNoSearchResults(true);
                            matchingHospitalType.HasMoreResults(false);
    
                            // if new search or pan/zoom: clear results
                            if (!isLoadMore) {
                                viewModel.results.removeAll();
                                refreshActiveMarkers();         // geocode search succeeded so we still want to update map with location
                            }
                            clearMarkers();
                            isFetching = false;
                            return;
                        } else {
                            viewModel.hasNoSearchResults(false);
                        }
    
                        // increment current hospital type and set-or-push results
                        if (isLoadMore) {
                            ko.utils.arrayPushAll(viewModel.results, data.Hospitals);
                        } else {
                            viewModel.results(data.Hospitals);
                            matchingHospitalType.CurrentResultCount = 0;
                        }
                        matchingHospitalType.CurrentResultCount += data.Hospitals.length;
    
                        // if no more future results for the hospital type, hide load more
                        if (matchingHospitalType && matchingHospitalType.CurrentResultCount >= data.TotalResults) {
                            matchingHospitalType.HasMoreResults(false);
                        }
                        else {
                            matchingHospitalType.HasMoreResults(true);
                        }
    
                        // refresh active markers
                        setTimeout(function () {
                            refreshActiveMarkers();
                            isFetching = false;
                        }, 0);
                    },
                    error: function (jqXHR, status, err) {
                        viewModel.hasNoSearchResults(true);
                        console.log(jqXHR.status + "," + jqXHR.responseText + "," + status + "," + err);
                        isFetching = false;
                    }
                });
            }
    
            function HTML5geolocate() {
                if (window.navigator && window.navigator.geolocation) {
                    window.navigator.geolocation.getCurrentPosition(function(position){
                        if (position && position.coords) {
                            var geocoderPosition = { lat: position.coords.latitude, lng: position.coords.longitude };
                            //vancouver coords - testing for those not in the land of eh
                            //geocoderPosition = { lat: 49.246292, lng: -123.116226 };
    
                            location.GetHospitalsByCoordinates(geocoder, geocoderPosition, Settings.MaxRadius, function (boundingData, center) {
    
                                bounds = boundingData;
    
                                isUserSearch = true;
                                isZoomOrPan = false;
    
                                Settings.UserBounds.MinLatitude = boundingData.getNorthEast().lat();
                                Settings.UserBounds.MaxLatitude = boundingData.getSouthWest().lat();
                                Settings.UserBounds.MinLongitude = boundingData.getNorthEast().lng();
                                Settings.UserBounds.MaxLongitude = boundingData.getSouthWest().lng();
    
                                resetHospitalTypeVMSettings();
                                getData(0, false);
                            });
                        }
                    }, function(error){
                        switch (error.code) {
                            case 1:
                                //permission denied
                                break;
                            case 2:
                                //position unavailable
                                break;
                            case 3:
                                //timeout
                                break;
                        }
                    });
                } else {
                    //unsupported browser
                }
            }
    
            // HospitalType Model for view
            var HospitalType = function (id) {
                this.ID = id;
                this.CurrentResultCount = 0;
                this.HasMoreResults = ko.observable(true);
                this.Hospitals = ko.observableArray([]);
            }
    
            // KO View Model
            var ViewModel = function () {
                var self = this;
    
                self.searchLocationLabel = ko.observable("");
                self.searchLocation = ko.observable(Settings.InitialLocationSearchTerm);
                self.currResultCount = ko.observable(0);
                self.results = ko.observableArray([]);
                self.uniqueHospitalTypes = ko.observableArray([]);
                self.hasNoSearchResults = ko.observable(false);
    
                self.viewResults = ko.computed(function () {
    
                    if (!self.results().length) { return null; }
    
                    self.hasNoSearchResults(false);
    
                    // group the results by hospital type
                    var groupedHospitals = _.map(self.uniqueHospitalTypes(), function (hType) {
    
                        hType.Hospitals(_.filter(self.results(), function (f) {
                            return _.findWhere(f.HospitalTypes, {
                                ID: hType.ID
                            });
                        }));
    
                        return hType;
                    });
    
                    return groupedHospitals;
                });
    
                self.findHospitals = function (form) {
    
                    if (!self.searchLocation() || self.searchLocation() === previousSearchVal) {
                        return;
                    }
    
                    location.GetHospitals(geocoder, self.searchLocation(), Settings.MaxRadius, function (boundingData, center) {
    
                        previousSearchVal = self.searchLocation();
                        self.searchLocationLabel(previousSearchVal);
                        bounds = boundingData;
    
                        isUserSearch = true;
                        isZoomOrPan = false;
    
                        Settings.UserBounds.MinLatitude = boundingData.getNorthEast().lat();
                        Settings.UserBounds.MaxLatitude = boundingData.getSouthWest().lat();
                        Settings.UserBounds.MinLongitude = boundingData.getNorthEast().lng();
                        Settings.UserBounds.MaxLongitude = boundingData.getSouthWest().lng();
    
                        // if first user search: set zoom capabilities flag
                        if (!hasUserSearched) {
                            hasUserSearched = true;                        
                            self.searchLocation(""); //empty search box on page load; show zip on "Showing results for" label
                        }
    
                        resetHospitalTypeVMSettings();
                        getData(0, false);
                    });
                };
    
                self.loadMore = function () {
    
                    isLoadMoreButton = true;
    
                    // get current hospital type result count to pass to getData
                    var currentHospitalTypeVM = getMatchingHospitalType();
                    var currentCount = currentHospitalTypeVM != null ? currentHospitalTypeVM.CurrentResultCount : self.results().length;
    
                    getData(currentCount, true);
                };
    
                self.hospitalsRendered = function (elements, data) {
                    // all results rendered
                    if (this.foreach()[this.foreach().length - 1] === data) {
    
                        // activate the current tab panel
                        var activeIndex = $navTabs.filter('.active').index();
                        var $activePane = $($navTabs.closest('.fa-tabs').find('.tab-content .tab-pane').get(activeIndex));
                        $activePane.addClass('active in');
                    }
                };
            }
    
            function setEvents() {
    
                // on tab change
                $navTabs.find('a[data-toggle="tab"]').on('shown.bs.tab', function (e) {
    
                    // set current hospital type
                    Settings.CurrentHospitalTypeIds = [e.target.parentElement.getAttribute("data-id")];
                    var currentHospitalTypeVM = getMatchingHospitalType();
    
                    if (hasUserSearched) {
                        isTabChange = true;
    
                        // only search if we haven't already on tab change
                        if (currentHospitalTypeVM != null && currentHospitalTypeVM.HasMoreResults() && currentHospitalTypeVM.CurrentResultCount === 0) {
                            getData(0, true);
                        } else {
                            // re-loading the markers for switched hospital type tab
                            var $currHospitalBlocks = $($(e.target).attr("href")).find(".hospital-info-block");
                            clearMarkers();
                            setUpMarkers($currHospitalBlocks);
                            viewModel.hasNoSearchResults($currHospitalBlocks.length === 0);
                        }
                    }
    
                });
    
                // if search arg: search for hospital on pageload
                if (viewModel != null && $.trim(viewModel.searchLocation()).length) {
                    viewModel.findHospitals();
                } else {
                    viewModel.searchLocation("");       // otherwise: disabled initial search (1/19)
                }
            }
    
            function searchByZoomOrDrag() {
                // only handle zooms and pans from drag end and zoom when a location is already entered
                if (hasUserSearched && !isLoadMoreButton && !isTabChange) {
    
                    //get new bounds
                    Settings.UserBounds.MinLatitude = map.getBounds().getNorthEast().lat();
                    Settings.UserBounds.MaxLatitude = map.getBounds().getSouthWest().lat();
                    Settings.UserBounds.MinLongitude = map.getBounds().getNorthEast().lng();
                    Settings.UserBounds.MaxLongitude = map.getBounds().getSouthWest().lng();
                    bounds = map.getBounds();
    
                    isZoomOrPan = true;
                    resetHospitalTypeVMSettings();
                    getData(0, false, true);
                }
            }
    
            function setZoomAndPanEvents() {
    
                google.maps.event.addListener(map, 'dragend', function (evt) {
                    // evt.latLng.lat().toFixed(5), evt.latLng.lng().toFixed(5)
                    if (!isFetching) {
                        searchByZoomOrDrag();
                    }
                });
    
                google.maps.event.addListener(map, 'zoom_changed', function () {
                    var zoomLvl = map.getZoom();
    
                    // return if manual zoom
                    if (hasManualZoomed) {
                        hasManualZoomed = false;
                        return;
                    }
    
                    // default zoom guard, before search
                    if (!hasUserSearched && zoomLvl < initMapZoomSetting - 1) {
                        hasManualZoomed = true;
                        map.setZoom(initMapZoomSetting-1);
                        return;
                    }
    
                    // if user has searched and trying to zoom out too far
                    if (hasUserSearched && zoomLvl < afterSearchMapZoomMin) {
                        hasManualZoomed = true;
                        map.setZoom(afterSearchMapZoomMin);
                        return;
                    }
    
                    if (isUserSearch) {
                        return;
                    }
    
                    if (!isFetching) {
                        searchByZoomOrDrag();
                    }
                });
            }
    
            // set gmap vars
            function setMapVars() {
    
                initMapZoomSetting = window.FindAHospitalSettings.InitialZoomSetting || 5;
                afterSearchMapZoomMin = window.FindAHospitalSettings.MaxZoomOutSetting || 8;
    
                map = new google.maps.Map(document.getElementById('map'), {
                    zoom: initMapZoomSetting,
                    center: { lat: window.FindAHospitalSettings.GMapCenterLat, lng: window.FindAHospitalSettings.GMapCenterLong }
                });
                map.setOptions({ styles: google_map_styles });
    
                bounds = map.getBounds();                               // Returns the lat/lng bounds of the current map viewport
                infowindow = new google.maps.InfoWindow();              // An overlay that looks like a bubble and is often connected to a marker
                geocoder = new google.maps.Geocoder();                  // A service for converting between an address and a LatLng
            }
    
            function setVars() {
    
                // search elements
                $navTabs = $(navTabsClass);
    
                // Sitecore managed
                Settings.LoadMoreCount = window.FindAHospitalSettings.LoadMoreCount;
                Settings.GetMoreCount = window.FindAHospitalSettings.GetMoreCount;
                Settings.MaxRadius = window.FindAHospitalSettings.MaximumRadius;
                Settings.InitialLocationSearchTerm = window.FindAHospitalSettings.InitialLocationSearchTerm;
                Settings.CurrentHospitalTypeIds = [$navTabs.filter('.active').attr('data-id')];
                Settings.CorpCountry = window.FindAHospitalSettings.CorpCountry;
                Settings.HTML5Enabled = window.FindAHospitalSettings.HTML5Enabled;
    
                // KO    
                viewModel = new ViewModel();
                viewModel.uniqueHospitalTypes($navTabs.map(function () { return new HospitalType(this.getAttribute("data-id")) }));
                ko.applyBindings(viewModel, $module.get(0));
            }
    
            function initialize() {
    
                $module = $('.fa-hospital');
                if (helper.exists($module)) {
    
                    GoogleMapsLoader.KEY = window.FindAHospitalSettings.GMapsAPIKey;
                    GoogleMapsLoader.load(function (google) {
    
                        setMapVars();
                        setZoomAndPanEvents();
                        initMapAndMarkers();
                        //setUpScrollPins(); //stop animating cc-marker pins
    
                        setVars();
                        setEvents();
    
                        if (Settings.HTML5Enabled) {
                            HTML5geolocate();
                        }
                    });
    
                }
            }
    
            return {
                init: initialize
            };
    
        })();
    
        FindAHospital.init();
    };
    },{"./google-map-styles":18,"google-maps":59,"helper":44,"knockout":64,"location":46,"underscore":66}],14:[function(require,module,exports){
    var ko = require("knockout");
    var _ = require("underscore");
    var helper = require("helper");
    
    exports.init = function ($) {
    
        var GlobalSettings = {
            VCAContextSiteName: VCA.ContextSiteName
        };
    
        // BEGIN: Pet Health Library
        var PetHealthLibrary = (function () {
    
            // vars
            var viewModel;
            var $module = $('.pet-health-library').not('.standalone');
            var petCategoryLinkClass = '.category a';
            var closeQueryViewClass = '.queried .close a';
            var typeAheadClass = '.typeahead';
            var $petResultsDefault, $petResultsQueried, $petCategories, $primarySearcher, $petResultFilters;
            var $selectCategory, $selectSpecies;
    
            // settings
            var Settings = {
                isPrimaryQueryState: true,
                pageLoadCount: null,        // sitecore managed
                LoadMoreCount: null,        // sitecore managed
                GetMoreCount: null,         // sitecore managed
                QueryModes: {
                    Search: {
                        filters: ['.search', '.species'],       // associated filters
                        currVal: null                           // current value of filter
                    },
                    Category: {
                        filters: ['.category', '.species'],
                        currVal: null
                    },
                    Species: {
                        filters: null,
                        currVal: null
                    }
                }
            }
    
            // service call
            function getData(start, isLoadMore) {
                start = start || 0;
    
                // add POST params to json obj
                var sentParams = {
                    GetMoreCount: isLoadMore ? Settings.LoadMoreCount : Settings.GetMoreCount,
                    ResultCount: start,
                    SearchTerm: viewModel.search(),
                    TopicId: Settings.QueryModes.Category.currVal,
                    SpeciesID: Settings.QueryModes.Species.currVal,
                    VCAContextSiteName: GlobalSettings.VCAContextSiteName
                };
    
                $.ajax({
                    url: '/api/Search/PetHealthSearch/GetPetHealthArticles',
                    dataType: 'json',
                    type: 'POST',
                    data: sentParams,
                    cache: false,
                    success: function (data) {
                        // no results (on primary state)
                        if (typeof data !== "object" || data == null || typeof data.FacetResultItems !== "object" || data.TotalResults === 0) {
    
                            viewModel.HasMoreResults(false);
    
                            if (!isLoadMore) {
                                viewModel.hasNoSearchResults(true);
                                viewModel.results.removeAll();
                            }
                            return;
                        } else {
                            viewModel.hasNoSearchResults(false);
                        }
    
                        if (isLoadMore) {
                            ko.utils.arrayPushAll(viewModel.results, data.FacetResultItems);
                        } else {
                            viewModel.results(data.FacetResultItems);
                        }
    
                        // if no more future results, hide load more
                        if (viewModel.results().length >= data.TotalResults) {
                            viewModel.HasMoreResults(false);
                        }
                    },
                    error: function (jqXHR, status, err) {
                        console.log(jqXHR.status + "," + jqXHR.responseText + "," + status + "," + err);
                    }
                });
            }
    
            // constructor: pet health detail result item
            var PetHealthDetail = function (obj) {
                this.title = obj.Title;
                this.resultDescription = obj.FeaturedDescription;
                this.resultImage = obj.FeaturedImage;
                this.moreLink = obj.MoreLink;
                this.moreLabel = obj.MoreLabel;
            }
    
            // knockout viewmodel
            var ViewModel = function () {
                var self = this;
                self.HasMoreResults = ko.observable(true);
                self.hasNoSearchResults = ko.observable(false);
                self.search = ko.observable("");
                self.results = ko.observableArray();
                self.viewResults = ko.computed(function () {
    
                    var petHealtResults = _.map(self.results(), function (r) {
                        return new PetHealthDetail(r);
                    });
    
                    return petHealtResults;
                });
    
                // operations
                self.loadMore = function () {
    
                    getData(self.viewResults().length, true);
                };
                self.doSearch = function (form, qMode) {
                    var queryMode = qMode || Settings.QueryModes.Search;
    
                    //if category mode, clear viewmodel search term and reset HasMoreResults
                    if (queryMode === Settings.QueryModes.Category) {
                        self.HasMoreResults(true);
                        self.search("");
                    }
    
                    //if species mode, reset HasMoreResults
                    if (queryMode === Settings.QueryModes.Species) {
                        self.HasMoreResults(true);                    
                    }
    
                    // if search mode, clear category
                    if (queryMode === Settings.QueryModes.Search) {
                        // if no query
                        if (!self.search()) {
                            return;
                        }
                        Settings.QueryModes.Category.currVal = null;
                    }
    
                    // if primary query state
                    if (Settings.isPrimaryQueryState) {
                        $petCategories.fadeOut();
                        $petResultsDefault.fadeOut();
                        $primarySearcher.fadeOut();
                        $petResultsQueried.fadeIn();
    
                        // clear species filter
                        $selectSpecies.val($selectSpecies.children().first().val()).change();
    
                        // pre-populate category dropdown with selected category value
                        if (Settings.QueryModes.Category.currVal) {
                            var matchingOption = $selectCategory.children().filter(function (i, e) { return $(e).val() === Settings.QueryModes.Category.currVal });
                            if (matchingOption) {
                                $selectCategory.val(matchingOption.val());
                            }
                        }
    
                        // hide all filters, show filters in search query mode
                        $petResultFilters.hide();
                        var $currModeFilters = $petResultFilters.filter(queryMode.filters.join(','));
                        $currModeFilters.show();
                    }
    
                    // get results
                    getData(self.results.length, false);
                };
            }
    
            // helpers
            function selectCategory($anchor) {
                Settings.QueryModes.Category.currVal = $anchor.attr('data-category-id');
                Settings.QueryModes.Search.currVal = null;
                Settings.isPrimaryQueryState = true;
    
                viewModel.doSearch(null, Settings.QueryModes.Category);
            }
    
            // event handlers
            function setEvents() {
    
                // search typeahead: autosearch on selected
                //$module.find(typeAheadClass).on('typeahead:selected', function (event, data) {
    
                //    Settings.QueryModes.Category.currVal = null;
                //    viewModel.search(data.name);
                //    viewModel.doSearch(null, Settings.QueryModes.Search);
                //});
    
                var $facetCategories = $module.find('.facet-categories');
    
                // category block
                $facetCategories.on('click', petCategoryLinkClass, function() {
                    var $this = $(this);
    
                    selectCategory($this);
    
                    return false;
                });
    
                // category and species select change
                $selectCategory.on('change', function () {
                    var selectedVal = $(this).val();
    
                    Settings.QueryModes.Category.currVal = selectedVal;
                    Settings.QueryModes.Search.currVal = null;
                    Settings.isPrimaryQueryState = false;
    
                    viewModel.doSearch(null, Settings.QueryModes.Category);
                });
    
                $selectSpecies.on('change', function () {
                    var selectedVal = $(this).val();
    
                    Settings.QueryModes.Species.currVal = selectedVal;
                    Settings.isPrimaryQueryState = false;
    
                    viewModel.doSearch(null, Settings.QueryModes.Species);
                });
    
                // close query state
                $module.find(closeQueryViewClass).on('click', function () {
                    // close query views, clear primary search, show pet categories
                    $petResultsQueried.fadeOut();
                    $petResultsDefault.fadeIn();
                    $primarySearcher.find('input[type="text"]').val('');
                    $primarySearcher.fadeIn();
                    $petCategories.fadeIn();
    
                    Settings.isPrimaryQueryState = true;
                    Settings.QueryModes.Search.currVal = null;
                    Settings.QueryModes.Category.currVal = null;
                    Settings.QueryModes.Species.currVal = null;
                });
            }
    
            function setVars() {
                $petResultsDefault = $module.find('.facet-results .default');
                $petResultsQueried = $module.find('.facet-results .queried');
                $petCategories = $module.find('.facet-categories');
                $primarySearcher = $module.find('.primary-search .filter.search');
                $petResultFilters = $petResultsQueried.find('.filter');
    
                $selectCategory = $petResultFilters.filter('.category').find('select');
                $selectSpecies = $petResultFilters.filter('.species').find('select');
    
                Settings.GetMoreCount = VCA.PetHealthLibrarySettings.GetMoreCount;
                Settings.LoadMoreCount = VCA.PetHealthLibrarySettings.LoadMoreCount;
            }
    
            // start
            function init() {
                if (helper.exists($module)) {
    
                    // ko databind
                    viewModel = new ViewModel();
                    ko.applyBindings(viewModel, $module.get(0));
    
                    // set module vars and events
                    setVars();
                    setEvents();
                }
            }
    
            return {
                init: init()
            }
        })();
        // End: Pet Health Library
    
        /* Vet Resources Listing */
        var VetResourcesListing = (function () {
    
            // vars
            var viewModel;
            var $module = $('.vet-resource-listing').not('.standalone');
            var categoryLinkClass = '.facet-categories .category a';
            var closeQueryViewClass = '.queried .close i';
            var $resultsQueried, $categories, $resultFilters;
            var $selectCategory, $selectSpecies;
    
            // settings
            var Settings = {
                pageLoadCount: null,        // sitecore managed
                LoadMoreCount: null,        // sitecore managed
                GetMoreCount: null,         // sitecore managed
                QueryModes: {
                    Category: {
                        filters: ['.category'],
                        currVal: null
                    }
                }
            }
    
            // service call
            function getData(start, isLoadMore) {
                start = start || 0;
    
                // add POST params to json obj
                var sentParams = {
                    GetMoreCount: isLoadMore ? Settings.LoadMoreCount : Settings.GetMoreCount,
                    ResultCount: start,
                    CategoryID: Settings.QueryModes.Category.currVal,
                    VCAContextSiteName: GlobalSettings.VCAContextSiteName
                };
    
                $.ajax({
                    url: '/api/Search/VetResourcesSearch/GetVetResourcesListingItems',
                    dataType: 'json',
                    type: 'POST',
                    data: sentParams,
                    cache: false,
                    success: function (data) {
                        // no results (on primary state)
                        if (typeof data !== "object" || data == null || typeof data.FacetResultItems !== "object" || data.TotalResults === 0) {
    
                            viewModel.HasMoreResults(false);
    
                            if (!isLoadMore) {
                                viewModel.hasNoSearchResults(true);
                                viewModel.results.removeAll();
                            }
                            return;
                        } else {
                            viewModel.hasNoSearchResults(false);
                        }
    
                        if (isLoadMore) {
                            ko.utils.arrayPushAll(viewModel.results, data.FacetResultItems);
                        } else {
                            viewModel.results(data.FacetResultItems);
                        }
    
                        // if no more future results, hide load more
                        if (viewModel.results().length >= data.TotalResults) {
                            viewModel.HasMoreResults(false);
                        }
                    },
                    error: function (jqXHR, status, err) {
                        console.log(jqXHR.status + "," + jqXHR.responseText + "," + status + "," + err);
                    }
                });
            }
    
            // constructor: pet health detail result item
            var VetResourcesDetail = function (obj) {
                this.title = obj.Title;
                this.resultDescription = obj.FeaturedDescription;
                this.publishedDate = obj.PublishedDate;
                this.featuredImage = obj.FeaturedImage;
                this.isFeaturedVideo = obj.IsFeaturedVideo;
                this.moreLink = obj.MoreLink;
                this.moreLabel = obj.MoreLabel;
            }
    
            // knockout viewmodel
            var ViewModel = function () {
                var self = this;
                self.HasMoreResults = ko.observable(true);
                self.hasNoSearchResults = ko.observable(false);
                self.results = ko.observableArray();
                self.viewResults = ko.computed(function () {
    
                    var vetResourceResults = _.map(self.results(), function (r) {
                        return new VetResourcesDetail(r);
                    });
    
                    return vetResourceResults;
                });
    
                // operations
                self.loadMore = function () {
                    getData(self.viewResults().length, true);
                };
    
                self.doSearch = function (form, qMode) {
                    var queryMode = qMode;
    
                    // if primary query state
                    if (Settings.isPrimaryQueryState) {
                        $categories.fadeOut();
                        $resultsQueried.fadeIn();
    
                        // pre-populate category dropdown with selected category value
                        if (Settings.QueryModes.Category.currVal) {
                            var matchingOption = $selectCategory.children().filter(function (i, e) { return $(e).val() === Settings.QueryModes.Category.currVal });
                            if (matchingOption) {
                                $selectCategory.val(matchingOption.val());
                            }
                        }
    
                        // hide all filters, show filters in search query mode
                        $resultFilters.hide();
                        var $currModeFilters = $resultFilters.filter(queryMode.filters.join(','));
                        $currModeFilters.show();
                    }
    
                    // get results
                    getData(self.results.length, false);
                };
            }
    
            // event handlers
            function setEvents() {
    
                // category block
                $module.find(categoryLinkClass).on('click', function () {
                    var $this = $(this);
    
                    Settings.QueryModes.Category.currVal = $this.attr('data-category-id');
                    Settings.isPrimaryQueryState = true;
    
                    viewModel.doSearch(null, Settings.QueryModes.Category);
    
                    return false;
                });
    
                // category select change
                $selectCategory.on('change', function () {
                    var selectedVal = $(this).val();
    
                    Settings.QueryModes.Category.currVal = selectedVal;
                    Settings.isPrimaryQueryState = false;
    
                    viewModel.doSearch(null, Settings.QueryModes.Category);
                });
    
                // close query views, clear primary search, show pet categories
                $module.find(closeQueryViewClass).on('click', function () {
    
                    $resultsQueried.fadeOut();
                    $categories.fadeIn();
    
                    Settings.isPrimaryQueryState = true;
                    Settings.QueryModes.Category.currVal = null;
                });
            }
    
            function setVars() {
                $resultsQueried = $module.find('.facet-results .queried');
                $categories = $module.find('.facet-categories');
                $resultFilters = $resultsQueried.find('.filter');
    
                $selectCategory = $resultFilters.filter('.category').find('select');
    
                Settings.GetMoreCount = window.VetResourceListingSettings.GetMoreCount;
                Settings.LoadMoreCount = window.VetResourceListingSettings.LoadMoreCount;
            }
    
            // start
            function init() {
                if (helper.exists($module)) {
    
                    // ko databind
                    viewModel = new ViewModel();
                    ko.applyBindings(viewModel, $module.get(0));
    
                    // set module vars and events
                    setVars();
                    setEvents();
                }
            }
    
            return {
                init: init()
            }
        })();
    
        /* Featured Content: default featured content 'show more' functionality */
        var FeaturedContent = (function () {
    
            var hiddenClass = 'hidden';
            var featuredContentListingClass = '.default .featured-content-listing';
            var $calloutListLoadMoreLinks = $('.featured-content-listing .load-more a');
    
            var Settings = {
                LoadMoreCount: 0
            }
    
            function setVars() {
                if (typeof VCA.FeaturedContentSettings !== "undefined") {
                    Settings.LoadMoreCount = VCA.FeaturedContentSettings.LoadMoreCount;
                }
            }
    
            function setLoadMore() {
                $calloutListLoadMoreLinks.on('click', function () {
                    var $this = $(this);
    
                    var $list = $this.closest(featuredContentListingClass);
                    var $hiddenCallouts = $list.find('.listing .article.' + hiddenClass);
                    if ($hiddenCallouts.length) {
                        $hiddenCallouts.slice(0, Settings.LoadMoreCount).fadeIn().removeClass(hiddenClass);
                    }
    
                    if (!$hiddenCallouts.hasClass(hiddenClass)) {
                        $this.hide();
                    }
                    return false;
                });
            }
    
            function init() {
                if ($(featuredContentListingClass).length) {
                    setVars();
                    setLoadMore();
                }
            }
    
            return {
                init: init()
            }
        })();
    
        /* PostModule */
        var NewsModule = (function () {
            // vars
            var viewModel;
            var $module = $('.news-module').not('.standalone');
            var $postResultsDefault, $postResultsQueried, $primarySearcher;
            var $selectTopic, $selectSortBy;
    
            // settings
            var Settings = {
                //isPrimaryQueryState: true,
                pageLoadCount: null,        // sitecore managed
                LoadMoreCount: null,        // sitecore managed
                GetMoreCount: null,         // sitecore managed
                QueryModes: {				// where the selected value of the dropdown is stored
                    Topic: {
                        filters: ['.topic'],
                        currVal: null
                    },
                    SortBy: {
                        filters: ['.sortby'],
                        currVal: "most-recent"
                    }
                }
            } //end of Settings
    
            // service call
            function getData(start, isLoadMore) {
                start = start || 0;
    
                // add POST params to json obj
                var sentParams = {
                    GetMoreCount: isLoadMore ? Settings.LoadMoreCount : Settings.GetMoreCount,
                    ResultCount: start,                
                    TopicID: Settings.QueryModes.Topic.currVal,
                    SortBy: Settings.QueryModes.SortBy.currVal,
                    VCAContextSiteName: GlobalSettings.VCAContextSiteName
                };
    
                $.ajax({
                    url: '/api/Search/PostListingSearch/GetPostsFromTopic',
                    dataType: 'json',
                    type: 'POST',
                    data: sentParams,
                    cache: false,
                    success: function (data) {
    
                        // no results (on primary state)
                        if (typeof data !== "object" || data == null || typeof data.FacetResultItems !== "object" || data.TotalResults === 0) {
    
                            viewModel.HasMoreResults(false);
    
                            if (!isLoadMore) {
                                viewModel.hasNoSearchResults(true);
                                viewModel.results.removeAll();
                            }
                            return;
                        }
    
                        if (isLoadMore) {
                            ko.utils.arrayPushAll(viewModel.results, data.FacetResultItems);
                        } else {
                            viewModel.results(data.FacetResultItems);
                        }
    
                        // if no more future results, hide load more
                        if (viewModel.results().length >= data.TotalResults) {
                            viewModel.HasMoreResults(false);
                        }
                    },
                    error: function (jqXHR, status, err) {
                        console.log(jqXHR.status + "," + jqXHR.responseText + "," + status + "," + err);
                    }
                });
            } //end of service call
    
            // constructor: post detail result item
            var PostDetail = function (obj) {
                this.title = obj.Title;
                this.date = obj.Date;
                this.resultDescription = obj.FeaturedDescription;
                this.resultImage = obj.FeaturedImage;
                this.moreLink = obj.MoreLink;
            }//end of postdetail constructor
    
            // knockout viewmodel
            var ViewModel = function () {
                var self = this;
                self.HasMoreResults = ko.observable(true); //boolean to load "load more" button
                self.hasNoSearchResults = ko.observable(false);
                self.results = ko.observableArray();
                self.viewResults = ko.computed(function () {
    
                    var postResults = _.map(self.results(), function (r) {
                        return new PostDetail(r);
                    });
    
                    return postResults;
                });
    
                // operations
                self.loadMore = function () {
    
                    getData(self.viewResults().length, true);
                }; 
                self.doSearch = function (form, qMode) {
    
                    // if selection is "featured posts"
                    if (Settings.QueryModes.Topic.currVal === "featured") {
                        $postResultsQueried.fadeOut();
                        $postResultsDefault.fadeIn();
                        
                    } else {
                        $postResultsDefault.fadeOut();
                        $postResultsQueried.fadeIn();
    
                        // get results
                        getData(self.results.length, false);
                    }
    
                };//end of doSearch
            }//end of knockout viewModel
    
            // event handlers
            function setEvents() {
    
                // topic selectr change
                $selectTopic.on('change', function () {
                    var selectedVal = $(this).val(); //returns topic id
                    Settings.QueryModes.Topic.currVal = selectedVal;
    
                    //reset variable
                    viewModel.HasMoreResults(true);
    
                    viewModel.doSearch(null, Settings.QueryModes.Topic);
                });
    
                // sortBy select change
                $selectSortBy.on('change', function () {
                    var selectedVal = $(this).val(); //returns string
                    Settings.QueryModes.SortBy.currVal = selectedVal;
    
                    //reset variable
                    viewModel.HasMoreResults(true);
    
                    viewModel.doSearch(null, Settings.QueryModes.SortBy);
                });
    
            }//end of event handlers	
    
            //set variables
            function setVars() {
                $postResultsDefault = $module.find('.facet-results .default');
                $postResultsQueried = $module.find('.facet-results .queried');
    
                $primarySearcher = $module.find('.primary-search .filters');
    
                $selectTopic = $primarySearcher.find('.topic').find('select');
                $selectSortBy = $primarySearcher.find('.sortby').find('select');
    
                Settings.GetMoreCount = VCA.PostSettings.GetMoreCount;
                Settings.LoadMoreCount = VCA.PostSettings.LoadMoreCount;
            }//end of setVars
    
            // start
            function init() {
                if (helper.exists($module)) {
    
                    // ko databind
                    viewModel = new ViewModel();
                    ko.applyBindings(viewModel, $module.get(0));
    
                    // set module vars and events
                    setVars();
                    setEvents();
                }
            }//end of init
    
            return {
                init: init()
            }
    
        })(); //end of PostModule
    
        /* Staff Listing Panel */
        var StaffListingPanel = (function () {
            //vars
            var $module = $('.person-listing').not('.standalone');
            var $selectDept, $currentDiv, selectedDept;
    
            //event handlers
            function setEvents() {
                //department select change            
                $selectDept.on('change', function () {
                    $(selectedDept).css('display', 'none');
                    selectedDept = "#" + $(this).val();
                    $currentDiv = $module.find('.list').find(selectedDept);
                    $(selectedDept).css('display', '');
                });
            }//end of event handlers
    
            //set variables
            function setVars() {
                $selectDept = $module.find('.primary-search .filters').find('.dept').find('select');
                selectedDept = "#" + $selectDept.val();
                $currentDiv = $module.find('.list').find(selectedDept);
            }//end of setvars
    
            //hide all departments except for first one
            function hideAll() {
                
            }//end of hideAll
    
            //start
            function init() {
                if (helper.exists($module)) {
                    setVars();
                    hideAll();
                    setEvents();
                }
            }//end of init
    
            return {
                init: init()
            }
    
        })(); //end of Staff Listing Panel
    };
    },{"helper":44,"knockout":64,"underscore":66}],15:[function(require,module,exports){
    /* requires */
    var helper = require('../utils/helper.js');
    var formValidator = require('jqueryFormValidator');
    
    exports.init = function ($) {
    
        var $freefirst = $('.free-exam');
    
        function FreeFirstExam() {
            var $form = $freefirst.find('form');
            var $submittedContainer = $freefirst.find('.submitted');
            var $receiptMessage = $freefirst.find('.message');
            var $errorMessage = $freefirst.find('.err_message');
    
            $form.on('submit', function (e) {
                e.preventDefault();
    
                if ($form.hasClass('err-client')) {
                    return false;
                }
    
                var $this = $(this);
                var $firstName = $this.find('.firstName').val();
                var $lastName = $this.find('.lastName').val();
                var $email = $this.find('input[data-validation="email"]').val();
                var $phone = $this.find('.phone').val();
                var $zip = $this.find('.zip').val();
                var $hospitalId = $this.find('.hospitalid').val();
                var $sitename = $this.find('.sitename').val();
                var $refUrl = document.referrer;
                var $currUrl = window.location.href;
                $.ajax({
                    url: '/api/Forms/FreeFirstExamApi/SubmitFreeFirstForm',
                    dataType: 'json',
                    type: 'POST',
                    data: { firstName: $firstName, lastName: $lastName, email: $email, phone: $phone, zip: $zip, hospitalId: $hospitalId, refUrl: $refUrl, currUrl: $currUrl, sitename: $sitename },
                    cache: false,
                    success: function (data) {
                        if ($form.css('display') !== 'none') {
                            $form.hide();
    
                            if (data != null && data.IsSuccess) {
    
                                // create coupon link
                                var $couponLink = $("<a />", {
                                    name: "ffe-coupon-link",
                                    href: data.CouponUrl,
                                    text: typeof window.FreeFirstExamSettings !== "undefined" ?
                                        window.FreeFirstExamSettings.CouponLinkText : "Click here to view your coupon",
                                    target: "_blank"
                                });
    
                                $couponLink.addClass('fancy');
    
                                $submittedContainer.append($couponLink);
                                $receiptMessage.show();
    
                                // GA datalayer push
                                window.dataLayer.push({
                                    'event': 'offer-submission',
                                    'offer-type': data.OfferType, //'new patient offer',
                                    'offer-variant': data.OfferVariant,
                                    'appointment-type': '',
                                    'appointment-reason': '',
                                    'appointment-client-type': '',
                                    'customer-postal-code': $zip,
                                    'pet-type': ''
                                });
                            } else {
                                $errorMessage.show();
                            }
                        }
                    },
                    error: function (jqXHR, status, err) {
                        console.log(jqXHR.status + "," + jqXHR.responseText + "," + status + "," + err);
                    }
                });// end of ajax call
    
    
            }); //end of on click 
        }
    
        FreeFirstExam();
    };
    },{"../utils/helper.js":44,"jqueryFormValidator":53}],16:[function(require,module,exports){
    
    exports.init = function($) {
        
        var LoadMore = (function() {
    
            var $calloutListLoadMoreLinks = $('.callout-list').siblings(".load-more").find("a"),
                hiddenClass = 'hidden',
                calloutListClass = '.callout-list',
                initialCalloutCount = 'initialCalloutCount';
            
            // set initial item count to the # of visible callouts per callout-list
            function setCalloutListsVisibleCount() {
    
                var $allModules = $(calloutListClass);
                $allModules.each(function () {
    
                    var $this = $(this);
                    var initialCount = $this.find('.generic-callout, .article').not('.' + hiddenClass).length;
    
                    $this.data(initialCalloutCount, initialCount);
    
                    if ($this.find('.generic-callout, .article').length === initialCount) {
                        $this.siblings(".load-more").hide();
                    }
                });
            }
            
            function setLoadMore() {
                
                setCalloutListsVisibleCount();
                
                $calloutListLoadMoreLinks.on('click', function() {
                    var $this = $(this);
                    
                    // set list type
                    var $list = $this.closest('.tab-pane').find(calloutListClass);
                    var $hiddenCallouts = $list.find('.generic-callout.' + hiddenClass);
                    var currLoadMoreCount = $list.data(initialCalloutCount);
                    
                    $hiddenCallouts.slice(0, currLoadMoreCount).fadeIn().removeClass(hiddenClass);
                    
                    // if any row still contains hidden, keep load more
                    if (!$hiddenCallouts.hasClass(hiddenClass)) {
                        $this.hide();
                    }
                    
                    return false;
                });
            }
    
            function initialize() {
                setLoadMore();
            }
            
            return {
                init: initialize
            };
            
        })();
        
        LoadMore.init();
    };
    },{}],17:[function(require,module,exports){
    /* requires */
    var helper = require('helper');
    var _ = require("underscore");
    
    exports.init = function ($) {
    
        function setupUnderscore() {
            _.templateSettings.variable = "rc";
        }
    
        function setAjaxSettings() {
    
            $.ajaxSetup({
                beforeSend: function () {
    
                    $('.ajax-loader').show();
                },
                complete: function () {
    
                    $('.ajax-loader').hide();
                }
            });
        }
    
        function setFormBindings() {
            $('.radio-button input[type="radio"] + label').on('click', function () {
                $(this).closest('.radio-button').find("input").prop("checked", true);
            });
        }
    
        function setJSExtensions() {
            // strip phone format
            Object.defineProperty(String.prototype, "StripPhoneFormat", {
                value: function StripPhoneFormat() {
                    return this.replace(/[\s().+-]/g, '');
                }
            });
            Object.defineProperty(String.prototype, "SetPhoneFormat", {
                value: function SetPhoneFormat() {
                    return this.replace(/(\d{3})(\d{3})(\d{4})/, '$1-$2-$3');
                }
            });
        }
    
        setupUnderscore();
        setAjaxSettings();
        //setFormBindings();
        setJSExtensions();
    };
    },{"helper":44,"underscore":66}],18:[function(require,module,exports){
    
    module.exports = function() {
        return {
            FAHospital: [
                {
                    "featureType": "landscape.man_made",
                    "elementType": "geometry",
                    "stylers": [
                        {
                            "color": "#f7f1df"
                        }
                    ]
                },
                {
                    "featureType": "landscape.natural",
                    "elementType": "geometry",
                    "stylers": [
                        {
                            "color": "#d0e3b4"
                        }
                    ]
                },
                {
                    "featureType": "landscape.natural.terrain",
                    "elementType": "geometry",
                    "stylers": [
                        {
                            "visibility": "off"
                        }
                    ]
                },
                {
                    "featureType": "poi",
                    "elementType": "labels",
                    "stylers": [
                        {
                            "visibility": "off"
                        }
                    ]
                },
                {
                    "featureType": "poi.business",
                    "elementType": "all",
                    "stylers": [
                        {
                            "visibility": "off"
                        }
                    ]
                },
                {
                    "featureType": "poi.medical",
                    "elementType": "geometry",
                    "stylers": [
                        {
                            "color": "#fbd3da"
                        }
                    ]
                },
                {
                    "featureType": "poi.park",
                    "elementType": "geometry",
                    "stylers": [
                        {
                            "color": "#bde6ab"
                        }
                    ]
                },
                {
                    "featureType": "road",
                    "elementType": "geometry.stroke",
                    "stylers": [
                        {
                            "visibility": "off"
                        }
                    ]
                },
                {
                    "featureType": "road",
                    "elementType": "labels",
                    "stylers": [
                        {
                            "visibility": "off"
                        }
                    ]
                },
                {
                    "featureType": "road.highway",
                    "elementType": "geometry.fill",
                    "stylers": [
                        {
                            "color": "#ffe15f"
                        }
                    ]
                },
                {
                    "featureType": "road.highway",
                    "elementType": "geometry.stroke",
                    "stylers": [
                        {
                            "color": "#efd151"
                        }
                    ]
                },
                {
                    "featureType": "road.arterial",
                    "elementType": "geometry.fill",
                    "stylers": [
                        {
                            "color": "#ffffff"
                        }
                    ]
                },
                {
                    "featureType": "road.local",
                    "elementType": "geometry.fill",
                    "stylers": [
                        {
                            "color": "black"
                        }
                    ]
                },
                {
                    "featureType": "transit.station.airport",
                    "elementType": "geometry.fill",
                    "stylers": [
                        {
                            "color": "#cfb2db"
                        }
                    ]
                },
                {
                    "featureType": "water",
                    "elementType": "geometry",
                    "stylers": [
                        {
                            "color": "#a2daf2"
                        }
                    ]
                }
            ]
        };
    };
    },{}],19:[function(require,module,exports){
    
    var $ = require("jquery");
    exports.init = function () {
    
        function mainNav() {
            var $module = $('.main-nav-container');
            var $navLinksSelector = $module.find('.main-nav-links');
    
            var currentPageId = VCA.CurrentItemId;
            $navLinksSelector.each(function (index, element) {
                if ($(element).attr("data-nav-id") == (currentPageId)) {
                    $(element).addClass("active");
                } else {
                    $(element).removeClass('active');
                }
            });
        }
    
        mainNav();
    
        function signOut() {
            var $link = $('.sign-out-lnk');
            $link.on('click', function (event) {
                event.preventDefault();
                $.ajax({
                    url: VCASignInSettings.dashboardUrl,
                    data: {
                        'scController': 'Dashboard',
                        'scAction': 'LogOut'
                    },
                    type: 'POST',
                    cache: false,
                    success: function (data) {
                        window.location = VCASignInSettings.logoutUrl;
                    },
                    error: function (jqXHR, status, err) {
                        console.log(jqXHR.status + "," + jqXHR.responseText + "," + status + "," + err);
                    }
                });
            });
        }
    
        signOut();
    
    };
    },{"jquery":63}],20:[function(require,module,exports){
    var helper = require("helper");
    var froogaloop = require("vimeo-froogaloop2");
    
    exports.init = function ($) {
    
        var playlist = [];
        var $video = $("#homepageVideo");
        var $video_list = $(".homepage-hero .video-list");
    
        var HeroVideo = (function () {
    
            function refillPlaylist(){
                $video_list.find(".video-group").each(function(){
                    var $this = $(this);
    
                    var playlist_group = [];
                    $this.find("span").each(function(){
                        var video_url = $(this).html();
                        var video_type = $(this).data("type");
                        playlist_group.push({ url: video_url, type: video_type});
                    })
                    playlist.push(playlist_group);
                });
    
                changeVideo();
            }
    
            function changeVideo(e) {
                if (playlist.length > 0) {
                    $video.html("");
                    $.each(playlist[0], function(index, value) {
                        $video.append('<source src="' + value.url + '" type="' + value.type + '">');
                    });
                    // $video.attr("src", playlist[0])
                    $video[0].play();
                    playlist.splice(0, 1);
                } else {
                    refillPlaylist();
                }
            }
    
            function initialize() {
    
                if (helper.exists($video)) {
                    refillPlaylist();
                    $video[0].addEventListener('ended', changeVideo, false);
                }
            };
    
            return {
                init: initialize()
            };
    
        })();
    };
    },{"helper":44,"vimeo-froogaloop2":67}],21:[function(require,module,exports){
    var helper = require("helper");
    require("bxslider");
    
    exports.init = function($) {
        
        var ImageGallery = (function() {
            
            var captionTogglerSelector = ".image-gallery i[role='button']",
                closerSelector = ".image-gallery .closer i[role='button']",
                pagerSelector = ".image-gallery .bx-pager a[data-slide-index]";
            
            function closeImageGallery() {
                $(closerSelector).hide().closest('.image-gallery').find('.bx-wrapper').fadeOut().siblings('.bx-pager').find('a[data-slide-index]').removeClass('active');
            }
    
            function initialize() {
                
                // bxslider init
                var slider = $('.bxslider').bxSlider({
                    mode: 'fade',
                    controls: false,
                    pagerCustom: '.bx-pager',
                    captions: true,
                    adaptiveHeight: true,
                    onSliderLoad: function () {
                        closeImageGallery();
                    }
                });
                
                // caption toggler
                $(captionTogglerSelector).on('click', function() {
                    var $this = $(this);
                    var $currCaption = $this.closest('.caption');
                    
                    if (helper.exists($currCaption)) {
                        $currCaption.toggleClass('active');
                        $this.toggleClass('fa-minus').toggleClass('fa-plus');
                    }
    
                    return false;
                });
                
                var openOnLoad = $(pagerSelector).closest('.image-gallery').find('.bx-wrapper').closest('.image-gallery.closed').length;
                if (openOnLoad)
                {
                    $(pagerSelector).removeClass('active');
                    $(closerSelector).hide();
                    slider.reloadSlider();
                };
    
                // closer toggler
                $(closerSelector).on('click', function() {
                    $(this).hide().closest('.image-gallery').find('.bx-wrapper').fadeOut().siblings('.bx-pager').find('a[data-slide-index]').removeClass('active');
                });
    
                // pager toggler
                $(pagerSelector).on('click', function() {
                    var $this = $(this);
                    var $currWrapper = $this.closest('.image-gallery').find('.bx-wrapper');
                    if (!$currWrapper.is(":visible")) {
                        $currWrapper.fadeIn();
                        $currWrapper.siblings('.closer').children().show();
                        $this.addClass('active');
                    }
                });
                
            };
            
            return {
                init: initialize
            };
            
        })();
        
        ImageGallery.init();
        
    };
    },{"bxslider":52,"helper":44}],22:[function(require,module,exports){
    var helper = require("helper");
    
    exports.init = function ($) {
    
        var informationBarMenu = (function () {
    
            var $info_bar_menus = $(".info-bar-menus");
            var $all_info_triggers = $(".info-bar-nav div[data-panel]");
            var $all_info_panels = $info_bar_menus.find("[data-panel]");
            var $info_bar_navpanels = $(".info-bar-nav div");
    
            $info_bar_menus.toggleClass("open");
            $all_info_panels.removeClass("open");
            $info_bar_navpanels.removeClass("active");
            $all_info_panels.hide();
    
            function SetupInfoPanel() {
                $all_info_triggers.on("click", function (e) {
                    if ((e.target).className!="fa fa-times") {
                        var $this = $(this);
                        var panel = $this.data("panel");
                        var $panel = $info_bar_menus.find("[data-panel='" + panel + "']");
                        var isAnyNavOpen = $info_bar_menus.hasClass("open");
    
                        var isCurrNavOpen = $panel.hasClass("open");
                        if (isAnyNavOpen) {
    
                            if (!isCurrNavOpen) {
    
                                $all_info_panels.removeClass("open");
                                $info_bar_navpanels.removeClass("active");
                                $all_info_triggers.removeClass("open");
                                $all_info_panels.hide();
                                if (panel !== "close") {
                                    $panel.show().addClass("open");
                                }
                                $this.addClass("open");
                                $this.addClass("active");
                            }
                        } else {
                            $info_bar_menus.toggleClass("open");
                            $all_info_panels.removeClass("open");
                            $info_bar_navpanels.removeClass("active");
                            $all_info_panels.hide();
                            $panel.slideDown();
                            $panel.addClass("open");
                            $this.addClass("open");
                            $this.addClass("active");
                        }
                    }
                });
    
    
                $('body').on('click', function (e) {
                    if ($(e.target).closest($all_info_triggers).length == 0) {
                        $all_info_panels.removeClass("open");
                        $info_bar_navpanels.removeClass("active");
                        $all_info_triggers.removeClass("open");
                        $all_info_panels.hide();
                    }
                });
    
                $('.panel-close').on('click', function (e) {
                    var $element = ($(e.target).closest("div[data-panel]"));
                    var panel = $element.data("panel");
                    var $panel = $info_bar_menus.find("[data-panel='" + panel + "']");
                    var isCurrNavOpen = $panel.hasClass("open");
                    if (isCurrNavOpen) {
                        $element.removeClass("open");
                        $element.removeClass("active");
                        $info_bar_menus.toggleClass("open");
                        $panel.removeClass("open");
                        $panel.hide();
                    }
                });
    
            }
    
            function initialize() {
                SetupInfoPanel();
            }
    
            return {
                init: initialize
            };
    
        })();
    
        informationBarMenu.init();
    };
    },{"helper":44}],23:[function(require,module,exports){
    var ko = require("knockout");
    var _ = require("underscore");
    var helper = require("helper");
    
    exports.init = function ($) {
    
        var Login = (function () {
    
            var $module, viewModel;
    
    
            // ko viewmodel
            var ViewModel = function() {
                var self = this;
    
                self.signupClick = function(location, data){
                    if (window.dataLayer) {
                        window.dataLayer.push({
                             'event': 'sign-up-click', 
                             'click-location': 'body'
                        });
                        setTimeout(function(){
                            window.location = location;
                        },500);
                    }
                };
    
                self.loginSubmit = function(){
                    window.dataLayer.push({ 'event': 'login-submit', 'auth-method': 'email' });
                    setTimeout(function(){
                        document.getElementById('login-custom-form').submit();
                    },500);
                };
    
                self.fbClick = function(){
                    window.dataLayer.push({ 'event': 'login-submit', 'auth-method': 'facebook' });
                    setTimeout(function(){
                        document.getElementById('login-facebook-form').submit();
                    },500);
                };
    
                self.googClick = function(){
                    window.dataLayer.push({ 'event': 'login-submit', 'auth-method': 'google' });
                    setTimeout(function(){
                        document.getElementById('login-google-form').submit();
                    },500);
                };
            };
    
            function setVars() {
    
                // elements
                $module = $('.login-page');
    
                if ($module.length > 0) {
                    return true;
                }
            };
    
            function init() {
                try {
                    var isReady = setVars();
                    if (isReady) {
    
                        $('.myvca-forgot-password a').on('click',function(event){
                            event.preventDefault();
                            var url = $(this).attr('href');
                            if (window.dataLayer){
                                dataLayer.push({ 'event': 'password-reset', 'userAction': 'click' });
                                setTimeout(function(){
                                    window.location = url;
                                },500);
                            }
                        });
    
                        // ko databind
                        viewModel = new ViewModel();
                        ko.applyBindings(viewModel, $module.get(0));
                        
                    }
                } catch (ex) {
                    console.log("Login Component error: " + ex);
                   $module.find('.technical-error').addClass('active');
                }
            };
    
            return {
                init: init()
            }
        })();
    };
    },{"helper":44,"knockout":64,"underscore":66}],24:[function(require,module,exports){
    var ko = require("knockout");
    var _ = require("underscore");
    var helper = require("helper");
    
    exports.init = function ($) {
    
        var ManageAccount = (function () {
    
            var $module, viewModel;
    
            var Settings = {
                ManageAccountControllerUrl: "/api/Single Sign On/ManageAccount/",
                ForgotPasswordUrl: "forgot-password"
            };
    
            // stores the inputs as observables per Address
            var Address = function(obj, countries) {
                var self = this;
    
                this.actual = ko.observable(obj);
    
                this.inputAddressLine1 = ko.observable(obj != null ? obj.AddressLine1 : null);
                this.inputAddressLine2 = ko.observable(obj != null ? obj.AddressLine2 : null);
                this.inputCity = ko.observable(obj != null ? obj.City : null);
                this.inputZipCode = ko.observable(obj != null ? obj.ZipCode : null);
    
                // country
                var initialMatchingCountry = obj != null ? _.find(countries, function(c) {
                    return c.countryCode === obj.Country || c.displayValue === obj.Country;
                }) : null;
                if (initialMatchingCountry === null) {
                    initialMatchingCountry = countries[0]; //default to US
                }
                this.ddSelectedCountry = ko.observable(initialMatchingCountry);
    
                // state
                var initialMatchingState;
                if (obj && obj.State) {
                    initialMatchingState = helper.exists(self.ddSelectedCountry()) ? _.find(self.ddSelectedCountry().states, function (cs) {
                        return cs.stateAbbr === obj.State || cs.displayValue === obj.State;
                    }) : null;
                }
                this.ddSelectedState = ko.observable(initialMatchingState);
                this.ddSelectedState.subscribe(function (newState) {
                    viewModel.checkEnableSubmit();
                });
                this.ddStates = ko.computed(function() {
                    if (self.ddSelectedCountry() == null || typeof self.ddSelectedCountry().states === "undefined") {
                        return [];
                    }
                    return self.ddSelectedCountry().states;
                });
            };
            var Email = function(obj) {
                if (obj != null) {
                    this.emailId = obj.EmailId;
                    this.email = ko.observable(obj.Email);
                    this.inputEmail = ko.observable(obj.Email);
                    this.IsPrimary = obj.IsPrimary;
                } else {
                    this.emailId = 0;
                    this.email = ko.observable("");
                    this.inputEmail = ko.observable("");
                }
            };
    
            var State = function (obj) {
                this.stateAbbr = obj.StateAbbr;
                this.displayValue = obj.DisplayValue;
            };
            var Country = function (obj) {
                this.countryCode = obj.CountryCode;
                this.displayValue = obj.DisplayValue;
                this.states = _.map(obj.States, function (s) {
                    return new State(s);
                });
            };
    
            // ko viewmodel
            var ViewModel = function(obj) {
                var self = this;
    
                self.isEditing = ko.observable(false);
    
                self.actualFirstName = ko.observable(obj.FirstName);
                self.tempFirstName = ko.observable(obj.FirstName);
    
                self.actualLastName = ko.observable(obj.LastName);
                self.tempLastName = ko.observable(obj.LastName);
                self.actualFullName = ko.pureComputed(function() {
                    return self.actualFirstName() + " " + self.actualLastName();
                });
    
                self.tempEmail = ko.observable(obj.Email);
                self.actualEmail = ko.observable(obj.Email);
    
                self.tempPhone = ko.observable(obj.Phone);
                self.actualPhone = ko.observable(obj.Phone);
    
                self.tempSecondaryEmail = ko.observable(obj.SecondaryEmail);
                self.actualSecondaryEmail = ko.observable(obj.SecondaryEmail);
    
                self.actualCoFirstName = ko.observable(obj.CoFirstName != null ? obj.CoFirstName : '');
                self.tempCoFirstName = ko.observable(obj.CoFirstName != null ? obj.CoFirstName : '');
    
                self.actualCoLastName = ko.observable(obj.CoLastName != null ? obj.CoLastName : '');
                self.tempCoLastName = ko.observable(obj.CoLastName != null ? obj.CoLastName : '');
                self.actualCoFullName = ko.pureComputed(function() {
                    return self.actualCoFirstName() + " " + self.actualCoLastName();
                });
    
                self.countries = ko.observableArray(_.map(obj.Countries, function(c) {
                    return new Country(c);
                }));
    
                self.addresses = ko.observableArray([new Address(obj.PrimaryAddress, self.countries())]);        // js supports multiple, but we are only passing in primary
    
                self.primaryEmail = ko.observable(new Email(obj.PrimaryEmail));
                self.secondaryEmail = ko.observable(new Email(obj.SecondaryEmail));
    
                self.primaryPhoneId = obj.PrimaryPhoneId;
                self.primaryPhoneTypeId = obj.PrimaryPhoneTypeId;
                self.actualPrimaryPhone = ko.observable(obj.PrimaryPhone);
                self.tempPrimaryPhone = ko.observable(obj.PrimaryPhone);
                self.viewPrimaryPhone = ko.pureComputed(function () {
                    var tempLabel = helper.exists(self.ddSelectedPrimaryPhoneType()) ? self.ddSelectedPrimaryPhoneType().PhoneTypeLabel : '';
                    var tempPhone = self.actualPrimaryPhone() != null ? self.actualPrimaryPhone().SetPhoneFormat() : '';
                    var tempResult;
    
                    tempResult = tempPhone;
    
                    return tempResult;
                });
                self.primaryPhoneIsVerifiedSmsEnabled = ko.observable(obj.PrimaryIsVerifiedSmsEnabled);
                self.primaryPhoneOptInStatusId = ko.observable(obj.PrimaryPhoneOptInStatusId === 75);
    
                self.secondaryPhoneId = obj.SecondaryPhoneId;
                self.secondaryPhoneTypeId = obj.SecondaryPhoneTypeId;
                self.actualSecondaryPhone = ko.observable(obj.SecondaryPhone);
                self.tempSecondaryPhone = ko.observable(obj.SecondaryPhone);
                self.viewSecondaryPhone = ko.pureComputed(function () {
                    var tempLabel = helper.exists(self.ddSelectedSecondaryPhoneType()) ? self.ddSelectedSecondaryPhoneType().PhoneTypeLabel : '';
                    var tempPhone = self.actualSecondaryPhone() != null ? self.actualSecondaryPhone().SetPhoneFormat() : '';
                    var tempResult;
    
                    tempResult = tempPhone;
    
                    return tempResult;
                });
                self.secondaryPhoneIsVerifiedSmsEnabled = ko.observable(obj.SecondaryIsVerifiedSmsEnabled);
                self.secondaryPhoneOptInStatusId = ko.observable(obj.SecondaryPhoneOptInStatusId === 75);
    
                self.phoneTypes = obj.PhoneTypes;
                self.ddSelectedPrimaryPhoneType = ko.observable(obj.primaryPhoneTypeObj);
                self.actualPrimaryPhoneTypeLabel = helper.exists(self.ddSelectedPrimaryPhoneType()) ?
                    self.ddSelectedPrimaryPhoneType().PhoneTypeWoofwareLabel : null;                        // stored to revert back to when needed
                self.ddSelectedPrimaryPhoneType.subscribe(function (newState) {
                    self.checkEnableSubmit();
                });
    
                self.ddSelectedSecondaryPhoneType = ko.observable(_.find(obj.PhoneTypes, function (pt) {
                    return obj.SecondaryPhoneTypeId === pt.PhoneTypeId &&
                        obj.SecondaryPhoneTypeLabel.toLowerCase() === pt.PhoneTypeWoofwareLabel.toLowerCase();
                }));
                self.actualSecondaryPhoneTypeLabel = helper.exists(self.ddSelectedSecondaryPhoneType()) ?
                    self.ddSelectedSecondaryPhoneType().PhoneTypeWoofwareLabel : null;
                self.ddSelectedSecondaryPhoneType.subscribe(function (newState) {
                    self.checkEnableSubmit();
                });
    
                // errors
                self.invalidInputMessages = ko.observable(null);            // server: invalid inputs
                self.isServiceError = ko.observable(false);                 // server: service operation failed
    
                // helpers
                self.isSubmitEnabled = ko.observable(false);
                self.setOptionValue = function (propId, propId2) {
                    return function (option, item) {
                        if (item === undefined) {
                            option.value = "";
                        } else {
                            if (propId2) {
                                option.value = item[propId] + " " + item[propId2];
                            } else {
                                option.value = item[propId];
                            }
                            
                        }
                    }
                };
    
                // custom check to make sure at least one input has changed before enabling submit
                self.checkEnableSubmit = function () {
                    if (!self.isEditing())
                        return;
    
                    var addressChanged = _.some(self.addresses(), function (a) {
                        // if actual address non-existant, simply check if any inputs are filled out
                        if (a.actual() == null) {
                            return helper.exists(a.ddSelectedCountry()) || helper.exists(a.ddSelectedState()) ||
                                !self.isEmpty(a.inputAddressLine1()) || !self.isEmpty(a.inputAddressLine2()) ||
                                !self.isEmpty(a.inputCity()) || !self.isEmpty(a.inputZipCode());
                        }
    
                        if (!helper.exists(a.ddSelectedCountry()))  // if no country selected, no state is either
                            return false;
    
                        var inputCountry = a.ddSelectedCountry().countryCode;
                        var inputState = helper.exists(a.ddSelectedState()) ? a.ddSelectedState().stateAbbr : null;
    
                        var currState = helper.exists(a.actual()) ? a.actual().State : null;
                        var currCntry = helper.exists(a.actual()) ? a.actual().Country : null;
    
                        var anyAddressInputChanged = a.inputAddressLine1() !== a.actual().AddressLine1 || a.inputAddressLine2() !== a.actual().AddressLine2 ||
                                a.inputCity() !== a.actual().City || a.inputZipCode() !== a.actual().ZipCode;
    
                        return currState !== inputState || currCntry !== inputCountry || anyAddressInputChanged;
                    });
    
                    var singleInputHasChanged =
                        ((self.tempSecondaryPhone() != null ? self.tempSecondaryPhone().replace(/-/g, '') : null) !== self.actualSecondaryPhone()) ||
                        ((self.tempPrimaryPhone() != null ? self.tempPrimaryPhone().replace(/-/g, '') : null) !== self.actualSecondaryPhone()) ||
                        (self.primaryEmail().email() !== self.primaryEmail().inputEmail()) || (self.secondaryEmail().email() !== self.secondaryEmail().inputEmail()) ||
                        (self.tempFirstName().toLowerCase() !== self.actualFirstName().toLowerCase()) || (self.tempLastName().toLowerCase() !== self.actualLastName().toLowerCase()) ||
                        (self.tempCoFirstName().toLowerCase() !== self.actualCoFirstName().toLowerCase()) || (self.tempCoLastName().toLowerCase() !== self.actualCoLastName().toLowerCase()) ||
                        (self.primaryPhoneTypeId !== (typeof self.ddSelectedPrimaryPhoneType() !== "undefined" ? self.ddSelectedPrimaryPhoneType().PhoneTypeId : undefined)) ||
                        (self.secondaryPhoneTypeId !== (typeof self.ddSelectedSecondaryPhoneType() !== "undefined" ? self.ddSelectedSecondaryPhoneType().PhoneTypeId : undefined)) ||
                        (addressChanged);
    
                    self.isSubmitEnabled(singleInputHasChanged);
                }
                self.validateForm = function(form) {
                    var myLang = {}, myConf = {};
                    if (!$(form).isValid(myLang, myConf)) {
                        return false;
                    }
    
                    return true;
                };
                self.resetTempFieldsToActual = function() {
    
                    // reset reg inputs
                    self.tempFirstName(self.actualFirstName());
                    self.tempLastName(self.actualLastName());
                    self.tempCoFirstName(self.actualCoFirstName());
                    self.tempCoLastName(self.actualCoLastName());
                    self.primaryEmail().inputEmail(self.primaryEmail().email());
                    self.secondaryEmail().inputEmail(self.secondaryEmail().email());
                    self.tempPrimaryPhone(self.actualPrimaryPhone());
                    self.tempSecondaryPhone(self.actualSecondaryPhone());
    
                    // reset address objects
                    _.each(self.addresses(), function(a) {
                        var actual = a.actual();
    
                        if (!helper.exists(actual))
                            return;
    
                        a.inputAddressLine1(actual.AddressLine1);
                        a.inputAddressLine2(actual.AddressLine2);
                        a.inputCity(actual.City);
                        a.inputZipCode(actual.ZipCode);
                    });
    
                    // reset phone types
                    self.ddSelectedPrimaryPhoneType(_.find(self.phoneTypes, function(pt) {
                        return pt.PhoneTypeWoofwareLabel === self.actualPrimaryPhoneTypeLabel;
                    }));
                    self.ddSelectedSecondaryPhoneType(self.actualSecondaryPhoneTypeLabel == null ? null :_.find(self.phoneTypes, function (pt) {
                        return pt.PhoneTypeWoofwareLabel === self.actualSecondaryPhoneTypeLabel;
                    }));
                };
                self.setActualFieldsFromServiceUpdate = function(client) {
    
                    // owner & co-owner
                    self.actualFirstName(client.FirstName);
                    self.actualLastName(client.LastName);
                    self.actualCoFirstName(client.CoOwnerFirstName);
                    self.actualCoLastName(client.CoOwnerLastName);
    
                    // emails
                    if (helper.exists(client.ClientEmails)) {
                        var newPrimaryEmail = _.find(client.ClientEmails, function(e) {
                            return e.IsPrimary;
                        });
                        if (helper.exists(newPrimaryEmail)) {
                            self.primaryEmail(new Email(newPrimaryEmail));
                        }
    
                        var newSecondaryEmail = _.find(client.ClientEmails, function (e) {
                            return !e.IsPrimary;
                        });
                        if (helper.exists(newSecondaryEmail)) {
                            self.secondaryEmail(new Email(newSecondaryEmail));
                        }
                    }
    
                    // phones
                    if (helper.exists(client.ClientPhones)) {
                        var newPrimaryPhone = _.find(client.ClientPhones, function (p) {
                            return p.IsPrimaryContact;
                        });
                        if (helper.exists(newPrimaryPhone)) {
                            self.actualPrimaryPhone(newPrimaryPhone.PhoneNumber);
                            self.primaryPhoneId = newPrimaryPhone.PhoneId;
                        }
    
                        var newSecondaryPhone = _.find(client.ClientPhones, function (p) {
                            return !p.IsPrimaryContact;
                        });
                        if (helper.exists(newSecondaryPhone)) {
                            self.actualSecondaryPhone(newSecondaryPhone.PhoneNumber);
                            self.secondaryPhoneId = newSecondaryPhone.PhoneId;
                        }
                    }
    
                    // addresses
                    if (helper.exists(client.Addresses)) {
    
                        _.each(self.addresses(), function (a) {
                            var actualObj = a.actual();
    
                            if (actualObj == null) {
                                a.actual(client.Addresses[0]);
                                return;
                            }
    
                            var matchingMailingAddress = _.find(client.Addresses, function (aa) {
                                return actualObj.AddressId === aa.AddressId;
                            });
                            if (helper.exists(matchingMailingAddress)) {
                                a.actual(matchingMailingAddress);
                            }
                        });
                    }
                };
                self.isEmpty = function(str) {
                    return str == null || $.trim(str) === '';
                }
    
                // events
                self.clickEdit = function (data, event) {
                    self.isEditing(true);
                };
                self.clickCancel = function (data, event) {
                    self.clearFormErrors();
                    self.resetTempFieldsToActual();
                    self.invalidInputMessages(null);
                    self.isServiceError(false);
                    self.isEditing(false);
                };
    
                self.clearFormErrors = function () {
                    $('#macc-err-summary').children().remove();
                    $('input,select').removeClass('error').removeAttr('style');
                };
                
                self.submitAccountInfo = function(form) {
    
                    var isValid = self.validateForm(form);
                    if (!isValid) {
                        return;
                    }
    
                    var sentParams = {
                        hospitalId: VCA.HospitalId,
                        firstName: self.tempFirstName(),
                        lastName: self.tempLastName(),
                        coFirstName: self.tempCoFirstName(),
                        coLastName: self.tempCoLastName(),
                        addresses: _.map(self.addresses(), function(a) {
                            var isNewAddress = !helper.exists(a.actual());
                            return {
                                addressId: isNewAddress ? 0 : a.actual().AddressId,
                                addressLine1: a.inputAddressLine1(),
                                addressLine2: a.inputAddressLine2(),
                                city: a.inputCity(),
                                zipCode: a.inputZipCode(),
                                addressType: isNewAddress ? "Default" : a.actual().AddressType,
                                IsMailingAddress: isNewAddress ? true : a.actual().IsMailingAddress,
                                country: a.ddSelectedCountry() != null ? a.ddSelectedCountry().countryCode : "",
                                state: a.ddSelectedState() != null ? a.ddSelectedState().stateAbbr : ""
                            };
                        }),
                        primaryEmail: self.primaryEmail().inputEmail(),
                        primaryEmailId: self.primaryEmail().emailId,
                        secondaryEmail: self.secondaryEmail().inputEmail(),
                        secondaryEmailId: self.secondaryEmail().emailId,
                        primaryPhoneId: self.primaryPhoneId,
                        primaryPhoneTypeWoofwareLabel: 'Other',
                        primaryPhoneTypeId: 16,
                        primaryPhone: helper.exists(self.tempPrimaryPhone()) ? self.tempPrimaryPhone().StripPhoneFormat() : null,
                        secondaryPhoneId: self.secondaryPhoneId,
                        secondaryPhoneTypeWoofwareLabel: 'Other',
                        secondaryPhoneTypeId: 16,
                        secondaryPhone: helper.exists(self.tempSecondaryPhone()) ? self.tempSecondaryPhone().StripPhoneFormat() : null,
                        PrimaryPhoneOptInStatusId: self.primaryPhoneOptInStatusId() ? 75 : 0,
                        SecondaryPhoneOptInStatusId: self.secondaryPhoneOptInStatusId() ? 75: 0
                    };
    
                    // service call to /UpdateUserInfo
                    $.ajax({
                        url: Settings.ManageAccountControllerUrl + "UpdateUserInfo",
                        dataType: 'json',
                        type: 'POST',
                        data: sentParams,
                        cache: false,
                        success: function(data) {
                            if (data != null) {
    
                                self.invalidInputMessages(data.InvalidInputMessages.length ? data.InvalidInputMessages : null);
                                self.isServiceError(data.IsServiceError);
    
                                if (data.UpdatedClient != null) {
                                    self.isEditing(false);
                                    self.setActualFieldsFromServiceUpdate(data.UpdatedClient);
                                }
                            }
                        },
                        error: function(jqXHR, status, err) {
                            console.log(jqXHR.status + "," + jqXHR.responseText + "," + status + "," + err);
                        }
                    });
                };
    
                self.changePassword = function() {
                    var scController = $('#pwf-email-form #scController').val();
                    var scAction = $('#pwf-email-form #scAction').val();
                    var fpTargetId = $('#pwf-email-form #fpTargetId').val();
                    $.ajax({
                        url: Settings.ForgotPasswordUrl,
                        type: 'POST',
                        data: {
                            scController: scController,
                            scAction: scAction,
                            UserEmail: VCA.ManageAccountSettings.ViewModel.SSOUsername,
                            __AjaxFormData: fpTargetId
                        },
                        cache: false,
                        success: function(data) {
                            $('.forgot-password-btn').hide();
                            $('.forgot-password-confirm').removeClass('hidden');
                        },
                        error: function(jqXHR, status, err) {
                            console.log(jqXHR.status + "," + jqXHR.responseText + "," + status + "," + err);
                        }
                    });
                };
            };
    
            function setVars() {
                if (typeof VCA === "undefined" || typeof VCA.ManageAccountSettings === "undefined" || typeof VCA.ManageAccountSettings.ViewModel === "undefined")
                    return false;
    
                // elements
                $module = $('.manage-account');
    
                return true;
            };
    
            function setEvents() {
                // after user has stopped typing
                $module.find('input').on('keyup', function() {
                    helper.delay(function() {
                        viewModel.checkEnableSubmit();
                    }, 1000);
                });
            };
    
            // setting new properties before constructing KO ViewModel
            function setNewViewModelProperties(obj) {
                // primary phone numer
                var matchingPrimaryPhoneType = _.find(obj.PhoneTypes, function (pt) {
                    return obj.PrimaryPhoneTypeId === pt.PhoneTypeId &&
                        obj.PrimaryPhoneTypeLabel.toLowerCase() === pt.PhoneTypeWoofwareLabel.toLowerCase();
                });
                obj.primaryPhoneTypeObj = helper.exists(matchingPrimaryPhoneType) ?
                    matchingPrimaryPhoneType :
                    _.find(obj.PhoneTypes, function(pt) {
                        return pt.PhoneTypeId === 16;
                    });
            };
    
            function init() {
                try {
                    var isReady = setVars();
                    if (isReady) {
    
                        var tempVM = VCA.ManageAccountSettings.ViewModel;
                        setNewViewModelProperties(tempVM);
    
                        // ko databind
                        viewModel = new ViewModel(tempVM);
                        ko.applyBindings(viewModel, $module.get(0));
                        setEvents();
                        jQuery('.FlowupLabels').FlowupLabels();
                        $('.wrap_cncl input').on('click',function(){
                            window.location = $('.back-cta a').attr('href');
                        });
                    }
                } catch (ex) {
                    console.log("Manage Account error: " + ex);
                   $module.find('.technical-error').addClass('active');
                }
            };
    
            return {
                init: init()
            }
        })();
    };
    },{"helper":44,"knockout":64,"underscore":66}],25:[function(require,module,exports){
    var ko = require("knockout");
    var _ = require("underscore");
    var helper = require("helper");
    
    exports.init = function ($) {
        //polyfill for browsers that don't support HTMLCanvasElement.toBlob
        if (!HTMLCanvasElement.prototype.toBlob) {
            Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {
                value: function (callback, type, quality) {
    
                    var binStr = atob(this.toDataURL(type, quality).split(',')[1]),
                        len = binStr.length,
                        arr = new Uint8Array(len);
    
                    for (var i = 0; i < len; i++) {
                        arr[i] = binStr.charCodeAt(i);
                    }
    
                    callback(new Blob([arr], {
                        type: type || 'image/png'
                    }));
                }
            });
        }
    
    
        var ManagePet = (function () {
            var $module, $modalFileUpload, $modalCrop, viewModel, imageUploaded, currentPet;
    
            var Settings = {
                PetPhotoMaxFileUploadSize: 0,
                ManagePetControllerUrl: "/api/Single Sign On/ManagePet/"
            };
    
            var Pet = function (obj) {
                this.breedName = ko.observable(obj.BreedName);
                this.patientId = obj.PatientId;
                this.petAge = ko.observable(obj.PetAge);
                this.petName = ko.observable(obj.PetName);
                this.petPhotoBase64 = ko.observable(obj.PetPhotoBase64);
            };
    
            // ko viewmodel
            var ViewModel = function (obj) {
                var self = this;
    
                self.isEditing = ko.observable(false);
    
                self.pets = ko.observableArray([new Pet(obj.Pet)]);
                self.sexs = ko.observableArray(obj.Sexs);
                self.specieses = ko.observableArray(obj.Specieses);
                self.neutered = ko.observableArray([{ 'txt': 'Yes', 'val': 'Yes' }, { 'txt': 'No', 'val': 'No' }]);
                self.appearance = ko.observableArray(obj.Appearances);
                
                self.actualPetName = ko.observable(obj.Pet.PetName);
                self.tempPetName = ko.observable(obj.Pet.PetName);
    
                self.actualSexId = ko.observable(obj.Pet.SexId);
                self.tempSexId = ko.observable(obj.Pet.SexId);
    
                self.actualSexName = ko.observable(obj.Pet.SexName);
                self.tempSexName = ko.observable(obj.Pet.SexName);
    
                self.actualSpeciesId = ko.observable(obj.Pet.SpeciesId);
                self.tempSpeciesId = ko.observable(obj.Pet.SpeciesId);
    
                self.breed = ko.computed(function () {
                    if (self.tempSpeciesId()) {
                        return obj.Breeds.filter(function (val) {
                            return val.SpeciesId === self.tempSpeciesId()
                        });
                    }
                    return obj.Breeds;
                });
    
                self.actualSpeciesName = ko.observable(obj.Pet.SpeciesName);
                self.tempSpeciesName = ko.observable(obj.Pet.SpeciesName);
    
                self.invalidInputMessages = ko.observable(null);            // server: invalid inputs
                self.isServiceError = ko.observable(false);                 // server: service operation failed
    
                var neuteredComputed = ko.computed(function () {
                    if (obj.Pet.Neutered && obj.Pet.Neutered !== 'No') {
                        return 'Yes';
                    }
                    return 'No';
                });
    
                self.actualNeutered = ko.observable(neuteredComputed());
                self.tempNeutered = ko.observable(neuteredComputed());
    
                var appearanceComputed = ko.computed(function () {
                    if (obj.Pet.Appearances && obj.Pet.Appearances.length > 0) {
                        return obj.Pet.Appearances[0];
                    }
                    return null;
                });
    
                self.actualAppearanceId = ko.observable(appearanceComputed() !== null ? appearanceComputed().AppearanceId : appearanceComputed());
                self.tempAppearanceId = ko.observable(appearanceComputed() !== null ? appearanceComputed().AppearanceId : appearanceComputed());
    
                self.actualAppearanceValue = ko.observable(appearanceComputed() !== null ? appearanceComputed().AppearanceName : appearanceComputed());
                self.tempAppearanceValue = ko.observable(appearanceComputed() !== null ? appearanceComputed().AppearanceName : appearanceComputed());
    
                var breedComputed = ko.computed(function () {
                    if (obj.Pet.Breeds && obj.Pet.Breeds.length > 0) {
                        return obj.Pet.Breeds[0];
                    }
                    return null;
                });
    
                self.actualBreedId = ko.observable(breedComputed() !== null ? breedComputed().BreedId : breedComputed());
                self.tempBreedId = ko.observable(breedComputed() !== null ? breedComputed().BreedId : breedComputed());
    
                self.actualBreedName = ko.observable(breedComputed() !== null ? breedComputed().BreedName : breedComputed());
                self.tempBreedName = ko.observable(breedComputed() !== null ? breedComputed().BreedName : breedComputed());
    
                self.actualPetWeight = ko.observable(obj.Pet.Weight);
                self.tempPetWeight = ko.observable(obj.Pet.Weight);
    
                if (obj.Pet.DateOfBirth) {
                    var dobFromService = moment(obj.Pet.DateOfBirth).utcOffset(new Date().getTimezoneOffset());
                    self.actualPetDateOfBirth = ko.observable(dobFromService.format('M-D-YYYY'));
                    self.tempPetDateOfBirth = ko.observable(dobFromService.format('M-D-YYYY'));
                } else {
                    self.actualPetDateOfBirth = ko.observable();
                    self.tempPetDateOfBirth = ko.observable();
                }
                
    
                self.resetTempFieldsToActual = function () {
                    self.tempPetName(self.actualPetName());
                    self.tempSexId(self.actualSexId());
                    self.tempSexName(self.actualSexName());
                    self.tempSpeciesId(self.actualSpeciesId());
                    self.tempSpeciesName(self.actualSpeciesName());
                    self.tempNeutered(self.actualNeutered());
                    self.tempAppearanceId(self.actualAppearanceId());
                    self.tempAppearanceValue(self.actualAppearanceValue());
                    self.tempBreedId(self.actualBreedId());
                    self.tempBreedName(self.actualBreedName());
                    self.tempPetWeight(self.actualPetWeight());
                    self.tempPetDateOfBirth(self.actualPetDateOfBirth());
                };
    
                self.isSubmitEnabled = ko.observable(false);
    
                self.checkEnableSubmit = function () {
                    if (!self.isEditing())
                        return;
    
    
                    var singleInputHasChanged = true;
    
                    self.isSubmitEnabled(singleInputHasChanged);
                }
    
                self.validateForm = function (form) {
                    var myLang = {}, myConf = {};
                    if (!$(form).isValid(myLang, myConf)) {
                        return false;
                    }
    
                    return true;
                };
    
                self.submitPetInfo = function (form) {
                    var isValid = self.validateForm(form);
                    if (!isValid) {
                        return;
                    }
    
                    var appearanceValue, breedName, speciesName, sexName;
                    VCA.ManagePetSettings.ViewModel.Appearances.forEach(function (val) {
                        if (val.AppearanceId === self.tempAppearanceId()) {
                            appearanceValue = val.AppearanceValue;
                        }
                    });
                    VCA.ManagePetSettings.ViewModel.Breeds.forEach(function (val) {
                        if (val.BreedId === self.tempBreedId()) {
                            breedName = val.BreedName;
                        }
                    });
                    VCA.ManagePetSettings.ViewModel.Sexs.forEach(function (val) {
                        if (val.SexId === self.tempSexId()) {
                            sexName = val.Name;
                        }
                    });
                    VCA.ManagePetSettings.ViewModel.Specieses.forEach(function (val) {
                        if (val.SpeciesId === self.tempSpeciesId()) {
                            speciesName = val.SpeciesName;
                        }
                    });
    
                    var sentParams = {
                        hospitalId: VCA.HospitalId,
                        patientId: VCA.ManagePetSettings.ViewModel.Pet.PatientId, 
                        petName: self.tempPetName(),
                        DateOfBirth: moment(self.tempPetDateOfBirth(), 'M-D-YYYY').format('M/D/YYYY'), 
                        speciesId: self.tempSpeciesId(),
                        speciesName: speciesName,
                        breedId: self.tempBreedId(), 
                        breedName: breedName,
                        appearanceId: self.tempAppearanceId(),
                        appearanceName: appearanceValue,
                        Neutered: self.tempNeutered(),
                        Weight: self.tempPetWeight(),
                        SexId: self.tempSexId(),
                        SexName: sexName
                    };
    
                    $.ajax({
                        url: Settings.ManagePetControllerUrl + "UpdateUserPetInfo",
                        dataType: 'json',
                        type: 'POST',
                        data: sentParams,
                        cache: false,
                        success: function (data) {
                            if (data != null) {
                                if (data.UpdatedPet != null) {
                                    self.isEditing(false);
                                    self.setActualFieldsFromServiceUpdate(data.UpdatedPet);
    
                                    if (window.dataLayer) {
                                        dataLayer.push({ 'event': 'pet-profile', 'userAction': 'submit' });
                                    }
    
                                }
                            }
                            $("#datepicker-petdob").datepicker("destroy");
                        },
                        error: function (jqXHR, status, err) {
                            console.log(jqXHR.status + "," + jqXHR.responseText + "," + status + "," + err);
                            $("#datepicker-petdob").datepicker("destroy");
                        }
                    });
                };
    
                self.setActualFieldsFromServiceUpdate = function (pet) {
                    self.actualPetName(pet.PatientName);
                    self.actualSexId(pet.Sex.SexId);
                    self.actualSexName(pet.Sex.Name);
                    self.actualSpeciesId(pet.SpeciesId);
                    self.actualSpeciesName(pet.SpeciesName);
                    self.actualNeutered(pet.Neutered);
                    if (pet.Appearances && pet.Appearances.length > 0) {
                        self.actualAppearanceId(pet.Appearances[0].AppearanceId);
                        self.actualAppearanceValue(pet.Appearances[0].AppearanceName);
                    }
                    if (pet.Breeds && pet.Breeds.length > 0) {
                        self.actualBreedId(pet.Breeds[0].BreedId);
                        self.actualBreedName(pet.Breeds[0].BreedName);
                    }
                    self.actualPetWeight(pet.Weight);
                    var dobFromService = moment(pet.DateOfBirth).utcOffset(new Date().getTimezoneOffset());
                    self.actualPetDateOfBirth(dobFromService.format('M-D-YYYY'));
                };
    
                self.clickCancel = function (data, event) {
                    $("#datepicker-petdob").datepicker("destroy");
                    self.clearFormErrors();
                    self.resetTempFieldsToActual();
                    self.invalidInputMessages(null);
                    self.isServiceError(false);
                    self.isEditing(false);
                };
    
                self.clearFormErrors = function () {
                    $('#mpet-err-summary').children().remove();
                    $('input,select').removeClass('error').removeAttr('style');
                };
    
                self.startUploadImage = function (file, pet, target) {
    
                    var isValid = true;
    
                    // if cancelled, return
                    if (typeof file === "undefined") {
                        return;
                    }
    
                    // invalid if doesn't match extension or size is too large
                    //if (!file || !file.type.match(/image.*/) || file.size / 1024 > Settings.PetPhotoMaxFileUploadSize) {
                    //    isValid = false;
                    //}
    
                    if (isValid) {
                        imageUploaded = file;
                        currentPet = pet;
                        $modalCrop.modal({
                            backdrop: 'static',
                            keyboard: false
                        });
                    } else {
                        $modalFileUpload.modal();
                    }
                };
    
                $modalCrop.on('shown.bs.modal', function (e) {
                    var preview = document.getElementById('preview');
                    var reader = new FileReader();
                    reader.addEventListener("load", function () {
                        preview.src = reader.result;
                        jQuery(preview).cropper({
                            aspectRatio: 1,
                            zoomable: false,
                            zoomOnTouch: false,
                            zoomOnWheel: false,
                            background: false
                        });
                    }, false);
                    reader.readAsDataURL(imageUploaded);
                });
    
                $modalCrop.on('hidden.bs.modal', function (e) {
                    var preview = document.getElementById('preview');
                    preview.src = '/Includes/_images/000000-0.0.png';
                });
    
                self.rotateClockwise = function () {
                    var preview = document.getElementById('preview');
                    jQuery(preview).cropper('rotate', 90);
                };
    
                self.rotateCounterClockwise = function () {
                    var preview = document.getElementById('preview');
                    jQuery(preview).cropper('rotate', -90);
                };
    
                self.okUploadImage = function () {
                    var preview = document.getElementById('preview');
                    var cropped = jQuery(preview).cropper('getCroppedCanvas', {
                        width: 200,
                        height: 200
                    });
                    cropped.toBlob(function (blob) {
                        self.uploadImage(blob, currentPet);
                    });
                    jQuery(preview).cropper('destroy');
                    $modalCrop.modal('hide');
                };
    
                self.cancelUploadImage = function () {
                    var preview = document.getElementById('preview');
                    jQuery(preview).cropper('destroy');
                    $modalCrop.modal('hide');
                };
    
                self.uploadImage = function (file, pet, target) {
                    var formData = new FormData();
                    formData.append("hospitalId", VCA.HospitalId);
                    formData.append("patientId", pet.patientId);
                    formData.append("petPhotoUpload", file);
    
                    // service call to /UpdateUserPetPhoto
                    $.ajax({
                        url: Settings.ManagePetControllerUrl + "UpdateUserPetPhoto",
                        dataType: 'json',
                        type: 'POST',
                        data: formData,
                        cache: false,
                        contentType: false,
                        processData: false,
                        success: function (data) {
    
                            if (data != null) {
                                var newPetPhotoBase64 = data.PetPhotoBase64;
                                var isServiceError = data.IsServiceError;
    
                                if (!isServiceError && newPetPhotoBase64 != null) {
                                    pet.petPhotoBase64("data:image/gif;base64," + newPetPhotoBase64);
                                    $('.myvca-pet-image').css({'visibility': 'visible'});
                                } else {
                                    $modalFileUpload.modal();
                                }
                            }
                        },
                        error: function (jqXHR, status, err) {
                            console.log(jqXHR.status + "," + jqXHR.responseText + "," + status + "," + err);
                        }
                    });
                };
    
                $('#datepicker-petdob').datepicker({
                    showOn: "both",
                    buttonImageOnly: false,
                    dayNamesShort: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                    showButtonPanel: true,
                    closeText: 'Close',
                    minDate: null,
                    maxDate: 0,
                    changeMonth: true,
                    changeYear: true,
                    yearRange: "-20:+0",
                    dateFormat: "m-d-yy",
                    onSelect: function (dateText, inst) {
                        self.tempPetDateOfBirth(dateText);
                        viewModel.checkEnableSubmit();
                        $(this).closest('.fl_wrap').addClass('focused');
                    }
                });
    
            };
    
            function setEvents() {
                $module.find('input').on('keyup', function () {
                    helper.delay(function () {
                        viewModel.checkEnableSubmit();
                    }, 100);
                });
                $module.find('select').on('change', function () {
                    helper.delay(function () {
                        viewModel.checkEnableSubmit();
                    }, 100);
                });
            };
    
            function setVars() {
                if (typeof VCA === "undefined" || typeof VCA.ManagePetSettings === "undefined" || typeof VCA.ManagePetSettings.ViewModel === "undefined")
                    return false;
    
                // settings
                Settings.PetPhotoMaxFileUploadSize = VCA.ManagePetSettings.PetPhotoMaxFileUploadSize;
    
                // elements
                $module = $('.manage-pet');
                $modalFileUpload = $('.modal-manage-account-fileupload');
                $modalCrop = $('.modal-manage-account-fileuploadcrop');
    
                return true;
            };
    
            function init() {
                try {
                    var isReady = setVars();
                    if (isReady) {
    
                        var tempVM = VCA.ManagePetSettings.ViewModel;
    
                        // ko databind
                        viewModel = new ViewModel(tempVM);
                        ko.applyBindings(viewModel, $module.get(0));
                        ko.applyBindings(viewModel, document.getElementsByClassName('modal-manage-account-fileuploadcrop')[0]);
                        setEvents();
                        jQuery('.FlowupLabels').FlowupLabels();
    
                        setTimeout(function(){
                            $('.myvca-pet-image').css({'visibility': 'visible'});
                        },500);
    
                        $('.wrap_cncl input').on('click',function(){
                            window.location = $('.back-cta a').attr('href');
                        });
                    }
                } catch (ex) {
                    console.log("Manage Account error: " + ex);
                    $module.find('.technical-error').addClass('active');
                }
            };
    
            return {
                init: init()
            }
    
        })();
    
    };
    },{"helper":44,"knockout":64,"underscore":66}],26:[function(require,module,exports){
    var helper = require("helper");
    
    exports.init = function ($) {
    
        var MobileNavMenu = (function () {
    
            var $mobile_menus = $(".mobile-menus");
            var $all_drawer_triggers = $(".mobile-nav li[data-panel]");
            var $all_panels = $mobile_menus.find("[data-panel]");
            var $menu_icon = $(".mobile-nav li[data-panel='menu']");
            var $close_icon = $(".mobile-nav li[data-panel='close']");
            var $footer_nav = $(".footer-wrapper .links [data-panel]");
            var $emergency_footer_link = $(".footer-wrapper .links .emergency");
    
            function setUpChildMenuItems() {
                $(".mobile-menus li.has-children span").on("click", function () {
                    var $this = $(this);
                    $this.parent().find("> ul").slideToggle();
                    $this.closest('.has-children').toggleClass('active');
                });
            }
    
            function setUpMobileFooterNavEvents() {
                var isMobile = $(".mobile-nav").is(":visible");
                $footer_nav.on("click", function (e) {
                    //var isMobile = $(".mobile-nav").is(":visible");
                    if (isMobile) {
                        var $this = $(this);
                        var panel = $this.data("panel");
    
                        if (panel) {
                            window.scrollTo(0, 0);
                            var $panel = $mobile_menus.find("[data-panel='" + panel + "']");
                            var isAnyNavOpen = $mobile_menus.hasClass("open");
    
                            //get top nav and footer elements
                            var $topThis = $(".mobile-nav ." + panel).parent();
                            var $footerThis = $(".footer-wrapper .links ." + panel);
    
                            if (panel === "menu" || panel === "close") {
                                $panel = $mobile_menus.find("[data-panel='menu']");
                                $menu_icon.toggleClass("hide");
                                $close_icon.toggleClass("hide");
                            } else {
                                $close_icon.addClass("hide");
                                $menu_icon.removeClass("hide");
                            }
    
                            if (!$panel.length) {
                                return;
                            }
    
                            var isCurrNavOpen = $panel.hasClass("open");
                            if (isAnyNavOpen) {
                                if (isCurrNavOpen) {
                                    $all_panels.removeClass("open");
                                    $all_drawer_triggers.removeClass("open");
                                    $panel.slideUp();
                                    $mobile_menus.toggleClass("open");
                                    //$this.removeClass("open");
                                    $topThis.removeClass("open");
                                    $footerThis.removeClass("open");
                                } else {
                                    $all_panels.removeClass("open");
                                    $all_drawer_triggers.removeClass("open");
                                    $all_panels.hide();
                                    if (panel !== "close") {
                                        $panel.show().addClass("open");
                                    }
                                    //$this.addClass("open");
                                    $topThis.addClass("open");
                                    $footerThis.addClass("open");
                                }
                            } else {
                                $mobile_menus.toggleClass("open");
                                $all_panels.removeClass("open");
                                $all_panels.hide();
                                $panel.slideDown();
                                $panel.addClass("open");
                                //$this.addClass("open");
                                $topThis.addClass("open");
                                $footerThis.addClass("open");
                            }
    
                            e.preventDefault();
                            e.stopPropagation();
                        }//end of panel
    
                    }
    
                });
    
                if (isMobile && $emergency_footer_link.attr("data-target") != "#emergencyModalMobile") {
                    $emergency_footer_link.attr("data-target", "#emergencyModalMobile");
                }
    
                if (!isMobile && $emergency_footer_link.attr("data-target") == "#emergencyModalMobile") {
                    $emergency_footer_link.attr("data-target", "#emergencyModal");
                }
            }
    
            function setUpMobileUtilityIconEvents() {
    
                $all_drawer_triggers.on("click", function (e) {
                    var $this = $(this);
                    var panel = $this.data("panel");
                    var $panel = $mobile_menus.find("[data-panel='" + panel + "']");
                    var isAnyNavOpen = $mobile_menus.hasClass("open");
    
                    if (panel === "menu" || panel === "close") {
                        $panel = $mobile_menus.find("[data-panel='menu']");
                        $menu_icon.toggleClass("hide");
                        $close_icon.toggleClass("hide");
                    } else {
                        $close_icon.addClass("hide");
                        $menu_icon.removeClass("hide");
                    }
    
                    if (!$panel.length) {
                        return;
                    }
    
                    var isCurrNavOpen = $panel.hasClass("open");
                    if (isAnyNavOpen) {
                        if (isCurrNavOpen) {
                            $all_panels.removeClass("open");
                            $all_drawer_triggers.removeClass("open");
                            $panel.slideUp();
                            $mobile_menus.toggleClass("open");
                            $this.removeClass("open");
                        } else {
                            $all_panels.removeClass("open");
                            $all_drawer_triggers.removeClass("open");
                            $all_panels.hide();
                            if (panel !== "close") {
                                $panel.show().addClass("open");
                            }
                            $this.addClass("open");
                        }
                    } else {
                        $mobile_menus.toggleClass("open");
                        $all_panels.removeClass("open");
                        $all_panels.hide();
                        $panel.slideDown();
                        $panel.addClass("open");
                        $this.addClass("open");
                    }
    
                    e.preventDefault();
                    e.stopPropagation();
                });
            }
    
            function initialize() {
                setUpChildMenuItems();
                setUpMobileUtilityIconEvents();
                setUpMobileFooterNavEvents();
            };
    
            return {
                init: initialize
            };
    
        })();
    
        MobileNavMenu.init();
    };
    },{"helper":44}],27:[function(require,module,exports){
    var ko = require("knockout");
    var _ = require("underscore");
    var helper = require("helper");
    
    exports.init = function ($) {
    
        var ClientNotFound = (function () {
    
            var $module;
    
            function setVars() {
    
                // elements
                $module = $('.password-confirm');
    
                if ($module.length > 0) {
                    return true;
                }
            };
    
            function init() {
                try {
                    var isReady = setVars();
                    if (isReady) {
                        if (window.dataLayer){
                            var authMethod = $('#auth-method').val();
                            console.log('authMethod', authMethod);
                            dataLayer.push({
                                'event': 'sign-up-auth',
                                'auth-method': authMethod,
                                'auth-status': 'success'
                                });
                        }
                    }
                } catch (ex) {
                    console.log("Password Confirm Component error: " + ex);
                   $module.find('.technical-error').addClass('active');
                }
            };
    
            return {
                init: init()
            }
        })();
    };
    },{"helper":44,"knockout":64,"underscore":66}],28:[function(require,module,exports){
    var $ = require("jquery");
    var ko = require("knockout");
    var _ = require("underscore");
    var helper = require("helper");
    
    exports.init = function () {
    
        var GlobalSettings = {
            VCAContextSiteName: window.VCAContextSiteName
        };
    
        /* Pet Health Library */
        var PetAdoption = (function () {
    
            // vars
            var viewModel;
            var $module = $('.pet-adoption-module');
            var $selectState, $primarySearcher, $queriedShelters;
    
            // settings
            var Settings = {
                pageLoadCount: null,        // sitecore managed
                LoadMoreCount: null,        // sitecore managed
                GetMoreCount: null,         // sitecore managed
                QueryModes: {				// where the selected value of the dropdown is stored
                    State: {
                        filters: ['.category'],
                        currVal: null
                    }
                }
            }
    
            // service call
            function getData() {
    
                var sentParams = {
                    State: Settings.QueryModes.State.currVal,
                    VCAContextSiteName: GlobalSettings.VCAContextSiteName
                };
    
                $.ajax({
                    url: '/api/Search/PetAdoptionApi/GetSheltersFromState',
                    dataType: 'json',
                    type: 'POST',
                    data: sentParams,
                    cache: false,
                    success: function (data) {
                        if (data != null) {
                            viewModel.results(data.FacetResultItems);
                        }
                        else {
                            console.log("PetAdoptionApi/GetSheltersFromState: data is null.");
                        }
                    },
                    error: function (jqXHR, status, err) {
                        console.log(jqXHR.status + "," + jqXHR.responseText + "," + status + "," + err);
                    }
                });
            }
    
            //constructor: shelter result item
            var ShelterDetail = function (obj) {
                this.name = obj.ShelterName;
                this.desc = obj.ShelterDesc;
                this.img = obj.ShelterImage;
                this.website = obj.ShelterWebsite;
            }
    
            // knockout viewmodel
            var ViewModel = function () {
                var self = this;            
                self.results = ko.observableArray();
                self.viewResults = ko.computed(function () {
    
                    //var shelterResults = _.map(self.results(), function (r) {
                    //    return new ShelterDetail(r);
                    //});
    
                    var groupList = [];
                    var cnt = 0;
                    _.each(self.results(), function (r, i) {
                        if (i % 3 === 0) {
                            if (i !== 0) {
                                cnt++;
                            }
                            groupList.push([]);
                            groupList[cnt].push(new ShelterDetail(r));
                        } else {
                            groupList[cnt].push(new ShelterDetail(r));
                        }
                    });
    
                    return groupList;
                });
    
                self.doSearch = function (form, qMode) {
                    getData();
                };
            }
    
            //event handlers
            function SetEvents() {
                $selectState.on('change', function () {
                    var selectedVal = $(this).val();
                    Settings.QueryModes.State.currVal = selectedVal;
                    
                    viewModel.doSearch(null, Settings.QueryModes.State);
                });
            }
    
            //set variables
            function SetVars() {
                $queriedShelters = $module.find('.pet-adoption-locations');
                $primarySearcher = $module.find('.primary-search .filters');
                $selectState = $primarySearcher.find('.category').find('select');
            }
    
            // start
            function init() {
                if (helper.exists($module)) {
    
                    // ko databind
                    viewModel = new ViewModel();
                    ko.applyBindings(viewModel, $module.get(0));
    
                    //set module vars and events
                    SetVars();
                    SetEvents();
                }
            }
    
            return {
                init: init()
            }
        })();
    };
    },{"helper":44,"jquery":63,"knockout":64,"underscore":66}],29:[function(require,module,exports){
    /* requires */
    var helper = require('../utils/helper.js');
    
    exports.init = function ($) {
    
        var $captureCalloutLinks = $('.generic-callout.capture .pet-types a');
        var $closeLinks = $('.generic-callout.capture .slide .icon > i');
        var $slideMessage = $('.generic-callout.capture .slide .border-wrapper .content > p');
    
        function PetTypeCapture() {
    
            $captureCalloutLinks.on('click', function () {
                var $link = $(this);
                var petType = $link[0].id;
                var $currSlide = $link.closest('.slide');
                //$slideMessage = $currSlide.find('.message');
    
                if (helper.exists($currSlide)) {
                    var $nextSlide = $currSlide.next();
                    if (helper.exists($nextSlide)) {
    
                        // set hide/show classes for current and next slides
                        $currSlide.removeClass('active');
                        $nextSlide.addClass('active');
    
                        //append pet type to message
                        if (petType.indexOf('s') == -1) {
                            $slideMessage.append(petType + 's.');
                        } else {
                            $slideMessage.append(petType + '.');
                        }
                        
                    }
                }
    
                $.ajax({
                    url: '/api/Forms/PetTypeCaptureApi/SubmitPetTypeCapture',
                    dataType: 'json',
                    type: 'POST',
                    data: JSON.stringify(petType),
                    contentType: 'application/json; charset=utf-8',
                    cache: false,
                    success: function (data) {
                        console.log("pet type captured:" + petType);
                    },
                    error: function (jqXHR, status, err) {
                        console.log(jqXHR.status + "," + jqXHR.responseText + "," + status + "," + err);
                    }
                });
                return false;
            });
    
            $closeLinks.on('click', function () {
                var $link = $(this);
                var $currSlide = $link.closest('.slide');
    
                if (helper.exists($currSlide)) {
                    $currSlide.removeClass('active');
                    var $thisCallout = $currSlide.closest('.generic-callout');
                    $thisCallout.fadeOut().next('.generic-callout.hidden').removeClass('hidden')
                        .closest('.pet-type-capture').addClass('capture-complete');
                }
    
                return false;
            });
        }
    
        PetTypeCapture();
    };
    },{"../utils/helper.js":44}],30:[function(require,module,exports){
    (function (global){
    var helper = require("../utils/helper");
    
    exports.init = function($) {
        
        // $els
        var $recaptchaEls = $('.vca-recaptcha');
    
        // response callback (after user/robot finishes widget)
        var callbackRecaptcha = function (response) {
            var v = window.grecaptcha.getResponse();
        };
    
        // settings
        var settings = {
            sitekey: '6Lc1mRITAAAAAJNsrUAvubVCBmo_0SeWR8g8tzQT',
            callback: callbackRecaptcha
        };
    
        // onload callback
        global.onloadRecaptcha = function () {
    
            // initialize each recaptcha
            if (helper.exists($recaptchaEls) && typeof window.grecaptcha !== 'undefined') {
    
                $recaptchaEls.each(function () {
                    var $thisRecaptchaEl = $(this);
    
                    // store widget id for getting certain widget response and reset
                    var widgetId = window.grecaptcha.render($thisRecaptchaEl.get(0), {
                        'sitekey': settings.sitekey,
                        'callback': settings.callback
                    });
    
                    $thisRecaptchaEl.data('widgetId', widgetId);
                });
            }
        };
    };
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    },{"../utils/helper":44}],31:[function(require,module,exports){
    var ko = require("knockout");
    var _ = require("underscore");
    var helper = require("helper");
    
    exports.init = function ($) {
    
        var Register = (function () {
    
            var $module, viewModel;
    
    
            // ko viewmodel
            var ViewModel = function() {
                var self = this;
    
                self.facebookClick = function(location, data){
                    if (window.dataLayer) {
                        window.dataLayer.push({ 
                            'event': 'sign-up-submit', 
                            'auth-method': 'facebook' 
                        });
                    }
                    setTimeout(function(){
                        document.getElementById('login-facebook-form').submit();
                    },500);
                };
    
                self.googleClick = function(location, data){
                    if (window.dataLayer) {
                        window.dataLayer.push({ 
                            'event': 'sign-up-submit',
                            'auth-method': 'google'
                        });
                    }
                    setTimeout(function(){
                        document.getElementById('login-google-form').submit();
                    },500);
                };
    
                self.standardRegister = function(){
                    var qs = window.location.search;
                    if (!(qs && qs.indexOf('provider') > -1)) {
                        window.dataLayer.push({ 
                            'event': 'sign-up-submit',
                            'auth-method': 'email'
                        });
                    }
                    setTimeout(function(){
                        document.getElementById('al-register-form').submit();
                    },500);
                };
            };
    
            function setVars() {
    
                // elements
                $module = $('.register');
    
                if ($module.length > 0) {
                    return true;
                }
            };
    
            function init() {
                try {
                    var isReady = setVars();
                    if (isReady) {
    
                        // ko databind
                        viewModel = new ViewModel();
                        ko.applyBindings(viewModel, $module.get(0));
                        
                    }
                } catch (ex) {
                    console.log("Register Component error: " + ex);
                   $module.find('.technical-error').addClass('active');
                }
            };
    
            return {
                init: init()
            }
        })();
    };
    },{"helper":44,"knockout":64,"underscore":66}],32:[function(require,module,exports){
    
    exports.init = function ($) {
    
        var $module;
        var closerClass = '.filters i[role="button"]';
        var categoryDropdownClass = ".filters select";
        var categoryItemsLinkClass = '.category-item a[role="button"]';
    
        function runDotDot($tags) {
            if ($tags && $tags.length) {
                $tags.dotdotdot({
                    height: 100
                });
            }
        }
    
        function setEvents() {
    
            // click category
            $module.find(categoryItemsLinkClass).on('click', function () {
                var $this = $(this);
    
                // get clicked index and all-services wrapper
                var currIndex = $this.closest('.category-item').index();
                var $currModule = $this.closest('.service-category-listing');
                var $calloutListWrapper = $currModule.find('.callout-list-wrapper');
    
                // fade out boxes and fade in filters + services by index
                $this.closest('.facet-categories').fadeOut();
                var $currFilters = $calloutListWrapper.find('.filters');
                var $selectedServices = $($calloutListWrapper.find('.services-content').get(currIndex));
    
                $.when($currFilters.add($selectedServices).fadeIn()).done(function() {
                    runDotDot($selectedServices.find('.generic-callout p'));
                });
    
                // set dropdown selected option
                $currModule.find(categoryDropdownClass).children().eq(currIndex).prop('selected', true);
    
                return false;
            });
    
            // category dropdown change
            $module.find(categoryDropdownClass).on('change', function (el) {
                var $this = $(this);
    
                var selectedIndex = $this.find('option:selected').index();
                var $allServices = $this.closest('.callout-list-wrapper').find('.services-content');
                var $selectedServices = $($allServices.get(selectedIndex));
    
                $allServices.fadeOut();
                $selectedServices.fadeIn(function() {
                    runDotDot($(this).find('.generic-callout p'));
                });
            });
    
            // close filters event
            $module.find(closerClass).on('click', function () {
                var $this = $(this);
    
                // hide filters + service content, show categories
                var $calloutListWrapper = $this.closest('.callout-list-wrapper');
                var $hideGroup = $calloutListWrapper.find('.filters').add($calloutListWrapper.find('.services-content'));
    
                $hideGroup.fadeOut();
                $calloutListWrapper.prev().fadeIn();
    
                return false;
            });
        }
    
        function setVars() {
            $module = $('.service-category-listing');
        }
    
        function init() {
            setVars();
            if ($module.length) {
                setEvents();
            }
        }
        //We dont' want to init this anymore. Sad.
       // init();
    }
    },{}],33:[function(require,module,exports){
    var helper = require("helper");
    var GoogleMapsLoader = require("google-maps");
    
    exports.init = function ($) {
    
        var SingleHospital = (function () {
    
            var $map;
            var map2, bounds, infowindow, InfoBox;
            var google_map_styles = [
                {
                    "featureType": "landscape.man_made",
                    "elementType": "geometry",
                    "stylers": [
                        {
                            "color": "#f7f1df"
                        }
                    ]
                },
                {
                    "featureType": "landscape.natural",
                    "elementType": "geometry",
                    "stylers": [
                        {
                            "color": "#d0e3b4"
                        }
                    ]
                },
                {
                    "featureType": "landscape.natural.terrain",
                    "elementType": "geometry",
                    "stylers": [
                        {
                            "visibility": "off"
                        }
                    ]
                },
                {
                    "featureType": "poi",
                    "elementType": "labels",
                    "stylers": [
                        {
                            "visibility": "off"
                        }
                    ]
                },
                {
                    "featureType": "poi.business",
                    "elementType": "all",
                    "stylers": [
                        {
                            "visibility": "off"
                        }
                    ]
                },
                {
                    "featureType": "poi.medical",
                    "elementType": "geometry",
                    "stylers": [
                        {
                            "color": "#fbd3da"
                        }
                    ]
                },
                {
                    "featureType": "poi.park",
                    "elementType": "geometry",
                    "stylers": [
                        {
                            "color": "#bde6ab"
                        }
                    ]
                },
                {
                    "featureType": "road",
                    "elementType": "geometry.stroke",
                    "stylers": [
                        {
                            "visibility": "off"
                        }
                    ]
                },
                {
                    "featureType": "road",
                    "elementType": "labels",
                    "stylers": [
                        {
                            "visibility": "on"
                        }
                    ]
                },
                {
                    "featureType": "road.highway",
                    "elementType": "geometry.fill",
                    "stylers": [
                        {
                            "color": "#ffe15f"
                        }
                    ]
                },
                {
                    "featureType": "road.highway",
                    "elementType": "geometry.stroke",
                    "stylers": [
                        {
                            "color": "#efd151"
                        }
                    ]
                },
                {
                    "featureType": "road.arterial",
                    "elementType": "geometry.fill",
                    "stylers": [
                        {
                            "color": "#ffffff"
                        }
                    ]
                },
                {
                    "featureType": "road.local",
                    "elementType": "geometry.fill",
                    "stylers": [
                        {
                            "color": "black"
                        }
                    ]
                },
                {
                    "featureType": "transit.station.airport",
                    "elementType": "geometry.fill",
                    "stylers": [
                        {
                            "color": "#cfb2db"
                        }
                    ]
                },
                {
                    "featureType": "water",
                    "elementType": "geometry",
                    "stylers": [
                        {
                            "color": "#a2daf2"
                        }
                    ]
                }
            ];
    
            function setUpMarker() {
                bounds = new google.maps.LatLngBounds();
    
                // make a marker
                var marker = new google.maps.Marker({
                    position: { lat: parseFloat($map.data("lat")), lng: parseFloat($map.data("long")) },
                    map: map2,
                    animation: google.maps.Animation.DROP
                });
    
                // extend the bounds of the initial map to include new marker
                bounds.extend(marker.position);
                map2.setCenter(bounds.getCenter());
                map2.setZoom(16);
                map2.setOptions({ styles: google_map_styles });
    
                var boxText = document.createElement("div");
                boxText.setAttribute('aria-hidden', 'true');
                boxText.style.cssText = "border-radius: 10px; border: 15px solid white; margin-top: 8px; background: white;width:178px;";
                boxText.innerHTML = '<img border="0" width="150" height="150" align="center" src="' + $map.data("img") + '" alt=""><img style="position: absolute; bottom: 51px; left: 72px;" border="0" align="center" src="../../Includes/_images/map-carrot.png">';
    
                var myOptions = {
                    content: boxText,
                    disableAutoPan: false,
                    maxWidth: 0,
                    pixelOffset: new google.maps.Size(-91, -205),
                    zIndex: null,
                    boxStyle: {
                        opacity: 1,
                        width: "200px",
                        height:"250px"
                    },
                    closeBoxMargin: "10px 2px 2px 2px",
                    closeBoxURL: "//www.google.com/intl/en_us/mapfiles/close.gif",
                    infoBoxClearance: new google.maps.Size(1, 1),
                    isHidden: false,
                    pane: "floatPane",
                    enableEventPropagation: false,
                };
    
                infowindow = new InfoBox(myOptions);
    
                if ($(window).width() > 750) {
                    setTimeout(function () {
                        infowindow.open(map2, marker);
                    }, 100);
                }
            }
    
            function initialize() {
    
                $map = $(".google-maps-location");
                if ($map.length) {
    
                    GoogleMapsLoader.KEY = window.HospitalInfoMapSettings.GMapsAPIKey;
                    GoogleMapsLoader.load(function (google) {
                        if (typeof google !== 'undefined') {
    
                            InfoBox = require("google-maps-infobox");
    
                            bounds = new google.maps.LatLngBounds();
                            map2 = new google.maps.Map(document.getElementById('map2'), {
                                zoom: 4
                            });
    
                            setUpMarker();
                        }
                    });
                }
            }
    
            return {
                init: initialize
            };
    
        })();
    
        SingleHospital.init();
    };
    },{"google-maps":59,"google-maps-infobox":58,"helper":44}],34:[function(require,module,exports){
    var queryStr = require('../utils/queryStr.js');
    
    exports.init = function ($) {
    
        var GlobalSettings = {
            VCAContextSiteName: window.VCA.ContextSiteName,
            VCAContextVirtualFolder: window.VCA.ContextVirtualFolder
        };
    
        var SiteSearch = (function () {
    
            function loadSearchResults() {
    
                var sentParams = {
                    PageNumber: $('#searchPage').val(),
                    SearchTerm: $('#searchInput').val(),
                    VCAContextVirtualFolder: GlobalSettings.VCAContextVirtualFolder,
                    VCAContextSiteName:  GlobalSettings.VCAContextSiteName
                };
    
                $.ajax({
                    type: 'GET',
                    url: '/mvc/Search/SiteSearchApi/GetSearchResults',
                    data: sentParams,
                    dataType: 'html',
                    error: function (error) {
                        console.log(error);
                    },
                    success: function (data) {
                        $("#searchResultsPlaceholder").empty().append(data).show();
                    }
                });
            }
    
            function setDefaultValues() {
                var term = queryStr.getUrlVars()["term"];
                if (typeof term != 'undefined')
                    $('#searchInput').val(decodeURI(term).replace(/\+/g, ' '));
            }
    
            function bindEvents() {
    
                $(document).on("click", "a.paging", function (event) {
                    event.preventDefault();
                    var page = $(this).data('page');
                    $('#searchPage').val(page);
                    loadSearchResults();
                });
            }
    
            function initialize() {
    
                if ($("#searchResultsPlaceholder").length) {
                    setDefaultValues();
                    bindEvents();
                    loadSearchResults();
                }
            }
    
            return {
                init: initialize
            };
    
        })();
        SiteSearch.init();
    };
    },{"../utils/queryStr.js":48}],35:[function(require,module,exports){
    /* requires */
    var bxslider = require('bxslider');
    var helper = require('../utils/helper.js');
    
    exports.init = function($) {
    
        var petHealthClass = ".callout-list.pet-health .row";
    
        function initPetHealthSliders() {
            $(window).load(function () {
    
                $(petHealthClass).each(function () {
                    var $this = $(this);
    
                    if ($(window).width() <= helper.maxMobileBreakpoint) {
                        $this.closest(".tab-pane").show();
                        var slider = $this.bxSlider({
                            pager: false,
                            nextText: "",
                            prevText: ""
                        });
                        $this.closest(".tab-pane").removeAttr("style");
    
                        $(window).resize(function () {
                            if ($(window).width() > helper.maxMobileBreakpoint) {
                                slider.destroySlider();
                            }
                        });
                    }
                });
    
                $(".image-text-50-50 .text-slider").bxSlider({
                    pager: true,
                    nextText: "",
                    prevText: "",
                    mode: "fade",
                    speed: 1000,
                    keyboardEnabled: true,
    
                    onSliderLoad: function (currentIndex) {
                        var slideLength = $('.bx-pager-item').length;
                        for (var i = 0; i < slideLength; ++i) {
                            $('.bx-pager-item > a').eq(i).attr('aria-label', 'slideshow page ' + (i + 1))
                        }
                    }
                });
            });
        }
    
        function initTextSliderVideo() {
            var $video = $("#homeSliderVideo");
    
            if (helper.exists($video)) {
                $video[0].addEventListener('click', function () {
                    $video[0].play();
                    $video.parent().addClass("playing");
                }, false);
    
                $video.parent().find("img").on("click", function () {
                    $video.trigger("click");
                });
            }
        }
    
        // init
        initPetHealthSliders();
        initTextSliderVideo();
    };
    },{"../utils/helper.js":44,"bxslider":52}],36:[function(require,module,exports){
    var $ = require('jquery');
    
    module.exports = function () {
    
        function resize() {
            var bigbrother = -1;
    
            $('.person-listing .list .person').each(function () {
                var current = $(this).height();//$('.person-listing .list .person').height();
                bigbrother = bigbrother > current ? bigbrother : current;
            });
    
            var h = bigbrother + "px";
            $('.person-listing .list .person').css("min-height", h);
    
        }
    
        $(document).ready(function () {
            resize();
        });
    }();
    },{"jquery":63}],37:[function(require,module,exports){
    /* Typeahead for pet health library */
    
    var typeahead = require("typeaheadjs");
    
    exports.init = function($) {
        
    
        var substringMatcher = function(strs) {
          return function findMatches(q, cb) {
            var matches, substringRegex;
    
            // an array that will be populated with substring matches
            matches = [];
    
            // regex used to determine if a string contains the substring `q`
            substrRegex = new RegExp(q, 'i');
    
            // iterate through the pool of strings and for any string that
            // contains the substring `q`, add it to the `matches` array
            $.each(strs, function(i, str) {
              if (substrRegex.test(str)) {
                matches.push(str);
              }
            });
    
            cb(matches);
          };
        };
        
        var facetItems = new Bloodhound({
            datumTokenizer: function (datum) {
                return Bloodhound.tokenizers.whitespace(datum.name);
            },
            queryTokenizer: Bloodhound.tokenizers.whitespace,
            remote: {
                url: '/Includes/json/typeahead-pethealth.json',
                replace: function(url, query) {
                    return url + "?q=" + query;
                },
                filter: function(facetItems) {
                    
                    return $.map(facetItems, function(data) {
                        return {
                            id: data.id,
                            name: data.name
                        }
                    });
                }
            }
        });
        
        function startTypeahead() {
            
            $('input.typeahead').typeahead(null, {
                //minLength: 1,
                hint: true,
                name: 'facetItems',
                displayKey: 'name',
                highlight: true,
                limit: 20,
                source: facetItems.ttAdapter()
            });
        };
        
        startTypeahead();
    };
    },{"typeaheadjs":56}],38:[function(require,module,exports){
    require('jquery-ui');
    
    /**
     * DATEPICKER ADA - DEQUEUE
     * @description jQuery UI DatePicker adjustments for accessibility. This module runs automatically when required.
     */
    module.exports = function () {
    
        /**
         * Starting function to call
         * @description Sets up trigger click event on datepickers and attaches handlers
         */
        function dayTripper() {
            $('.ui-datepicker-trigger').on('click', function () {
                var $input = $(this).prev();
    
                setTimeout(function () {
    
                    var $openFocusElement = $('.ui-datepicker-today a')[0] || $('.ui-state-active')[0] || $('.ui-datepicker-next')[0];
    
                    // Hide the entire page (except the date picker)
                    // from screen readers to prevent document navigation
                    // (by headings, etc.) while the popup is open
                    $("main").attr({
                        'dp-container': '',
                        'aria-hidden': 'true'
                    });
    
                    // Hide the "today" button because it doesn't do what 
                    // you think it supposed to do
                    $(".ui-datepicker-current").hide();
    
                    $openFocusElement.focus();
                    datePickHandler($input);
    
                }, 100);
            });
        }
    
        function datePickHandler($input) {
            var activeDate;
            var container = document.getElementById('ui-datepicker-div');
            //var input = document.getElementById('datepicker');
    
            if (!container) { //}) || !input) {
                return;
            }
    
            // set grid aria attributes
            var $gridTable = $(container).find('table').first();
            var $gridTitle = $(container).find('.ui-datepicker-title');
            setGridAria($gridTable, $gridTitle);
    
            container.setAttribute('role', 'application');
            container.setAttribute('aria-label', 'Calendar view date-picker');
    
            // the top controls:
            var prev = $('.ui-datepicker-prev', container)[0],
                next = $('.ui-datepicker-next', container)[0];
    
    
            // next/prev buttons
            next.href = 'javascript:void(0)';           // fix for pages with base URL set in head
            prev.href = 'javascript:void(0)';
    
            next.setAttribute('role', 'button');
            next.removeAttribute('title');
            prev.setAttribute('role', 'button');
            prev.removeAttribute('title');
    
            appendOffscreenMonthText(next);
            appendOffscreenMonthText(prev);
    
            // delegation won't work here for whatever reason, so we are
            // forced to attach individual click listeners to the prev /
            // next month buttons each time they are added to the DOM
            $(next).on('click', handleNextClicks);
            $(prev).on('click', handlePrevClicks);
    
            monthDayYearText();
    
            $(container).on('keydown', function calendarKeyboardListener(keyVent) {
                var which = keyVent.which;
                var target = keyVent.target;
                var dateCurrent = getCurrentDate(container);
    
                if (!dateCurrent) {
                    dateCurrent = $('a.ui-state-default')[0];
                    setHighlightState(dateCurrent, container);
                }
    
                if (27 === which) {
                    keyVent.stopPropagation();
                    return closeCalendar($input);
                } else if (which === 9 && keyVent.shiftKey) { // SHIFT + TAB
                    keyVent.preventDefault();
                    if ($(target).hasClass('ui-datepicker-close')) { // close button
                        $('.ui-datepicker-prev')[0].focus();
                    } else if ($(target).hasClass('ui-state-default')) { // a date link
                        $('.ui-datepicker-close')[0].focus();
                    } else if ($(target).hasClass('ui-datepicker-prev')) { // the prev link
                        $('.ui-datepicker-next')[0].focus();
                    } else if ($(target).hasClass('ui-datepicker-next')) { // the next link
                        activeDate = $('.ui-state-highlight') ||
                                    $('.ui-state-active')[0];
                        if (activeDate) {
                            activeDate.focus();
                        }
                    }
                } else if (which === 9) { // TAB
                    keyVent.preventDefault();
                    if ($(target).hasClass('ui-datepicker-close')) { // close button
    
                        activeDate = $('.ui-state-highlight') || $('.availDate > a')[0];
                        if (activeDate) {
                            activeDate.focus();
                        }
                    } else if ($(target).hasClass('ui-state-default')) {
                        $('.ui-datepicker-next')[0].focus();
                    } else if ($(target).hasClass('ui-datepicker-next')) {
                        $('.ui-datepicker-prev')[0].focus();
                    } else if ($(target).hasClass('ui-datepicker-prev')) {
                        $('.ui-datepicker-close')[0].focus();
                    }
                } else if (which === 37) { // LEFT arrow key
                    // if we're on a date link...
                    if (!$(target).hasClass('ui-datepicker-close') && $(target).hasClass('ui-state-default')) {
                        keyVent.preventDefault();
                        previousDay(target);
                    }
                } else if (which === 39) { // RIGHT arrow key
                    // if we're on a date link...
                    if (!$(target).hasClass('ui-datepicker-close') && $(target).hasClass('ui-state-default')) {
                        keyVent.preventDefault();
                        nextDay(target);
                    }
                } else if (which === 38) { // UP arrow key
                    if (!$(target).hasClass('ui-datepicker-close') && $(target).hasClass('ui-state-default')) {
                        keyVent.preventDefault();
                        upHandler(target, container, prev);
                    }
                } else if (which === 40) { // DOWN arrow key
                    if (!$(target).hasClass('ui-datepicker-close') && $(target).hasClass('ui-state-default')) {
                        keyVent.preventDefault();
                        downHandler(target, container, next);
                    }
                } else if (which === 13) { // ENTER
                    if ($(target).hasClass('ui-state-default')) {
                        setTimeout(function () {
                            closeCalendar($input);
                        }, 100);
                    } else if ($(target).hasClass('ui-datepicker-prev')) {
                        handlePrevClicks();
                    } else if ($(target).hasClass('ui-datepicker-next')) {
                        handleNextClicks();
                    }
                } else if (32 === which) {
                    if ($(target).hasClass('ui-datepicker-prev') || $(target).hasClass('ui-datepicker-next')) {
                        target.click();
                    }
                } else if (33 === which) { // PAGE UP
                    moveOneMonth(target, 'prev');
                } else if (34 === which) { // PAGE DOWN
                    moveOneMonth(target, 'next');
                } else if (36 === which) { // HOME
                    var firstOfMonth = $(target).closest('tbody').find('.ui-state-default')[0];
                    if (firstOfMonth) {
                        firstOfMonth.focus();
                        setHighlightState(firstOfMonth, $('#ui-datepicker-div')[0]);
                    }
                } else if (35 === which) { // END
                    var $daysOfMonth = $(target).closest('tbody').find('.ui-state-default');
                    var lastDay = $daysOfMonth[$daysOfMonth.length - 1];
                    if (lastDay) {
                        lastDay.focus();
                        setHighlightState(lastDay, $('#ui-datepicker-div')[0]);
                    }
                }
                $(".ui-datepicker-current").hide();
            });
    
        }
    
        function closeCalendar($input) {
            var container = $('#ui-datepicker-div');
            $(container).off('keydown');
    
            $input.datepicker('hide');
            $input.focus();
        }
    
        /**
         * Utilities
         */
        function isOdd(num) {
            return num % 2;
        }
    
        function setGridAria($grid, $gridHeading) {
    
            $grid.attr({
                'role': 'grid',
                'aria-label': 'use the arrow keys to navigate the calendar, and press enter to select a day'
            });
    
            $gridHeading.attr({
                'aria-label': 'Currently viewing month:',
                'role': 'heading',
                'aria-live': 'assertive',
                'aria-atomic': 'true'
            });
        }
    
        function moveOneMonth(currentDate, dir) {
            var button = (dir === 'next')
                        ? $('.ui-datepicker-next')[0]
                        : $('.ui-datepicker-prev')[0];
    
            if (!button) {
                return;
            }
    
            var ENABLED_SELECTOR = '#ui-datepicker-div tbody td:not(.ui-state-disabled)';
            var $currentCells = $(ENABLED_SELECTOR);
            var currentIdx = $.inArray(currentDate.parentNode, $currentCells);
    
            button.click();
            setTimeout(function () {
                updateHeaderElements();
    
                var $newCells = $(ENABLED_SELECTOR);
                var newTd = $newCells[currentIdx];
                var newAnchor = newTd && $(newTd).find('a')[0];
    
                while (!newAnchor) {
                    currentIdx--;
                    newTd = $newCells[currentIdx];
                    newAnchor = newTd && $(newTd).find('a')[0];
                }
    
                setHighlightState(newAnchor, $('#ui-datepicker-div')[0]);
                newAnchor.focus();
    
            }, 0);
    
        }
    
        function handleNextClicks() {
            setTimeout(function () {
                updateHeaderElements();
                prepHighlightState();
                $('.ui-datepicker-next').focus();
                $(".ui-datepicker-current").hide();
            }, 0);
        }
    
        function handlePrevClicks() {
            setTimeout(function () {
                updateHeaderElements();
                prepHighlightState();
                $('.ui-datepicker-prev').focus();
                $(".ui-datepicker-current").hide();
            }, 0);
        }
    
        function previousDay(dateLink) {
            var container = document.getElementById('ui-datepicker-div');
            if (!dateLink) {
                return;
            }
            var td = $(dateLink).closest('td');
            if (!td) {
                return;
            }
    
            var prevTd = $(td).prev(),
                prevDateLink = $('a.ui-state-default', prevTd)[0];
    
            if (prevTd && prevDateLink) {
                setHighlightState(prevDateLink, container);
                prevDateLink.focus();
            } else {
                handlePrevious(dateLink);
            }
        }
    
        function handlePrevious(target) {
            var container = document.getElementById('ui-datepicker-div');
            if (!target) {
                return;
            }
            var currentRow = $(target).closest('tr');
            if (!currentRow) {
                return;
            }
            var previousRow = $(currentRow).prev();
    
            if (!previousRow || previousRow.length === 0) {
                // there is not previous row, so we go to previous month...
                previousMonth();
            } else {
                var prevRowDates = $('td a.ui-state-default', previousRow);
                var prevRowDate = prevRowDates[prevRowDates.length - 1];
    
                if (prevRowDate) {
                    setTimeout(function () {
                        setHighlightState(prevRowDate, container);
                        prevRowDate.focus();
                    }, 0);
                }
            }
        }
    
        function previousMonth() {
            var prevLink = $('.ui-datepicker-prev')[0];
            var container = document.getElementById('ui-datepicker-div');
            prevLink.click();
            // focus last day of new month
            setTimeout(function () {
                var trs = $('tr', container),
                    lastRowTdLinks = $('td a.ui-state-default', trs[trs.length - 1]),
                    lastDate = lastRowTdLinks[lastRowTdLinks.length - 1];
    
                // updating the cached header elements
                updateHeaderElements();
    
                setHighlightState(lastDate, container);
                lastDate.focus();
    
            }, 0);
        }
    
        ///////////////// NEXT /////////////////
        /**
         * Handles right arrow key navigation
         * @param  {HTMLElement} dateLink The target of the keyboard event
         */
        function nextDay(dateLink) {
            var container = document.getElementById('ui-datepicker-div');
            if (!dateLink) {
                return;
            }
            var td = $(dateLink).closest('td');
            if (!td) {
                return;
            }
            var nextTd = $(td).next(),
                nextDateLink = $('a.ui-state-default', nextTd)[0];
    
            if (nextTd && nextDateLink) {
                setHighlightState(nextDateLink, container);
                nextDateLink.focus(); // the next day (same row)
            } else {
                handleNext(dateLink);
            }
        }
    
        function handleNext(target) {
            var container = document.getElementById('ui-datepicker-div');
            if (!target) {
                return;
            }
            var currentRow = $(target).closest('tr'),
                nextRow = $(currentRow).next();
    
            if (!nextRow || nextRow.length === 0) {
                nextMonth();
            } else {
                var nextRowFirstDate = $('a.ui-state-default', nextRow)[0];
                if (nextRowFirstDate) {
                    setHighlightState(nextRowFirstDate, container);
                    nextRowFirstDate.focus();
                }
            }
        }
    
        function nextMonth() {
            nextMon = $('.ui-datepicker-next')[0];
            var container = document.getElementById('ui-datepicker-div');
            nextMon.click();
            // focus the first day of the new month
            setTimeout(function () {
                // updating the cached header elements
                updateHeaderElements();
    
                var firstDate = $('a.ui-state-default', container)[0];
                setHighlightState(firstDate, container);
                firstDate.focus();
            }, 0);
        }
    
        /////////// UP ///////////
        /**
         * Handle the up arrow navigation through dates
         * @param  {HTMLElement} target   The target of the keyboard event (day)
         * @param  {HTMLElement} cont     The calendar container
         * @param  {HTMLElement} prevLink Link to navigate to previous month
         */
        function upHandler(target, cont, prevLink) {
            prevLink = $('.ui-datepicker-prev')[0];
            var rowContext = $(target).closest('tr');
            if (!rowContext) {
                return;
            }
            var rowTds = $('td', rowContext),
                rowLinks = $('a.ui-state-default', rowContext),
                targetIndex = $.inArray(target, rowLinks),
                prevRow = $(rowContext).prev(),
                prevRowTds = $('td', prevRow),
                parallel = prevRowTds[targetIndex],
                linkCheck = $('a.ui-state-default', parallel)[0];
    
            if (prevRow && parallel && linkCheck) {
                // there is a previous row, a td at the same index
                // of the target AND theres a link in that td
                setHighlightState(linkCheck, cont);
                linkCheck.focus();
            } else {
                // we're either on the first row of a month, or we're on the
                // second and there is not a date link directly above the target
                prevLink.click();
                setTimeout(function () {
                    // updating the cached header elements
                    updateHeaderElements();
                    var newRows = $('tr', cont),
                        lastRow = newRows[newRows.length - 1],
                        lastRowTds = $('td', lastRow),
                        tdParallelIndex = $.inArray(target.parentNode, rowTds),
                        newParallel = lastRowTds[tdParallelIndex],
                        newCheck = $('a.ui-state-default', newParallel)[0];
    
                    if (lastRow && newParallel && newCheck) {
                        setHighlightState(newCheck, cont);
                        newCheck.focus();
                    } else {
                        // theres no date link on the last week (row) of the new month
                        // meaning its an empty cell, so we'll try the 2nd to last week
                        var secondLastRow = newRows[newRows.length - 2],
                            secondTds = $('td', secondLastRow),
                            targetTd = secondTds[tdParallelIndex],
                            linkCheck = $('a.ui-state-default', targetTd)[0];
    
                        if (linkCheck) {
                            setHighlightState(linkCheck, cont);
                            linkCheck.focus();
                        }
    
                    }
                }, 0);
            }
        }
    
        //////////////// DOWN ////////////////
        /**
         * Handles down arrow navigation through dates in calendar
         * @param  {HTMLElement} target   The target of the keyboard event (day)
         * @param  {HTMLElement} cont     The calendar container
         * @param  {HTMLElement} nextLink Link to navigate to next month
         */
        function downHandler(target, cont, nextLink) {
            nextLink = $('.ui-datepicker-next')[0];
            var targetRow = $(target).closest('tr');
            if (!targetRow) {
                return;
            }
            var targetCells = $('td', targetRow),
                cellIndex = $.inArray(target.parentNode, targetCells), // the td (parent of target) index
                nextRow = $(targetRow).next(),
                nextRowCells = $('td', nextRow),
                nextWeekTd = nextRowCells[cellIndex],
                nextWeekCheck = $('a.ui-state-default', nextWeekTd)[0];
    
            if (nextRow && nextWeekTd && nextWeekCheck) {
                // theres a next row, a TD at the same index of `target`,
                // and theres an anchor within that td
                setHighlightState(nextWeekCheck, cont);
                nextWeekCheck.focus();
            } else {
                nextLink.click();
    
                setTimeout(function () {
                    // updating the cached header elements
                    //updateHeaderElements();
    
                    var nextMonthTrs = $('tbody tr', cont),
                        firstTds = $('td', nextMonthTrs[0]),
                        firstParallel = firstTds[cellIndex],
                        firstCheck = $('a.ui-state-default', firstParallel)[0];
    
                    if (firstParallel && firstCheck) {
                        setHighlightState(firstCheck, cont);
                        firstCheck.focus();
                    } else {
                        // lets try the second row b/c we didnt find a
                        // date link in the first row at the target's index
                        var secondRow = nextMonthTrs[1],
                            secondTds = $('td', secondRow),
                            secondRowTd = secondTds[cellIndex],
                            secondCheck = $('a.ui-state-default', secondRowTd)[0];
    
                        if (secondRow && secondCheck) {
                            setHighlightState(secondCheck, cont);
                            secondCheck.focus();
                        }
                    }
                }, 0);
            }
        }
    
        // add an aria-label to the date link indicating the currently focused date
        // (formatted identically to the required format: mm/dd/yyyy)
        function monthDayYearText() {
            var cleanUps = $('.amaze-date');
    
            $(cleanUps).each(function (clean) {
                // each(cleanUps, function (clean) {
                clean.parentNode.removeChild(clean);
            });
    
            var datePickDiv = document.getElementById('ui-datepicker-div');
            // in case we find no datepick div
            if (!datePickDiv) {
                return;
            }
    
            var dates = $('a.ui-state-default', datePickDiv);
    
            $(dates).each(function (index, date) {
                var currentRow = $(date).closest('tr'),
                    currentTds = $('td', currentRow),
                    currentIndex = $.inArray(date.parentNode, currentTds),
                    headThs = $('thead tr th', datePickDiv),
                    dayIndex = headThs[currentIndex],
                    daySpan = $('span', dayIndex)[0],
                    monthName = $('.ui-datepicker-month', datePickDiv)[0].innerHTML,
                    year = $('.ui-datepicker-year', datePickDiv)[0].innerHTML,
                    number = date.innerHTML;
    
                if (!daySpan || !monthName || !number || !year) {
                    return;
                }
    
                // AT Reads: {month} {date} {year} {day}
                // "December 18 2014 Thursday"
                var dateText = monthName + ' ' + date.innerHTML + ' ' + year + ' ' + daySpan.title;
                // AT Reads: {date(number)} {name of day} {name of month} {year(number)}
                // var dateText = date.innerHTML + ' ' + daySpan.title + ' ' + monthName + ' ' + year;
                // add an aria-label to the date link reading out the currently focused date
                date.setAttribute('aria-label', dateText);
            });
        }
    
    
    
        // update the cached header elements because we're in a new month or year
        function updateHeaderElements() {
            var context = document.getElementById('ui-datepicker-div');
            if (!context) {
                return;
            }
    
            // set grid aria attributes, again
            var $dpContainer = $(context);
            setGridAria($dpContainer.find('table').first(), $dpContainer.find('.ui-datepicker-title'));
    
            prev = $('.ui-datepicker-prev', context)[0];
            next = $('.ui-datepicker-next', context)[0];
    
            //make them click/focus - able
            next.href = 'javascript:void(0)';
            prev.href = 'javascript:void(0)';
    
            next.setAttribute('role', 'button');
            prev.setAttribute('role', 'button');
            appendOffscreenMonthText(next);
            appendOffscreenMonthText(prev);
    
            $(next).on('click', handleNextClicks);
            $(prev).on('click', handlePrevClicks);
    
            // add month day year text
            monthDayYearText();
        }
    
        function prepHighlightState() {
            var cage = document.getElementById('ui-datepicker-div');
            var highlight = $('.ui-state-highlight', cage)[0] || $('.availDate > a', cage)[0];
            if (highlight && cage) {
                setHighlightState(highlight, cage);
            }
        }
    
        // Set the highlighted class to date elements, when focus is recieved
        function setHighlightState(newHighlight, container) {
            var prevHighlight = getCurrentDate(container);
            // remove the highlight state from previously
            // highlighted date and add it to our newly active date
            $(prevHighlight).removeClass('ui-state-highlight');
            $(newHighlight).addClass('ui-state-highlight');
        }
    
    
        // grabs the current date based on the hightlight class
        function getCurrentDate(container) {
            var currentDate = $('.ui-state-highlight', container)[0];
            return currentDate;
        }
    
        /**
         * Appends logical next/prev month text to the buttons
         * - ex: Next Month, January 2015
         *       Previous Month, November 2014
         */
        function appendOffscreenMonthText(button) {
            var isNext = $(button).hasClass('ui-datepicker-next');
            var months = [
              'january', 'february',
              'march', 'april',
              'may', 'june', 'july',
              'august', 'september',
              'october',
              'november', 'december'
            ];
    
            var currentMonth = $('.ui-datepicker-title .ui-datepicker-month').text().toLowerCase();
            var monthIndex = $.inArray(currentMonth.toLowerCase(), months);
            var currentYear = $('.ui-datepicker-title .ui-datepicker-year').text().toLowerCase();
            var adjacentIndex = (isNext) ? monthIndex + 1 : monthIndex - 1;
    
            if (isNext && currentMonth === 'december') {
                currentYear = parseInt(currentYear, 10) + 1;
                adjacentIndex = 0;
            } else if (!isNext && currentMonth === 'january') {
                currentYear = parseInt(currentYear, 10) - 1;
                adjacentIndex = months.length - 1;
            }
    
            var buttonText = (isNext)
                ? 'Next Month, ' + firstToCap(months[adjacentIndex]) + ' ' + currentYear
                : 'Previous Month, ' + firstToCap(months[adjacentIndex]) + ' ' + currentYear;
    
            $(button).find('.ui-icon').html(buttonText);
    
        }
    
        // Returns the string with the first letter capitalized
        function firstToCap(s) {
            return s.charAt(0).toUpperCase() + s.slice(1);
        }
    
    
        /**
         * START
         */
        $(document).ready(function() {
            dayTripper();
        });
    }();
    },{"jquery-ui":61}],39:[function(require,module,exports){
    var helper = require('../utils/helper.js');
    require('jqueryFormValidator');
    require("formValidatorSecurity");
    //require('jquery-form-validator/form-validator/security.js');
    
    exports.init = function ($) {
    
        var Validator = (function () {
    
            // vars
            var defaultFormClass = 'form',
                clientErrClass = 'err-client',
                elementErrClass = 'error',
                errBorderColor = '#ec331a',
                recaptchaClass = '.vca-recaptcha',
                emailCaptureStart = '.email-capture-start',
                emailCaptureEnd = '.email-capture-end';
    
            //settings
            var globalOptions = {
                errorElementClass: elementErrClass,
                showHelpOnFocus: false,
                validateOnBlur: false,
                validateHiddenInputs: false,
                modules: 'location, security',
                borderColorOnError: errBorderColor,
                //language: {
                //    requiredFields: "This field is required: {0}"
                //},
                onElementValidate: function (valid, $el, $form, errorMess) {
    
                    // email capture
                    if ($form.closest(emailCaptureStart).length) {
                        if (valid) {
                            $el.siblings("input[type=submit]").removeAttr("disabled");
                        }
                        else {
                            $el.siblings("input[type=submit]").attr("disabled", "disabled");
                        }
                    }
                    
                    // append/toggle 'aria-invalid' attribute
                    $el.attr('aria-invalid', !valid);
                },
    
                inlineErrorMessageCallback: function ($input, errorMessage, config) {
                    var inputName = $input.attr('name') || $input.attr('id');
                    var fieldErrorStr = inputName + '_err';
    
                    createErrorPopup($input, errorMessage, fieldErrorStr);
    
                    //return false;
                },
                //onValidate: function ($form) {
                    
                //},
                onError: function ($form) {
    
                    $form.addClass(clientErrClass);
    
                    var firstErrElement = $($form.find('.' + elementErrClass)[0]);
                    if (helper.exists(firstErrElement)) {
                        
                        firstErrElement.focus();
                    }
    
                    return false;
                },
                onSuccess: function ($form) {
                    $form.removeClass(clientErrClass);
    
                    // email capture
                    if ($form.closest(emailCaptureStart).length > 0) {
                        $form.closest(emailCaptureStart).fadeOut(500, function () {
                            $(emailCaptureEnd).fadeIn(500);
                        });
                        return false;
                    }
                    return true;
                }
            };
    
            function createErrorPopup($input, errorMessage, fieldErrorStr) {
    
                // get message container: check input attribute then fallback to parent
                var $msgContainer = helper.exists($input.attr('data-validation-error-msg-container')) ?
                    $($input.attr('data-validation-error-msg-container')) : $input.parent();
    
                if (errorMessage) {
                    // build span.help-block.form-error#id, and append to container
                    var msg = '<span class="help-block form-error" id="' + fieldErrorStr + '">' + errorMessage + '</span>';
    
                    $msgContainer.append(msg);
                    $input.attr('aria-describedBy', fieldErrorStr);
                } else {
                    $('#' + fieldErrorStr).remove();
                }
            }
    
            function decodeHtmlEntity(str) {
                return str.replace(/&#(\d+);/g, function(match, dec) {
                    return String.fromCharCode(dec);
                });
            }
    
            function setCustomValidators() {
                $.formUtils.addValidator({
                    name: 'specialchars',
                    validatorFunction: function (value, $el, config, language, $form) {                    
                        var regex = new RegExp(decodeHtmlEntity(VCA.BookingSettings.AllowedSpecialChars), '');
                        
                        if (!value.match(regex))            
                            return false;
                    },
                    errorMessage: 'You have typed an invalid character',
                    errorMessageKey: 'validFieldValueRequired'
                });
                $.formUtils.addValidator({
                    name: 'phonenumber',
                    validatorFunction: function (value, $el, config, language, $form) {
                        if (value.substring(0, 1) === "1")                                              
                            return false;                    
                            
                        if (!value.match(/^\(?([0-9]{3})\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$/))
                            return false;
                        //if (value.length > 10)
                        //    return false;
                    },
                    errorMessage: 'Invalid phone number. Make sure phone number does not start with 1 and includes area code.',              
                    errorMessageKey: 'validPhoneNumberRequired'
                });
                $.formUtils.addValidator({
                    name: 'vcarecaptcha',
                    validatorFunction: function (value, $el, config, language, $form) {
    
                        if (typeof window.grecaptcha !== 'undefined') {
    
                            var widgetId = $form.find(recaptchaClass).data('widgetId');
                            if (typeof widgetId === "undefined") {
                                return false;
                            }
    
                            var v = window.grecaptcha.getResponse(widgetId);
                            if (v.length !== 0) {
                                return true;
                            }
                            return false;
                        }
                        return false;
                    },
                    errorMessage: 'Recaptcha required',
                    errorMessageKey: 'recaptcharequired'
                });
                $.formUtils.addValidator({
                    name: 'different_input_value',
                    validatorFunction: function (value, $el, config, language, $form) {
    
                        var diffInputId = $el.attr('data-validation-different-input');
                        if (helper.exists(diffInputId)) {
                            var $diffInput = $form.find('#' + diffInputId);
                            if (helper.exists($diffInput)) {
                                return $.trim($el.val()) !== $.trim($diffInput.val());
                            }
                            return false;
                        }
                        return false;
                    },
                    errorMessage: 'Different value required for same input type',
                    errorMessageKey: 'differentInputValueRequired'
                });
            }
    
            // for a given form that doesn't display inline-error messages, adds (replaces previous) current error messages to the error message container
            function displayErrorMessages($form, errorMessages) {
                
                var $errContainer = $form.find('.err-client .current-errors');
                if ($errContainer.length) {
                    var $ul = $('<ul/>', { "aria-live": "assertive" });
                    $.each(errorMessages, function (msg) {
                        $('<li/>').text(msg).appendTo($ul);
                    });
    
                    $errContainer.html($ul);
                }
            }
    
            // start
            function init() {
    
                setCustomValidators();
    
                // foreach: form
                $(defaultFormClass).each(function () {
                    var $currForm = $(this);
    
                    globalOptions.form = $currForm;
    
                    // option: validate hidden inputs
                    if ($currForm.hasClass('validate-hdn-inputs')) {
                        globalOptions.validateHiddenInputs = true;
                    } else {
                        globalOptions.validateHiddenInputs = false;
                    }
    
                    // option: error container or inline messages
                    var hasErrorContainer = $currForm.find('.err-client').length;
                    if (hasErrorContainer) {
                        globalOptions.errorMessagePosition = 'top';
                        globalOptions.submitErrorMessageCallback = function ($form, errorMessages, config) {
    
                            if (errorMessages) {
                                //displayErrorMessages($form, errorMessages);
                                return $form.find('.err-client .current-errors');
                            }
    
                            //return false;
                        };
                    } else {
                        globalOptions.errorMessagePosition = 'inline';
                    }
    
                    // option: validate on blur
                    if ($currForm.hasClass('validate-blur')) {
                        globalOptions.validateOnBlur = true;
                    } else {
                        globalOptions.validateOnBlur = false;
                    }
    
                    // set validator
                    $.validate(globalOptions);
                });
    
                // for email capture, validate on every keypress
                if (helper.exists($(emailCaptureStart))) {
                    $(emailCaptureStart).find("form input[type=text]").on("keydown", function () {
                        $(this).validate();
                    });
                }
            }
    
            return {
                init: init()
            }
        })();
    };
    },{"../utils/helper.js":44,"formValidatorSecurity":54,"jqueryFormValidator":53}],40:[function(require,module,exports){
    (function (global){
    global.jQuery = require('jquery');
    
    (function($) {
        $.fn.FlowupLabels = function( options ){
        
            var defaults = {
                    // Useful if you pre-fill input fields or if localstorage/sessionstorage is used. 
                    feature_onLoadInit: 	true,
                    // Class names used for focus and populated statuses
                    class_focused: 		'focused',
                    class_populated: 	'populated'
                },
                settings = $.extend({}, defaults, options);
      
      
            return this.each(function(){
                var $scope  = $(this);
        
                $scope.on('focus.flowupLabelsEvt', '.fl_input', function() {
                    $(this).closest('.fl_wrap').addClass(settings.class_focused);
                })
                .on('blur.flowupLabelsEvt', '.fl_input', function() {
                    var $this = $(this);
                    
                    if ($this.val().length) {
                        $this.closest('.fl_wrap')
                            .addClass(settings.class_populated)
                            .removeClass(settings.class_focused);
                    } 
                    else {
                        $this.closest('.fl_wrap')
                            .removeClass(settings.class_populated + ' ' + settings.class_focused);
                    }
                })
                .on('transitionend', '.fl_label', function() {
                    $('.fl_label').removeClass('fl_hidden');
                });
            
        
                // On page load, make sure it looks good
                if (settings.feature_onLoadInit) {
                    $scope.find('.fl_input').trigger('blur.flowupLabelsEvt');
                }
            });
        };
    })( jQuery );
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    },{"jquery":63}],41:[function(require,module,exports){
    (function (global){
    global.jQuery = require('jquery');
    
    /*!
     * Cropper v3.1.3
     * https://github.com/fengyuanchen/cropper
     *
     * Copyright (c) 2014-2017 Chen Fengyuan
     * Released under the MIT license
     *
     * Date: 2017-10-21T10:04:29.734Z
     */
    
    (function (global, factory) {
        typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('jquery')) :
        typeof define === 'function' && define.amd ? define(['jquery'], factory) :
        (factory(global.jQuery));
    }(this, (function ($) { 'use strict';
    
    $ = $ && $.hasOwnProperty('default') ? $['default'] : $;
    
    var WINDOW = typeof window !== 'undefined' ? window : {};
    var NAMESPACE = 'cropper';
    
    // Actions
    var ACTION_ALL = 'all';
    var ACTION_CROP = 'crop';
    var ACTION_MOVE = 'move';
    var ACTION_ZOOM = 'zoom';
    var ACTION_EAST = 'e';
    var ACTION_WEST = 'w';
    var ACTION_SOUTH = 's';
    var ACTION_NORTH = 'n';
    var ACTION_NORTH_EAST = 'ne';
    var ACTION_NORTH_WEST = 'nw';
    var ACTION_SOUTH_EAST = 'se';
    var ACTION_SOUTH_WEST = 'sw';
    
    // Classes
    var CLASS_CROP = NAMESPACE + '-crop';
    var CLASS_DISABLED = NAMESPACE + '-disabled';
    var CLASS_HIDDEN = NAMESPACE + '-hidden';
    var CLASS_HIDE = NAMESPACE + '-hide';
    var CLASS_INVISIBLE = NAMESPACE + '-invisible';
    var CLASS_MODAL = NAMESPACE + '-modal';
    var CLASS_MOVE = NAMESPACE + '-move';
    
    // Data keys
    var DATA_ACTION = 'action';
    var DATA_PREVIEW = 'preview';
    
    // Drag modes
    var DRAG_MODE_CROP = 'crop';
    var DRAG_MODE_MOVE = 'move';
    var DRAG_MODE_NONE = 'none';
    
    // Events
    var EVENT_CROP = 'crop';
    var EVENT_CROP_END = 'cropend';
    var EVENT_CROP_MOVE = 'cropmove';
    var EVENT_CROP_START = 'cropstart';
    var EVENT_DBLCLICK = 'dblclick';
    var EVENT_ERROR = 'error';
    var EVENT_LOAD = 'load';
    var EVENT_POINTER_DOWN = WINDOW.PointerEvent ? 'pointerdown' : 'touchstart mousedown';
    var EVENT_POINTER_MOVE = WINDOW.PointerEvent ? 'pointermove' : 'touchmove mousemove';
    var EVENT_POINTER_UP = WINDOW.PointerEvent ? ' pointerup pointercancel' : 'touchend touchcancel mouseup';
    var EVENT_READY = 'ready';
    var EVENT_RESIZE = 'resize';
    var EVENT_WHEEL = 'wheel mousewheel DOMMouseScroll';
    var EVENT_ZOOM = 'zoom';
    
    // RegExps
    var REGEXP_ACTIONS = /^(e|w|s|n|se|sw|ne|nw|all|crop|move|zoom)$/;
    var REGEXP_DATA_URL = /^data:/;
    var REGEXP_DATA_URL_JPEG = /^data:image\/jpeg;base64,/;
    var REGEXP_TAG_NAME = /^(img|canvas)$/i;
    
    var DEFAULTS = {
      // Define the view mode of the cropper
      viewMode: 0, // 0, 1, 2, 3
    
      // Define the dragging mode of the cropper
      dragMode: DRAG_MODE_CROP, // 'crop', 'move' or 'none'
    
      // Define the aspect ratio of the crop box
      aspectRatio: NaN,
    
      // An object with the previous cropping result data
      data: null,
    
      // A selector for adding extra containers to preview
      preview: '',
    
      // Re-render the cropper when resize the window
      responsive: true,
    
      // Restore the cropped area after resize the window
      restore: true,
    
      // Check if the current image is a cross-origin image
      checkCrossOrigin: true,
    
      // Check the current image's Exif Orientation information
      checkOrientation: true,
    
      // Show the black modal
      modal: true,
    
      // Show the dashed lines for guiding
      guides: true,
    
      // Show the center indicator for guiding
      center: true,
    
      // Show the white modal to highlight the crop box
      highlight: true,
    
      // Show the grid background
      background: true,
    
      // Enable to crop the image automatically when initialize
      autoCrop: true,
    
      // Define the percentage of automatic cropping area when initializes
      autoCropArea: 0.8,
    
      // Enable to move the image
      movable: true,
    
      // Enable to rotate the image
      rotatable: true,
    
      // Enable to scale the image
      scalable: true,
    
      // Enable to zoom the image
      zoomable: true,
    
      // Enable to zoom the image by dragging touch
      zoomOnTouch: true,
    
      // Enable to zoom the image by wheeling mouse
      zoomOnWheel: true,
    
      // Define zoom ratio when zoom the image by wheeling mouse
      wheelZoomRatio: 0.1,
    
      // Enable to move the crop box
      cropBoxMovable: true,
    
      // Enable to resize the crop box
      cropBoxResizable: true,
    
      // Toggle drag mode between "crop" and "move" when click twice on the cropper
      toggleDragModeOnDblclick: true,
    
      // Size limitation
      minCanvasWidth: 0,
      minCanvasHeight: 0,
      minCropBoxWidth: 0,
      minCropBoxHeight: 0,
      minContainerWidth: 200,
      minContainerHeight: 100,
    
      // Shortcuts of events
      ready: null,
      cropstart: null,
      cropmove: null,
      cropend: null,
      crop: null,
      zoom: null
    };
    
    var TEMPLATE = '<div class="cropper-container">' + '<div class="cropper-wrap-box">' + '<div class="cropper-canvas"></div>' + '</div>' + '<div class="cropper-drag-box"></div>' + '<div class="cropper-crop-box">' + '<span class="cropper-view-box"></span>' + '<span class="cropper-dashed dashed-h"></span>' + '<span class="cropper-dashed dashed-v"></span>' + '<span class="cropper-center"></span>' + '<span class="cropper-face"></span>' + '<span class="cropper-line line-e" data-action="e"></span>' + '<span class="cropper-line line-n" data-action="n"></span>' + '<span class="cropper-line line-w" data-action="w"></span>' + '<span class="cropper-line line-s" data-action="s"></span>' + '<span class="cropper-point point-e" data-action="e"></span>' + '<span class="cropper-point point-n" data-action="n"></span>' + '<span class="cropper-point point-w" data-action="w"></span>' + '<span class="cropper-point point-s" data-action="s"></span>' + '<span class="cropper-point point-ne" data-action="ne"></span>' + '<span class="cropper-point point-nw" data-action="nw"></span>' + '<span class="cropper-point point-sw" data-action="sw"></span>' + '<span class="cropper-point point-se" data-action="se"></span>' + '</div>' + '</div>';
    
    function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
    
    /**
     * Check if the given value is a string.
     * @param {*} value - The value to check.
     * @returns {boolean} Returns `true` if the given value is a string, else `false`.
     */
    function isString(value) {
      return typeof value === 'string';
    }
    
    /**
     * Check if the given value is not a number.
     */
    var isNaN = Number.isNaN || WINDOW.isNaN;
    
    /**
     * Check if the given value is a number.
     * @param {*} value - The value to check.
     * @returns {boolean} Returns `true` if the given value is a number, else `false`.
     */
    function isNumber(value) {
      return typeof value === 'number' && !isNaN(value);
    }
    
    /**
     * Check if the given value is undefined.
     * @param {*} value - The value to check.
     * @returns {boolean} Returns `true` if the given value is undefined, else `false`.
     */
    function isUndefined(value) {
      return typeof value === 'undefined';
    }
    
    /**
     * Takes a function and returns a new one that will always have a particular context.
     * Custom proxy to avoid jQuery's guid.
     * @param {Function} fn - The target function.
     * @param {Object} context - The new context for the function.
     * @returns {Function} The new function.
     */
    function proxy(fn, context) {
      for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
    
      return function () {
        for (var _len2 = arguments.length, args2 = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args2[_key2] = arguments[_key2];
        }
    
        return fn.apply(context, args.concat(args2));
      };
    }
    
    /**
     * Get the own enumerable properties of a given object.
     * @param {Object} obj - The target object.
     * @returns {Array} All the own enumerable properties of the given object.
     */
    var objectKeys = Object.keys || function objectKeys(obj) {
      var keys = [];
    
      $.each(obj, function (key) {
        keys.push(key);
      });
    
      return keys;
    };
    
    var REGEXP_DECIMALS = /\.\d*(?:0|9){12}\d*$/i;
    
    /**
     * Normalize decimal number.
     * Check out {@link http://0.30000000000000004.com/ }
     * @param {number} value - The value to normalize.
     * @param {number} [times=100000000000] - The times for normalizing.
     * @returns {number} Returns the normalized number.
     */
    function normalizeDecimalNumber(value) {
      var times = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100000000000;
    
      return REGEXP_DECIMALS.test(value) ? Math.round(value * times) / times : value;
    }
    
    var location = WINDOW.location;
    
    var REGEXP_ORIGINS = /^(https?:)\/\/([^:/?#]+):?(\d*)/i;
    
    /**
     * Check if the given URL is a cross origin URL.
     * @param {string} url - The target URL.
     * @returns {boolean} Returns `true` if the given URL is a cross origin URL, else `false`.
     */
    function isCrossOriginURL(url) {
      var parts = url.match(REGEXP_ORIGINS);
    
      return parts && (parts[1] !== location.protocol || parts[2] !== location.hostname || parts[3] !== location.port);
    }
    
    /**
     * Add timestamp to the given URL.
     * @param {string} url - The target URL.
     * @returns {string} The result URL.
     */
    function addTimestamp(url) {
      var timestamp = 'timestamp=' + new Date().getTime();
    
      return url + (url.indexOf('?') === -1 ? '?' : '&') + timestamp;
    }
    
    /**
     * Get transform values base on the given object.
     * @param {Object} obj - The target object.
     * @returns {string} A string contains transform values.
     */
    function getTransformValues(_ref) {
      var rotate = _ref.rotate,
          scaleX = _ref.scaleX,
          scaleY = _ref.scaleY,
          translateX = _ref.translateX,
          translateY = _ref.translateY;
    
      var values = [];
    
      if (isNumber(translateX) && translateX !== 0) {
        values.push('translateX(' + translateX + 'px)');
      }
    
      if (isNumber(translateY) && translateY !== 0) {
        values.push('translateY(' + translateY + 'px)');
      }
    
      // Rotate should come first before scale to match orientation transform
      if (isNumber(rotate) && rotate !== 0) {
        values.push('rotate(' + rotate + 'deg)');
      }
    
      if (isNumber(scaleX) && scaleX !== 1) {
        values.push('scaleX(' + scaleX + ')');
      }
    
      if (isNumber(scaleY) && scaleY !== 1) {
        values.push('scaleY(' + scaleY + ')');
      }
    
      return values.length ? values.join(' ') : 'none';
    }
    
    var navigator = WINDOW.navigator;
    
    var IS_SAFARI_OR_UIWEBVIEW = navigator && /(Macintosh|iPhone|iPod|iPad).*AppleWebKit/i.test(navigator.userAgent);
    
    /**
     * Get an image's natural sizes.
     * @param {string} image - The target image.
     * @param {Function} callback - The callback function.
     */
    function getImageNaturalSizes(image, callback) {
      // Modern browsers (except Safari)
      if (image.naturalWidth && !IS_SAFARI_OR_UIWEBVIEW) {
        callback(image.naturalWidth, image.naturalHeight);
        return;
      }
    
      var newImage = document.createElement('img');
    
      newImage.onload = function () {
        callback(newImage.width, newImage.height);
      };
    
      newImage.src = image.src;
    }
    
    /**
     * Get the max ratio of a group of pointers.
     * @param {string} pointers - The target pointers.
     * @returns {number} The result ratio.
     */
    function getMaxZoomRatio(pointers) {
      var pointers2 = $.extend({}, pointers);
      var ratios = [];
    
      $.each(pointers, function (pointerId, pointer) {
        delete pointers2[pointerId];
    
        $.each(pointers2, function (pointerId2, pointer2) {
          var x1 = Math.abs(pointer.startX - pointer2.startX);
          var y1 = Math.abs(pointer.startY - pointer2.startY);
          var x2 = Math.abs(pointer.endX - pointer2.endX);
          var y2 = Math.abs(pointer.endY - pointer2.endY);
          var z1 = Math.sqrt(x1 * x1 + y1 * y1);
          var z2 = Math.sqrt(x2 * x2 + y2 * y2);
          var ratio = (z2 - z1) / z1;
    
          ratios.push(ratio);
        });
      });
    
      ratios.sort(function (a, b) {
        return Math.abs(a) < Math.abs(b);
      });
    
      return ratios[0];
    }
    
    /**
     * Get a pointer from an event object.
     * @param {Object} event - The target event object.
     * @param {boolean} endOnly - Indicates if only returns the end point coordinate or not.
     * @returns {Object} The result pointer contains start and/or end point coordinates.
     */
    function getPointer(_ref2, endOnly) {
      var pageX = _ref2.pageX,
          pageY = _ref2.pageY;
    
      var end = {
        endX: pageX,
        endY: pageY
      };
    
      if (endOnly) {
        return end;
      }
    
      return $.extend({
        startX: pageX,
        startY: pageY
      }, end);
    }
    
    /**
     * Get the center point coordinate of a group of pointers.
     * @param {Object} pointers - The target pointers.
     * @returns {Object} The center point coordinate.
     */
    function getPointersCenter(pointers) {
      var pageX = 0;
      var pageY = 0;
      var count = 0;
    
      $.each(pointers, function (pointerId, _ref3) {
        var startX = _ref3.startX,
            startY = _ref3.startY;
    
        pageX += startX;
        pageY += startY;
        count += 1;
      });
    
      pageX /= count;
      pageY /= count;
    
      return {
        pageX: pageX,
        pageY: pageY
      };
    }
    
    /**
     * Check if the given value is a finite number.
     */
    var isFinite = Number.isFinite || WINDOW.isFinite;
    
    /**
     * Get the max sizes in a rectangle under the given aspect ratio.
     * @param {Object} data - The original sizes.
     * @returns {Object} The result sizes.
     */
    function getContainSizes(_ref4) {
      var aspectRatio = _ref4.aspectRatio,
          height = _ref4.height,
          width = _ref4.width;
    
      var isValidNumber = function isValidNumber(value) {
        return isFinite(value) && value > 0;
      };
    
      if (isValidNumber(width) && isValidNumber(height)) {
        if (height * aspectRatio > width) {
          height = width / aspectRatio;
        } else {
          width = height * aspectRatio;
        }
      } else if (isValidNumber(width)) {
        height = width / aspectRatio;
      } else if (isValidNumber(height)) {
        width = height * aspectRatio;
      }
    
      return {
        width: width,
        height: height
      };
    }
    
    /**
     * Get the new sizes of a rectangle after rotated.
     * @param {Object} data - The original sizes.
     * @returns {Object} The result sizes.
     */
    function getRotatedSizes(_ref5) {
      var width = _ref5.width,
          height = _ref5.height,
          degree = _ref5.degree;
    
      degree = Math.abs(degree);
    
      if (degree % 180 === 90) {
        return {
          width: height,
          height: width
        };
      }
    
      var arc = degree % 90 * Math.PI / 180;
      var sinArc = Math.sin(arc);
      var cosArc = Math.cos(arc);
    
      return {
        width: width * cosArc + height * sinArc,
        height: width * sinArc + height * cosArc
      };
    }
    
    /**
     * Get a canvas which drew the given image.
     * @param {HTMLImageElement} image - The image for drawing.
     * @param {Object} imageData - The image data.
     * @param {Object} canvasData - The canvas data.
     * @param {Object} options - The options.
     * @returns {HTMLCanvasElement} The result canvas.
     */
    function getSourceCanvas(image, _ref6, _ref7, _ref8) {
      var imageNaturalWidth = _ref6.naturalWidth,
          imageNaturalHeight = _ref6.naturalHeight,
          _ref6$rotate = _ref6.rotate,
          rotate = _ref6$rotate === undefined ? 0 : _ref6$rotate,
          _ref6$scaleX = _ref6.scaleX,
          scaleX = _ref6$scaleX === undefined ? 1 : _ref6$scaleX,
          _ref6$scaleY = _ref6.scaleY,
          scaleY = _ref6$scaleY === undefined ? 1 : _ref6$scaleY;
      var aspectRatio = _ref7.aspectRatio,
          naturalWidth = _ref7.naturalWidth,
          naturalHeight = _ref7.naturalHeight;
      var _ref8$fillColor = _ref8.fillColor,
          fillColor = _ref8$fillColor === undefined ? 'transparent' : _ref8$fillColor,
          _ref8$imageSmoothingE = _ref8.imageSmoothingEnabled,
          imageSmoothingEnabled = _ref8$imageSmoothingE === undefined ? true : _ref8$imageSmoothingE,
          _ref8$imageSmoothingQ = _ref8.imageSmoothingQuality,
          imageSmoothingQuality = _ref8$imageSmoothingQ === undefined ? 'low' : _ref8$imageSmoothingQ,
          _ref8$maxWidth = _ref8.maxWidth,
          maxWidth = _ref8$maxWidth === undefined ? Infinity : _ref8$maxWidth,
          _ref8$maxHeight = _ref8.maxHeight,
          maxHeight = _ref8$maxHeight === undefined ? Infinity : _ref8$maxHeight,
          _ref8$minWidth = _ref8.minWidth,
          minWidth = _ref8$minWidth === undefined ? 0 : _ref8$minWidth,
          _ref8$minHeight = _ref8.minHeight,
          minHeight = _ref8$minHeight === undefined ? 0 : _ref8$minHeight;
    
      var maxSizes = getContainSizes({
        aspectRatio: aspectRatio,
        width: maxWidth,
        height: maxHeight
      });
      var minSizes = getContainSizes({
        aspectRatio: aspectRatio,
        width: minWidth,
        height: minHeight
      });
      var width = Math.min(maxSizes.width, Math.max(minSizes.width, naturalWidth));
      var height = Math.min(maxSizes.height, Math.max(minSizes.height, naturalHeight));
      var canvas = document.createElement('canvas');
      var context = canvas.getContext('2d');
      var params = [-imageNaturalWidth / 2, -imageNaturalHeight / 2, imageNaturalWidth, imageNaturalHeight];
    
      canvas.width = normalizeDecimalNumber(width);
      canvas.height = normalizeDecimalNumber(height);
      context.fillStyle = fillColor;
      context.fillRect(0, 0, width, height);
      context.save();
      context.translate(width / 2, height / 2);
      context.rotate(rotate * Math.PI / 180);
      context.scale(scaleX, scaleY);
      context.imageSmoothingEnabled = !!imageSmoothingEnabled;
      context.imageSmoothingQuality = imageSmoothingQuality;
      context.drawImage.apply(context, [image].concat(_toConsumableArray($.map(params, function (param) {
        return Math.floor(normalizeDecimalNumber(param));
      }))));
      context.restore();
      return canvas;
    }
    
    var fromCharCode = String.fromCharCode;
    
    /**
     * Get string from char code in data view.
     * @param {DataView} dataView - The data view for read.
     * @param {number} start - The start index.
     * @param {number} length - The read length.
     * @returns {string} The read result.
     */
    
    function getStringFromCharCode(dataView, start, length) {
      var str = '';
      var i = void 0;
    
      length += start;
    
      for (i = start; i < length; i += 1) {
        str += fromCharCode(dataView.getUint8(i));
      }
    
      return str;
    }
    
    var REGEXP_DATA_URL_HEAD = /^data:.*,/;
    
    /**
     * Transform Data URL to array buffer.
     * @param {string} dataURL - The Data URL to transform.
     * @returns {ArrayBuffer} The result array buffer.
     */
    function dataURLToArrayBuffer(dataURL) {
      var base64 = dataURL.replace(REGEXP_DATA_URL_HEAD, '');
      var binary = atob(base64);
      var arrayBuffer = new ArrayBuffer(binary.length);
      var uint8 = new Uint8Array(arrayBuffer);
    
      $.each(uint8, function (i) {
        uint8[i] = binary.charCodeAt(i);
      });
    
      return arrayBuffer;
    }
    
    /**
     * Transform array buffer to Data URL.
     * @param {ArrayBuffer} arrayBuffer - The array buffer to transform.
     * @param {string} mimeType - The mime type of the Data URL.
     * @returns {string} The result Data URL.
     */
    function arrayBufferToDataURL(arrayBuffer, mimeType) {
      var uint8 = new Uint8Array(arrayBuffer);
      var data = '';
    
      // TypedArray.prototype.forEach is not supported in some browsers.
      $.each(uint8, function (i, value) {
        data += fromCharCode(value);
      });
    
      return 'data:' + mimeType + ';base64,' + btoa(data);
    }
    
    /**
     * Get orientation value from given array buffer.
     * @param {ArrayBuffer} arrayBuffer - The array buffer to read.
     * @returns {number} The read orientation value.
     */
    function getOrientation(arrayBuffer) {
      var dataView = new DataView(arrayBuffer);
      var orientation = void 0;
      var littleEndian = void 0;
      var app1Start = void 0;
      var ifdStart = void 0;
    
      // Only handle JPEG image (start by 0xFFD8)
      if (dataView.getUint8(0) === 0xFF && dataView.getUint8(1) === 0xD8) {
        var length = dataView.byteLength;
        var offset = 2;
    
        while (offset < length) {
          if (dataView.getUint8(offset) === 0xFF && dataView.getUint8(offset + 1) === 0xE1) {
            app1Start = offset;
            break;
          }
    
          offset += 1;
        }
      }
    
      if (app1Start) {
        var exifIDCode = app1Start + 4;
        var tiffOffset = app1Start + 10;
    
        if (getStringFromCharCode(dataView, exifIDCode, 4) === 'Exif') {
          var endianness = dataView.getUint16(tiffOffset);
    
          littleEndian = endianness === 0x4949;
    
          if (littleEndian || endianness === 0x4D4D /* bigEndian */) {
              if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002A) {
                var firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);
    
                if (firstIFDOffset >= 0x00000008) {
                  ifdStart = tiffOffset + firstIFDOffset;
                }
              }
            }
        }
      }
    
      if (ifdStart) {
        var _length = dataView.getUint16(ifdStart, littleEndian);
        var _offset = void 0;
        var i = void 0;
    
        for (i = 0; i < _length; i += 1) {
          _offset = ifdStart + i * 12 + 2;
    
          if (dataView.getUint16(_offset, littleEndian) === 0x0112 /* Orientation */) {
              // 8 is the offset of the current tag's value
              _offset += 8;
    
              // Get the original orientation value
              orientation = dataView.getUint16(_offset, littleEndian);
    
              // Override the orientation with its default value
              dataView.setUint16(_offset, 1, littleEndian);
              break;
            }
        }
      }
    
      return orientation;
    }
    
    /**
     * Parse Exif Orientation value.
     * @param {number} orientation - The orientation to parse.
     * @returns {Object} The parsed result.
     */
    function parseOrientation(orientation) {
      var rotate = 0;
      var scaleX = 1;
      var scaleY = 1;
    
      switch (orientation) {
        // Flip horizontal
        case 2:
          scaleX = -1;
          break;
    
        // Rotate left 180
        case 3:
          rotate = -180;
          break;
    
        // Flip vertical
        case 4:
          scaleY = -1;
          break;
    
        // Flip vertical and rotate right 90
        case 5:
          rotate = 90;
          scaleY = -1;
          break;
    
        // Rotate right 90
        case 6:
          rotate = 90;
          break;
    
        // Flip horizontal and rotate right 90
        case 7:
          rotate = 90;
          scaleX = -1;
          break;
    
        // Rotate left 90
        case 8:
          rotate = -90;
          break;
    
        default:
      }
    
      return {
        rotate: rotate,
        scaleX: scaleX,
        scaleY: scaleY
      };
    }
    
    var render = {
      render: function render() {
        this.initContainer();
        this.initCanvas();
        this.initCropBox();
        this.renderCanvas();
    
        if (this.cropped) {
          this.renderCropBox();
        }
      },
      initContainer: function initContainer() {
        var $element = this.$element,
            options = this.options,
            $container = this.$container,
            $cropper = this.$cropper;
    
    
        $cropper.addClass(CLASS_HIDDEN);
        $element.removeClass(CLASS_HIDDEN);
    
        $cropper.css(this.container = {
          width: Math.max($container.width(), Number(options.minContainerWidth) || 200),
          height: Math.max($container.height(), Number(options.minContainerHeight) || 100)
        });
    
        $element.addClass(CLASS_HIDDEN);
        $cropper.removeClass(CLASS_HIDDEN);
      },
    
    
      // Canvas (image wrapper)
      initCanvas: function initCanvas() {
        var container = this.container,
            image = this.image;
        var viewMode = this.options.viewMode;
    
        var rotated = Math.abs(image.rotate) % 180 === 90;
        var naturalWidth = rotated ? image.naturalHeight : image.naturalWidth;
        var naturalHeight = rotated ? image.naturalWidth : image.naturalHeight;
        var aspectRatio = naturalWidth / naturalHeight;
        var canvasWidth = container.width;
        var canvasHeight = container.height;
    
        if (container.height * aspectRatio > container.width) {
          if (viewMode === 3) {
            canvasWidth = container.height * aspectRatio;
          } else {
            canvasHeight = container.width / aspectRatio;
          }
        } else if (viewMode === 3) {
          canvasHeight = container.width / aspectRatio;
        } else {
          canvasWidth = container.height * aspectRatio;
        }
    
        var canvas = {
          aspectRatio: aspectRatio,
          naturalWidth: naturalWidth,
          naturalHeight: naturalHeight,
          width: canvasWidth,
          height: canvasHeight
        };
    
        canvas.left = (container.width - canvasWidth) / 2;
        canvas.top = (container.height - canvasHeight) / 2;
        canvas.oldLeft = canvas.left;
        canvas.oldTop = canvas.top;
    
        this.canvas = canvas;
        this.limited = viewMode === 1 || viewMode === 2;
        this.limitCanvas(true, true);
        this.initialImage = $.extend({}, image);
        this.initialCanvas = $.extend({}, canvas);
      },
      limitCanvas: function limitCanvas(isSizeLimited, isPositionLimited) {
        var options = this.options,
            container = this.container,
            canvas = this.canvas,
            cropBox = this.cropBox;
        var viewMode = options.viewMode;
        var aspectRatio = canvas.aspectRatio;
    
        var cropped = this.cropped && cropBox;
    
        if (isSizeLimited) {
          var minCanvasWidth = Number(options.minCanvasWidth) || 0;
          var minCanvasHeight = Number(options.minCanvasHeight) || 0;
    
          if (viewMode > 0) {
            if (viewMode > 1) {
              minCanvasWidth = Math.max(minCanvasWidth, container.width);
              minCanvasHeight = Math.max(minCanvasHeight, container.height);
    
              if (viewMode === 3) {
                if (minCanvasHeight * aspectRatio > minCanvasWidth) {
                  minCanvasWidth = minCanvasHeight * aspectRatio;
                } else {
                  minCanvasHeight = minCanvasWidth / aspectRatio;
                }
              }
            } else if (minCanvasWidth) {
              minCanvasWidth = Math.max(minCanvasWidth, cropped ? cropBox.width : 0);
            } else if (minCanvasHeight) {
              minCanvasHeight = Math.max(minCanvasHeight, cropped ? cropBox.height : 0);
            } else if (cropped) {
              minCanvasWidth = cropBox.width;
              minCanvasHeight = cropBox.height;
    
              if (minCanvasHeight * aspectRatio > minCanvasWidth) {
                minCanvasWidth = minCanvasHeight * aspectRatio;
              } else {
                minCanvasHeight = minCanvasWidth / aspectRatio;
              }
            }
          }
    
          var _getContainSizes = getContainSizes({
            aspectRatio: aspectRatio,
            width: minCanvasWidth,
            height: minCanvasHeight
          });
    
          minCanvasWidth = _getContainSizes.width;
          minCanvasHeight = _getContainSizes.height;
    
    
          canvas.minWidth = minCanvasWidth;
          canvas.minHeight = minCanvasHeight;
          canvas.maxWidth = Infinity;
          canvas.maxHeight = Infinity;
        }
    
        if (isPositionLimited) {
          if (viewMode > 0) {
            var newCanvasLeft = container.width - canvas.width;
            var newCanvasTop = container.height - canvas.height;
    
            canvas.minLeft = Math.min(0, newCanvasLeft);
            canvas.minTop = Math.min(0, newCanvasTop);
            canvas.maxLeft = Math.max(0, newCanvasLeft);
            canvas.maxTop = Math.max(0, newCanvasTop);
    
            if (cropped && this.limited) {
              canvas.minLeft = Math.min(cropBox.left, cropBox.left + cropBox.width - canvas.width);
              canvas.minTop = Math.min(cropBox.top, cropBox.top + cropBox.height - canvas.height);
              canvas.maxLeft = cropBox.left;
              canvas.maxTop = cropBox.top;
    
              if (viewMode === 2) {
                if (canvas.width >= container.width) {
                  canvas.minLeft = Math.min(0, newCanvasLeft);
                  canvas.maxLeft = Math.max(0, newCanvasLeft);
                }
    
                if (canvas.height >= container.height) {
                  canvas.minTop = Math.min(0, newCanvasTop);
                  canvas.maxTop = Math.max(0, newCanvasTop);
                }
              }
            }
          } else {
            canvas.minLeft = -canvas.width;
            canvas.minTop = -canvas.height;
            canvas.maxLeft = container.width;
            canvas.maxTop = container.height;
          }
        }
      },
      renderCanvas: function renderCanvas(changed, transformed) {
        var canvas = this.canvas,
            image = this.image;
    
    
        if (transformed) {
          var _getRotatedSizes = getRotatedSizes({
            width: image.naturalWidth * Math.abs(image.scaleX || 1),
            height: image.naturalHeight * Math.abs(image.scaleY || 1),
            degree: image.rotate || 0
          }),
              naturalWidth = _getRotatedSizes.width,
              naturalHeight = _getRotatedSizes.height;
    
          var width = canvas.width * (naturalWidth / canvas.naturalWidth);
          var height = canvas.height * (naturalHeight / canvas.naturalHeight);
    
          canvas.left -= (width - canvas.width) / 2;
          canvas.top -= (height - canvas.height) / 2;
          canvas.width = width;
          canvas.height = height;
          canvas.aspectRatio = naturalWidth / naturalHeight;
          canvas.naturalWidth = naturalWidth;
          canvas.naturalHeight = naturalHeight;
          this.limitCanvas(true, false);
        }
    
        if (canvas.width > canvas.maxWidth || canvas.width < canvas.minWidth) {
          canvas.left = canvas.oldLeft;
        }
    
        if (canvas.height > canvas.maxHeight || canvas.height < canvas.minHeight) {
          canvas.top = canvas.oldTop;
        }
    
        canvas.width = Math.min(Math.max(canvas.width, canvas.minWidth), canvas.maxWidth);
        canvas.height = Math.min(Math.max(canvas.height, canvas.minHeight), canvas.maxHeight);
    
        this.limitCanvas(false, true);
    
        canvas.left = Math.min(Math.max(canvas.left, canvas.minLeft), canvas.maxLeft);
        canvas.top = Math.min(Math.max(canvas.top, canvas.minTop), canvas.maxTop);
        canvas.oldLeft = canvas.left;
        canvas.oldTop = canvas.top;
    
        this.$canvas.css({
          width: canvas.width,
          height: canvas.height,
          transform: getTransformValues({
            translateX: canvas.left,
            translateY: canvas.top
          })
        });
    
        this.renderImage(changed);
    
        if (this.cropped && this.limited) {
          this.limitCropBox(true, true);
        }
      },
      renderImage: function renderImage(changed) {
        var canvas = this.canvas,
            image = this.image;
    
        var width = image.naturalWidth * (canvas.width / canvas.naturalWidth);
        var height = image.naturalHeight * (canvas.height / canvas.naturalHeight);
    
        $.extend(image, {
          width: width,
          height: height,
          left: (canvas.width - width) / 2,
          top: (canvas.height - height) / 2
        });
    
        this.$clone.css({
          width: image.width,
          height: image.height,
          transform: getTransformValues($.extend({
            translateX: image.left,
            translateY: image.top
          }, image))
        });
    
        if (changed) {
          this.output();
        }
      },
      initCropBox: function initCropBox() {
        var options = this.options,
            canvas = this.canvas;
        var aspectRatio = options.aspectRatio;
    
        var autoCropArea = Number(options.autoCropArea) || 0.8;
        var cropBox = {
          width: canvas.width,
          height: canvas.height
        };
    
        if (aspectRatio) {
          if (canvas.height * aspectRatio > canvas.width) {
            cropBox.height = cropBox.width / aspectRatio;
          } else {
            cropBox.width = cropBox.height * aspectRatio;
          }
        }
    
        this.cropBox = cropBox;
        this.limitCropBox(true, true);
    
        // Initialize auto crop area
        cropBox.width = Math.min(Math.max(cropBox.width, cropBox.minWidth), cropBox.maxWidth);
        cropBox.height = Math.min(Math.max(cropBox.height, cropBox.minHeight), cropBox.maxHeight);
    
        // The width of auto crop area must large than "minWidth", and the height too. (#164)
        cropBox.width = Math.max(cropBox.minWidth, cropBox.width * autoCropArea);
        cropBox.height = Math.max(cropBox.minHeight, cropBox.height * autoCropArea);
        cropBox.left = canvas.left + (canvas.width - cropBox.width) / 2;
        cropBox.top = canvas.top + (canvas.height - cropBox.height) / 2;
        cropBox.oldLeft = cropBox.left;
        cropBox.oldTop = cropBox.top;
    
        this.initialCropBox = $.extend({}, cropBox);
      },
      limitCropBox: function limitCropBox(isSizeLimited, isPositionLimited) {
        var options = this.options,
            container = this.container,
            canvas = this.canvas,
            cropBox = this.cropBox,
            limited = this.limited;
        var aspectRatio = options.aspectRatio;
    
    
        if (isSizeLimited) {
          var minCropBoxWidth = Number(options.minCropBoxWidth) || 0;
          var minCropBoxHeight = Number(options.minCropBoxHeight) || 0;
          var maxCropBoxWidth = Math.min(container.width, limited ? canvas.width : container.width);
          var maxCropBoxHeight = Math.min(container.height, limited ? canvas.height : container.height);
    
          // The min/maxCropBoxWidth/Height must be less than container's width/Height
          minCropBoxWidth = Math.min(minCropBoxWidth, container.width);
          minCropBoxHeight = Math.min(minCropBoxHeight, container.height);
    
          if (aspectRatio) {
            if (minCropBoxWidth && minCropBoxHeight) {
              if (minCropBoxHeight * aspectRatio > minCropBoxWidth) {
                minCropBoxHeight = minCropBoxWidth / aspectRatio;
              } else {
                minCropBoxWidth = minCropBoxHeight * aspectRatio;
              }
            } else if (minCropBoxWidth) {
              minCropBoxHeight = minCropBoxWidth / aspectRatio;
            } else if (minCropBoxHeight) {
              minCropBoxWidth = minCropBoxHeight * aspectRatio;
            }
    
            if (maxCropBoxHeight * aspectRatio > maxCropBoxWidth) {
              maxCropBoxHeight = maxCropBoxWidth / aspectRatio;
            } else {
              maxCropBoxWidth = maxCropBoxHeight * aspectRatio;
            }
          }
    
          // The minWidth/Height must be less than maxWidth/Height
          cropBox.minWidth = Math.min(minCropBoxWidth, maxCropBoxWidth);
          cropBox.minHeight = Math.min(minCropBoxHeight, maxCropBoxHeight);
          cropBox.maxWidth = maxCropBoxWidth;
          cropBox.maxHeight = maxCropBoxHeight;
        }
    
        if (isPositionLimited) {
          if (limited) {
            cropBox.minLeft = Math.max(0, canvas.left);
            cropBox.minTop = Math.max(0, canvas.top);
            cropBox.maxLeft = Math.min(container.width, canvas.left + canvas.width) - cropBox.width;
            cropBox.maxTop = Math.min(container.height, canvas.top + canvas.height) - cropBox.height;
          } else {
            cropBox.minLeft = 0;
            cropBox.minTop = 0;
            cropBox.maxLeft = container.width - cropBox.width;
            cropBox.maxTop = container.height - cropBox.height;
          }
        }
      },
      renderCropBox: function renderCropBox() {
        var options = this.options,
            container = this.container,
            cropBox = this.cropBox;
    
    
        if (cropBox.width > cropBox.maxWidth || cropBox.width < cropBox.minWidth) {
          cropBox.left = cropBox.oldLeft;
        }
    
        if (cropBox.height > cropBox.maxHeight || cropBox.height < cropBox.minHeight) {
          cropBox.top = cropBox.oldTop;
        }
    
        cropBox.width = Math.min(Math.max(cropBox.width, cropBox.minWidth), cropBox.maxWidth);
        cropBox.height = Math.min(Math.max(cropBox.height, cropBox.minHeight), cropBox.maxHeight);
    
        this.limitCropBox(false, true);
    
        cropBox.left = Math.min(Math.max(cropBox.left, cropBox.minLeft), cropBox.maxLeft);
        cropBox.top = Math.min(Math.max(cropBox.top, cropBox.minTop), cropBox.maxTop);
        cropBox.oldLeft = cropBox.left;
        cropBox.oldTop = cropBox.top;
    
        if (options.movable && options.cropBoxMovable) {
          // Turn to move the canvas when the crop box is equal to the container
          this.$face.data(DATA_ACTION, cropBox.width >= container.width && cropBox.height >= container.height ? ACTION_MOVE : ACTION_ALL);
        }
    
        this.$cropBox.css({
          width: cropBox.width,
          height: cropBox.height,
          transform: getTransformValues({
            translateX: cropBox.left,
            translateY: cropBox.top
          })
        });
    
        if (this.cropped && this.limited) {
          this.limitCanvas(true, true);
        }
    
        if (!this.disabled) {
          this.output();
        }
      },
      output: function output() {
        this.preview();
    
        if (this.completed) {
          this.trigger(EVENT_CROP, this.getData());
        }
      }
    };
    
    var preview = {
      initPreview: function initPreview() {
        var crossOrigin = this.crossOrigin;
    
        var url = crossOrigin ? this.crossOriginUrl : this.url;
        var image = document.createElement('img');
    
        if (crossOrigin) {
          image.crossOrigin = crossOrigin;
        }
    
        image.src = url;
    
        var $clone2 = $(image);
    
        this.$preview = $(this.options.preview);
        this.$clone2 = $clone2;
        this.$viewBox.html($clone2);
        this.$preview.each(function (i, element) {
          var $element = $(element);
          var img = document.createElement('img');
    
          // Save the original size for recover
          $element.data(DATA_PREVIEW, {
            width: $element.width(),
            height: $element.height(),
            html: $element.html()
          });
    
          if (crossOrigin) {
            img.crossOrigin = crossOrigin;
          }
    
          img.src = url;
    
          /**
           * Override img element styles
           * Add `display:block` to avoid margin top issue
           * Add `height:auto` to override `height` attribute on IE8
           * (Occur only when margin-top <= -height)
           */
          img.style.cssText = 'display:block;' + 'width:100%;' + 'height:auto;' + 'min-width:0!important;' + 'min-height:0!important;' + 'max-width:none!important;' + 'max-height:none!important;' + 'image-orientation:0deg!important;"';
    
          $element.html(img);
        });
      },
      resetPreview: function resetPreview() {
        this.$preview.each(function (i, element) {
          var $element = $(element);
          var data = $element.data(DATA_PREVIEW);
    
          $element.css({
            width: data.width,
            height: data.height
          }).html(data.html).removeData(DATA_PREVIEW);
        });
      },
      preview: function preview() {
        var image = this.image,
            canvas = this.canvas,
            cropBox = this.cropBox;
        var cropBoxWidth = cropBox.width,
            cropBoxHeight = cropBox.height;
        var width = image.width,
            height = image.height;
    
        var left = cropBox.left - canvas.left - image.left;
        var top = cropBox.top - canvas.top - image.top;
    
        if (!this.cropped || this.disabled) {
          return;
        }
    
        this.$clone2.css({
          width: width,
          height: height,
          transform: getTransformValues($.extend({
            translateX: -left,
            translateY: -top
          }, image))
        });
    
        this.$preview.each(function (i, element) {
          var $element = $(element);
          var data = $element.data(DATA_PREVIEW);
          var originalWidth = data.width;
          var originalHeight = data.height;
          var newWidth = originalWidth;
          var newHeight = originalHeight;
          var ratio = 1;
    
          if (cropBoxWidth) {
            ratio = originalWidth / cropBoxWidth;
            newHeight = cropBoxHeight * ratio;
          }
    
          if (cropBoxHeight && newHeight > originalHeight) {
            ratio = originalHeight / cropBoxHeight;
            newWidth = cropBoxWidth * ratio;
            newHeight = originalHeight;
          }
    
          $element.css({
            width: newWidth,
            height: newHeight
          }).find('img').css({
            width: width * ratio,
            height: height * ratio,
            transform: getTransformValues($.extend({
              translateX: -left * ratio,
              translateY: -top * ratio
            }, image))
          });
        });
      }
    };
    
    var events = {
      bind: function bind() {
        var $element = this.$element,
            options = this.options,
            $cropper = this.$cropper;
    
    
        if ($.isFunction(options.cropstart)) {
          $element.on(EVENT_CROP_START, options.cropstart);
        }
    
        if ($.isFunction(options.cropmove)) {
          $element.on(EVENT_CROP_MOVE, options.cropmove);
        }
    
        if ($.isFunction(options.cropend)) {
          $element.on(EVENT_CROP_END, options.cropend);
        }
    
        if ($.isFunction(options.crop)) {
          $element.on(EVENT_CROP, options.crop);
        }
    
        if ($.isFunction(options.zoom)) {
          $element.on(EVENT_ZOOM, options.zoom);
        }
    
        $cropper.on(EVENT_POINTER_DOWN, proxy(this.cropStart, this));
    
        if (options.zoomable && options.zoomOnWheel) {
          $cropper.on(EVENT_WHEEL, proxy(this.wheel, this));
        }
    
        if (options.toggleDragModeOnDblclick) {
          $cropper.on(EVENT_DBLCLICK, proxy(this.dblclick, this));
        }
    
        $(document).on(EVENT_POINTER_MOVE, this.onCropMove = proxy(this.cropMove, this)).on(EVENT_POINTER_UP, this.onCropEnd = proxy(this.cropEnd, this));
    
        if (options.responsive) {
          $(window).on(EVENT_RESIZE, this.onResize = proxy(this.resize, this));
        }
      },
      unbind: function unbind() {
        var $element = this.$element,
            options = this.options,
            $cropper = this.$cropper;
    
    
        if ($.isFunction(options.cropstart)) {
          $element.off(EVENT_CROP_START, options.cropstart);
        }
    
        if ($.isFunction(options.cropmove)) {
          $element.off(EVENT_CROP_MOVE, options.cropmove);
        }
    
        if ($.isFunction(options.cropend)) {
          $element.off(EVENT_CROP_END, options.cropend);
        }
    
        if ($.isFunction(options.crop)) {
          $element.off(EVENT_CROP, options.crop);
        }
    
        if ($.isFunction(options.zoom)) {
          $element.off(EVENT_ZOOM, options.zoom);
        }
    
        $cropper.off(EVENT_POINTER_DOWN, this.cropStart);
    
        if (options.zoomable && options.zoomOnWheel) {
          $cropper.off(EVENT_WHEEL, this.wheel);
        }
    
        if (options.toggleDragModeOnDblclick) {
          $cropper.off(EVENT_DBLCLICK, this.dblclick);
        }
    
        $(document).off(EVENT_POINTER_MOVE, this.onCropMove).off(EVENT_POINTER_UP, this.onCropEnd);
    
        if (options.responsive) {
          $(window).off(EVENT_RESIZE, this.onResize);
        }
      }
    };
    
    var handlers = {
      resize: function resize() {
        var options = this.options,
            $container = this.$container,
            container = this.container;
    
        var minContainerWidth = Number(options.minContainerWidth) || 200;
        var minContainerHeight = Number(options.minContainerHeight) || 100;
    
        if (this.disabled || container.width <= minContainerWidth || container.height <= minContainerHeight) {
          return;
        }
    
        var ratio = $container.width() / container.width;
    
        // Resize when width changed or height changed
        if (ratio !== 1 || $container.height() !== container.height) {
          var canvasData = void 0;
          var cropBoxData = void 0;
    
          if (options.restore) {
            canvasData = this.getCanvasData();
            cropBoxData = this.getCropBoxData();
          }
    
          this.render();
    
          if (options.restore) {
            this.setCanvasData($.each(canvasData, function (i, n) {
              canvasData[i] = n * ratio;
            }));
            this.setCropBoxData($.each(cropBoxData, function (i, n) {
              cropBoxData[i] = n * ratio;
            }));
          }
        }
      },
      dblclick: function dblclick() {
        if (this.disabled || this.options.dragMode === DRAG_MODE_NONE) {
          return;
        }
    
        this.setDragMode(this.$dragBox.hasClass(CLASS_CROP) ? DRAG_MODE_MOVE : DRAG_MODE_CROP);
      },
      wheel: function wheel(event) {
        var _this = this;
    
        var e = event.originalEvent || event;
        var ratio = Number(this.options.wheelZoomRatio) || 0.1;
    
        if (this.disabled) {
          return;
        }
    
        event.preventDefault();
    
        // Limit wheel speed to prevent zoom too fast
        if (this.wheeling) {
          return;
        }
    
        this.wheeling = true;
    
        setTimeout(function () {
          _this.wheeling = false;
        }, 50);
    
        var delta = 1;
    
        if (e.deltaY) {
          delta = e.deltaY > 0 ? 1 : -1;
        } else if (e.wheelDelta) {
          delta = -e.wheelDelta / 120;
        } else if (e.detail) {
          delta = e.detail > 0 ? 1 : -1;
        }
    
        this.zoom(-delta * ratio, event);
      },
      cropStart: function cropStart(e) {
        if (this.disabled) {
          return;
        }
    
        var options = this.options,
            pointers = this.pointers;
        var originalEvent = e.originalEvent;
    
        var action = void 0;
    
        if (originalEvent && originalEvent.changedTouches) {
          // Handle touch event
          $.each(originalEvent.changedTouches, function (i, touch) {
            pointers[touch.identifier] = getPointer(touch);
          });
        } else {
          // Handle mouse event and pointer event
          pointers[originalEvent && originalEvent.pointerId || 0] = getPointer(originalEvent || e);
        }
    
        if (objectKeys(pointers).length > 1 && options.zoomable && options.zoomOnTouch) {
          action = ACTION_ZOOM;
        } else {
          action = $(e.target).data(DATA_ACTION);
        }
    
        if (!REGEXP_ACTIONS.test(action)) {
          return;
        }
    
        if (this.trigger(EVENT_CROP_START, {
          originalEvent: originalEvent,
          action: action
        }).isDefaultPrevented()) {
          return;
        }
    
        e.preventDefault();
    
        this.action = action;
        this.cropping = false;
    
        if (action === ACTION_CROP) {
          this.cropping = true;
          this.$dragBox.addClass(CLASS_MODAL);
        }
      },
      cropMove: function cropMove(e) {
        var action = this.action;
    
    
        if (this.disabled || !action) {
          return;
        }
    
        var pointers = this.pointers;
        var originalEvent = e.originalEvent;
    
    
        e.preventDefault();
    
        if (this.trigger(EVENT_CROP_MOVE, {
          originalEvent: originalEvent,
          action: action
        }).isDefaultPrevented()) {
          return;
        }
    
        if (originalEvent && originalEvent.changedTouches) {
          $.each(originalEvent.changedTouches, function (i, touch) {
            $.extend(pointers[touch.identifier], getPointer(touch, true));
          });
        } else {
          $.extend(pointers[originalEvent && originalEvent.pointerId || 0], getPointer(originalEvent || e, true));
        }
    
        this.change(e);
      },
      cropEnd: function cropEnd(e) {
        if (this.disabled) {
          return;
        }
    
        var action = this.action;
        var pointers = this.pointers;
        var originalEvent = e.originalEvent;
    
    
        if (originalEvent && originalEvent.changedTouches) {
          $.each(originalEvent.changedTouches, function (i, touch) {
            delete pointers[touch.identifier];
          });
        } else {
          delete pointers[originalEvent && originalEvent.pointerId || 0];
        }
    
        if (!action) {
          return;
        }
    
        e.preventDefault();
    
        if (!objectKeys(pointers).length) {
          this.action = '';
        }
    
        if (this.cropping) {
          this.cropping = false;
          this.$dragBox.toggleClass(CLASS_MODAL, this.cropped && this.options.modal);
        }
    
        this.trigger(EVENT_CROP_END, {
          originalEvent: originalEvent,
          action: action
        });
      }
    };
    
    var change = {
      change: function change(e) {
        var options = this.options,
            pointers = this.pointers,
            container = this.container,
            canvas = this.canvas,
            cropBox = this.cropBox;
        var action = this.action;
        var aspectRatio = options.aspectRatio;
        var left = cropBox.left,
            top = cropBox.top,
            width = cropBox.width,
            height = cropBox.height;
    
        var right = left + width;
        var bottom = top + height;
        var minLeft = 0;
        var minTop = 0;
        var maxWidth = container.width;
        var maxHeight = container.height;
        var renderable = true;
        var offset = void 0;
    
        // Locking aspect ratio in "free mode" by holding shift key (#259)
        if (!aspectRatio && e.shiftKey) {
          aspectRatio = width && height ? width / height : 1;
        }
    
        if (this.limited) {
          minLeft = cropBox.minLeft;
          minTop = cropBox.minTop;
    
          maxWidth = minLeft + Math.min(container.width, canvas.width, canvas.left + canvas.width);
          maxHeight = minTop + Math.min(container.height, canvas.height, canvas.top + canvas.height);
        }
    
        var pointer = pointers[objectKeys(pointers)[0]];
        var range = {
          x: pointer.endX - pointer.startX,
          y: pointer.endY - pointer.startY
        };
        var check = function check(side) {
          switch (side) {
            case ACTION_EAST:
              if (right + range.x > maxWidth) {
                range.x = maxWidth - right;
              }
    
              break;
    
            case ACTION_WEST:
              if (left + range.x < minLeft) {
                range.x = minLeft - left;
              }
    
              break;
    
            case ACTION_NORTH:
              if (top + range.y < minTop) {
                range.y = minTop - top;
              }
    
              break;
    
            case ACTION_SOUTH:
              if (bottom + range.y > maxHeight) {
                range.y = maxHeight - bottom;
              }
    
              break;
    
            default:
          }
        };
    
        switch (action) {
          // Move crop box
          case ACTION_ALL:
            left += range.x;
            top += range.y;
            break;
    
          // Resize crop box
          case ACTION_EAST:
            if (range.x >= 0 && (right >= maxWidth || aspectRatio && (top <= minTop || bottom >= maxHeight))) {
              renderable = false;
              break;
            }
    
            check(ACTION_EAST);
            width += range.x;
    
            if (aspectRatio) {
              height = width / aspectRatio;
              top -= range.x / aspectRatio / 2;
            }
    
            if (width < 0) {
              action = ACTION_WEST;
              width = 0;
            }
    
            break;
    
          case ACTION_NORTH:
            if (range.y <= 0 && (top <= minTop || aspectRatio && (left <= minLeft || right >= maxWidth))) {
              renderable = false;
              break;
            }
    
            check(ACTION_NORTH);
            height -= range.y;
            top += range.y;
    
            if (aspectRatio) {
              width = height * aspectRatio;
              left += range.y * aspectRatio / 2;
            }
    
            if (height < 0) {
              action = ACTION_SOUTH;
              height = 0;
            }
    
            break;
    
          case ACTION_WEST:
            if (range.x <= 0 && (left <= minLeft || aspectRatio && (top <= minTop || bottom >= maxHeight))) {
              renderable = false;
              break;
            }
    
            check(ACTION_WEST);
            width -= range.x;
            left += range.x;
    
            if (aspectRatio) {
              height = width / aspectRatio;
              top += range.x / aspectRatio / 2;
            }
    
            if (width < 0) {
              action = ACTION_EAST;
              width = 0;
            }
    
            break;
    
          case ACTION_SOUTH:
            if (range.y >= 0 && (bottom >= maxHeight || aspectRatio && (left <= minLeft || right >= maxWidth))) {
              renderable = false;
              break;
            }
    
            check(ACTION_SOUTH);
            height += range.y;
    
            if (aspectRatio) {
              width = height * aspectRatio;
              left -= range.y * aspectRatio / 2;
            }
    
            if (height < 0) {
              action = ACTION_NORTH;
              height = 0;
            }
    
            break;
    
          case ACTION_NORTH_EAST:
            if (aspectRatio) {
              if (range.y <= 0 && (top <= minTop || right >= maxWidth)) {
                renderable = false;
                break;
              }
    
              check(ACTION_NORTH);
              height -= range.y;
              top += range.y;
              width = height * aspectRatio;
            } else {
              check(ACTION_NORTH);
              check(ACTION_EAST);
    
              if (range.x >= 0) {
                if (right < maxWidth) {
                  width += range.x;
                } else if (range.y <= 0 && top <= minTop) {
                  renderable = false;
                }
              } else {
                width += range.x;
              }
    
              if (range.y <= 0) {
                if (top > minTop) {
                  height -= range.y;
                  top += range.y;
                }
              } else {
                height -= range.y;
                top += range.y;
              }
            }
    
            if (width < 0 && height < 0) {
              action = ACTION_SOUTH_WEST;
              height = 0;
              width = 0;
            } else if (width < 0) {
              action = ACTION_NORTH_WEST;
              width = 0;
            } else if (height < 0) {
              action = ACTION_SOUTH_EAST;
              height = 0;
            }
    
            break;
    
          case ACTION_NORTH_WEST:
            if (aspectRatio) {
              if (range.y <= 0 && (top <= minTop || left <= minLeft)) {
                renderable = false;
                break;
              }
    
              check(ACTION_NORTH);
              height -= range.y;
              top += range.y;
              width = height * aspectRatio;
              left += range.y * aspectRatio;
            } else {
              check(ACTION_NORTH);
              check(ACTION_WEST);
    
              if (range.x <= 0) {
                if (left > minLeft) {
                  width -= range.x;
                  left += range.x;
                } else if (range.y <= 0 && top <= minTop) {
                  renderable = false;
                }
              } else {
                width -= range.x;
                left += range.x;
              }
    
              if (range.y <= 0) {
                if (top > minTop) {
                  height -= range.y;
                  top += range.y;
                }
              } else {
                height -= range.y;
                top += range.y;
              }
            }
    
            if (width < 0 && height < 0) {
              action = ACTION_SOUTH_EAST;
              height = 0;
              width = 0;
            } else if (width < 0) {
              action = ACTION_NORTH_EAST;
              width = 0;
            } else if (height < 0) {
              action = ACTION_SOUTH_WEST;
              height = 0;
            }
    
            break;
    
          case ACTION_SOUTH_WEST:
            if (aspectRatio) {
              if (range.x <= 0 && (left <= minLeft || bottom >= maxHeight)) {
                renderable = false;
                break;
              }
    
              check(ACTION_WEST);
              width -= range.x;
              left += range.x;
              height = width / aspectRatio;
            } else {
              check(ACTION_SOUTH);
              check(ACTION_WEST);
    
              if (range.x <= 0) {
                if (left > minLeft) {
                  width -= range.x;
                  left += range.x;
                } else if (range.y >= 0 && bottom >= maxHeight) {
                  renderable = false;
                }
              } else {
                width -= range.x;
                left += range.x;
              }
    
              if (range.y >= 0) {
                if (bottom < maxHeight) {
                  height += range.y;
                }
              } else {
                height += range.y;
              }
            }
    
            if (width < 0 && height < 0) {
              action = ACTION_NORTH_EAST;
              height = 0;
              width = 0;
            } else if (width < 0) {
              action = ACTION_SOUTH_EAST;
              width = 0;
            } else if (height < 0) {
              action = ACTION_NORTH_WEST;
              height = 0;
            }
    
            break;
    
          case ACTION_SOUTH_EAST:
            if (aspectRatio) {
              if (range.x >= 0 && (right >= maxWidth || bottom >= maxHeight)) {
                renderable = false;
                break;
              }
    
              check(ACTION_EAST);
              width += range.x;
              height = width / aspectRatio;
            } else {
              check(ACTION_SOUTH);
              check(ACTION_EAST);
    
              if (range.x >= 0) {
                if (right < maxWidth) {
                  width += range.x;
                } else if (range.y >= 0 && bottom >= maxHeight) {
                  renderable = false;
                }
              } else {
                width += range.x;
              }
    
              if (range.y >= 0) {
                if (bottom < maxHeight) {
                  height += range.y;
                }
              } else {
                height += range.y;
              }
            }
    
            if (width < 0 && height < 0) {
              action = ACTION_NORTH_WEST;
              height = 0;
              width = 0;
            } else if (width < 0) {
              action = ACTION_SOUTH_WEST;
              width = 0;
            } else if (height < 0) {
              action = ACTION_NORTH_EAST;
              height = 0;
            }
    
            break;
    
          // Move canvas
          case ACTION_MOVE:
            this.move(range.x, range.y);
            renderable = false;
            break;
    
          // Zoom canvas
          case ACTION_ZOOM:
            this.zoom(getMaxZoomRatio(pointers), e.originalEvent);
            renderable = false;
            break;
    
          // Create crop box
          case ACTION_CROP:
            if (!range.x || !range.y) {
              renderable = false;
              break;
            }
    
            offset = this.$cropper.offset();
            left = pointer.startX - offset.left;
            top = pointer.startY - offset.top;
            width = cropBox.minWidth;
            height = cropBox.minHeight;
    
            if (range.x > 0) {
              action = range.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST;
            } else if (range.x < 0) {
              left -= width;
              action = range.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST;
            }
    
            if (range.y < 0) {
              top -= height;
            }
    
            // Show the crop box if is hidden
            if (!this.cropped) {
              this.$cropBox.removeClass(CLASS_HIDDEN);
              this.cropped = true;
    
              if (this.limited) {
                this.limitCropBox(true, true);
              }
            }
    
            break;
    
          default:
        }
    
        if (renderable) {
          cropBox.width = width;
          cropBox.height = height;
          cropBox.left = left;
          cropBox.top = top;
          this.action = action;
          this.renderCropBox();
        }
    
        // Override
        $.each(pointers, function (i, p) {
          p.startX = p.endX;
          p.startY = p.endY;
        });
      }
    };
    
    function _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
    
    var methods = {
      // Show the crop box manually
      crop: function crop() {
        if (!this.ready || this.disabled) {
          return;
        }
    
        if (!this.cropped) {
          this.cropped = true;
          this.limitCropBox(true, true);
    
          if (this.options.modal) {
            this.$dragBox.addClass(CLASS_MODAL);
          }
    
          this.$cropBox.removeClass(CLASS_HIDDEN);
        }
    
        this.setCropBoxData(this.initialCropBox);
      },
    
    
      // Reset the image and crop box to their initial states
      reset: function reset() {
        if (!this.ready || this.disabled) {
          return;
        }
    
        this.image = $.extend({}, this.initialImage);
        this.canvas = $.extend({}, this.initialCanvas);
        this.cropBox = $.extend({}, this.initialCropBox);
        this.renderCanvas();
    
        if (this.cropped) {
          this.renderCropBox();
        }
      },
    
    
      // Clear the crop box
      clear: function clear() {
        if (!this.cropped || this.disabled) {
          return;
        }
    
        $.extend(this.cropBox, {
          left: 0,
          top: 0,
          width: 0,
          height: 0
        });
    
        this.cropped = false;
        this.renderCropBox();
        this.limitCanvas(true, true);
    
        // Render canvas after crop box rendered
        this.renderCanvas();
        this.$dragBox.removeClass(CLASS_MODAL);
        this.$cropBox.addClass(CLASS_HIDDEN);
      },
    
    
      /**
       * Replace the image's src and rebuild the cropper
       * @param {string} url - The new URL.
       * @param {boolean} [onlyColorChanged] - Indicate if the new image only changed color.
       */
      replace: function replace(url, onlyColorChanged) {
        if (!this.disabled && url) {
          if (this.isImg) {
            this.$element.attr('src', url);
          }
    
          if (onlyColorChanged) {
            this.url = url;
            this.$clone.attr('src', url);
    
            if (this.ready) {
              this.$preview.find('img').add(this.$clone2).attr('src', url);
            }
          } else {
            if (this.isImg) {
              this.replaced = true;
            }
    
            // Clear previous data
            this.options.data = null;
            this.load(url);
          }
        }
      },
    
    
      // Enable (unfreeze) the cropper
      enable: function enable() {
        if (this.ready) {
          this.disabled = false;
          this.$cropper.removeClass(CLASS_DISABLED);
        }
      },
    
    
      // Disable (freeze) the cropper
      disable: function disable() {
        if (this.ready) {
          this.disabled = true;
          this.$cropper.addClass(CLASS_DISABLED);
        }
      },
    
    
      // Destroy the cropper and remove the instance from the image
      destroy: function destroy() {
        var $element = this.$element;
    
    
        if (this.loaded) {
          if (this.isImg && this.replaced) {
            $element.attr('src', this.originalUrl);
          }
    
          this.unbuild();
          $element.removeClass(CLASS_HIDDEN);
        } else if (this.isImg) {
          $element.off(EVENT_LOAD, this.start);
        } else if (this.$clone) {
          this.$clone.remove();
        }
    
        $element.removeData(NAMESPACE);
      },
    
    
      /**
       * Move the canvas with relative offsets
       * @param {number} offsetX - The relative offset distance on the x-axis.
       * @param {number} offsetY - The relative offset distance on the y-axis.
       */
      move: function move(offsetX, offsetY) {
        var _canvas = this.canvas,
            left = _canvas.left,
            top = _canvas.top;
    
    
        this.moveTo(isUndefined(offsetX) ? offsetX : left + Number(offsetX), isUndefined(offsetY) ? offsetY : top + Number(offsetY));
      },
    
    
      /**
       * Move the canvas to an absolute point
       * @param {number} x - The x-axis coordinate.
       * @param {number} [y=x] - The y-axis coordinate.
       */
      moveTo: function moveTo(x, y) {
        var canvas = this.canvas;
    
        var changed = false;
    
        // If "y" is not present, its default value is "x"
        if (isUndefined(y)) {
          y = x;
        }
    
        x = Number(x);
        y = Number(y);
    
        if (this.ready && !this.disabled && this.options.movable) {
          if (isNumber(x)) {
            canvas.left = x;
            changed = true;
          }
    
          if (isNumber(y)) {
            canvas.top = y;
            changed = true;
          }
    
          if (changed) {
            this.renderCanvas(true);
          }
        }
      },
    
    
      /**
       * Zoom the canvas with a relative ratio
       * @param {Number} ratio - The target ratio.
       * @param {Event} _event - The related event if any.
       */
      zoom: function zoom(ratio, _event) {
        var canvas = this.canvas;
    
    
        ratio = Number(ratio);
    
        if (ratio < 0) {
          ratio = 1 / (1 - ratio);
        } else {
          ratio = 1 + ratio;
        }
    
        this.zoomTo(canvas.width * ratio / canvas.naturalWidth, _event);
      },
    
    
      /**
       * Zoom the canvas to an absolute ratio
       * @param {number} ratio - The target ratio.
       * @param {Event} _event - The related event if any.
       */
      zoomTo: function zoomTo(ratio, _event) {
        var options = this.options,
            pointers = this.pointers,
            canvas = this.canvas;
        var width = canvas.width,
            height = canvas.height,
            naturalWidth = canvas.naturalWidth,
            naturalHeight = canvas.naturalHeight;
    
    
        ratio = Number(ratio);
    
        if (ratio >= 0 && this.ready && !this.disabled && options.zoomable) {
          var newWidth = naturalWidth * ratio;
          var newHeight = naturalHeight * ratio;
          var originalEvent = void 0;
    
          if (_event) {
            originalEvent = _event.originalEvent;
          }
    
          if (this.trigger(EVENT_ZOOM, {
            originalEvent: originalEvent,
            oldRatio: width / naturalWidth,
            ratio: newWidth / naturalWidth
          }).isDefaultPrevented()) {
            return;
          }
    
          if (originalEvent) {
            var offset = this.$cropper.offset();
            var center = pointers && objectKeys(pointers).length ? getPointersCenter(pointers) : {
              pageX: _event.pageX || originalEvent.pageX || 0,
              pageY: _event.pageY || originalEvent.pageY || 0
            };
    
            // Zoom from the triggering point of the event
            canvas.left -= (newWidth - width) * ((center.pageX - offset.left - canvas.left) / width);
            canvas.top -= (newHeight - height) * ((center.pageY - offset.top - canvas.top) / height);
          } else {
            // Zoom from the center of the canvas
            canvas.left -= (newWidth - width) / 2;
            canvas.top -= (newHeight - height) / 2;
          }
    
          canvas.width = newWidth;
          canvas.height = newHeight;
          this.renderCanvas(true);
        }
      },
    
    
      /**
       * Rotate the canvas with a relative degree
       * @param {number} degree - The rotate degree.
       */
      rotate: function rotate(degree) {
        this.rotateTo((this.image.rotate || 0) + Number(degree));
      },
    
    
      /**
       * Rotate the canvas to an absolute degree
       * @param {number} degree - The rotate degree.
       */
      rotateTo: function rotateTo(degree) {
        degree = Number(degree);
    
        if (isNumber(degree) && this.ready && !this.disabled && this.options.rotatable) {
          this.image.rotate = degree % 360;
          this.renderCanvas(true, true);
        }
      },
    
    
      /**
       * Scale the image on the x-axis.
       * @param {number} scaleX - The scale ratio on the x-axis.
       */
      scaleX: function scaleX(_scaleX) {
        var scaleY = this.image.scaleY;
    
    
        this.scale(_scaleX, isNumber(scaleY) ? scaleY : 1);
      },
    
    
      /**
       * Scale the image on the y-axis.
       * @param {number} scaleY - The scale ratio on the y-axis.
       */
      scaleY: function scaleY(_scaleY) {
        var scaleX = this.image.scaleX;
    
    
        this.scale(isNumber(scaleX) ? scaleX : 1, _scaleY);
      },
    
    
      /**
       * Scale the image
       * @param {number} scaleX - The scale ratio on the x-axis.
       * @param {number} [scaleY=scaleX] - The scale ratio on the y-axis.
       */
      scale: function scale(scaleX) {
        var scaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scaleX;
        var image = this.image;
    
        var transformed = false;
    
        scaleX = Number(scaleX);
        scaleY = Number(scaleY);
    
        if (this.ready && !this.disabled && this.options.scalable) {
          if (isNumber(scaleX)) {
            image.scaleX = scaleX;
            transformed = true;
          }
    
          if (isNumber(scaleY)) {
            image.scaleY = scaleY;
            transformed = true;
          }
    
          if (transformed) {
            this.renderCanvas(true, true);
          }
        }
      },
    
    
      /**
       * Get the cropped area position and size data (base on the original image)
       * @param {boolean} [rounded=false] - Indicate if round the data values or not.
       * @returns {Object} The result cropped data.
       */
      getData: function getData() {
        var rounded = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var options = this.options,
            image = this.image,
            canvas = this.canvas,
            cropBox = this.cropBox;
    
        var data = void 0;
    
        if (this.ready && this.cropped) {
          data = {
            x: cropBox.left - canvas.left,
            y: cropBox.top - canvas.top,
            width: cropBox.width,
            height: cropBox.height
          };
    
          var ratio = image.width / image.naturalWidth;
    
          $.each(data, function (i, n) {
            n /= ratio;
            data[i] = rounded ? Math.round(n) : n;
          });
        } else {
          data = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
    
        if (options.rotatable) {
          data.rotate = image.rotate || 0;
        }
    
        if (options.scalable) {
          data.scaleX = image.scaleX || 1;
          data.scaleY = image.scaleY || 1;
        }
    
        return data;
      },
    
    
      /**
       * Set the cropped area position and size with new data
       * @param {Object} data - The new data.
       */
      setData: function setData(data) {
        var options = this.options,
            image = this.image,
            canvas = this.canvas;
    
        var cropBoxData = {};
    
        if ($.isFunction(data)) {
          data = data.call(this.element);
        }
    
        if (this.ready && !this.disabled && $.isPlainObject(data)) {
          var transformed = false;
    
          if (options.rotatable) {
            if (isNumber(data.rotate) && data.rotate !== image.rotate) {
              image.rotate = data.rotate;
              transformed = true;
            }
          }
    
          if (options.scalable) {
            if (isNumber(data.scaleX) && data.scaleX !== image.scaleX) {
              image.scaleX = data.scaleX;
              transformed = true;
            }
    
            if (isNumber(data.scaleY) && data.scaleY !== image.scaleY) {
              image.scaleY = data.scaleY;
              transformed = true;
            }
          }
    
          if (transformed) {
            this.renderCanvas(true, true);
          }
    
          var ratio = image.width / image.naturalWidth;
    
          if (isNumber(data.x)) {
            cropBoxData.left = data.x * ratio + canvas.left;
          }
    
          if (isNumber(data.y)) {
            cropBoxData.top = data.y * ratio + canvas.top;
          }
    
          if (isNumber(data.width)) {
            cropBoxData.width = data.width * ratio;
          }
    
          if (isNumber(data.height)) {
            cropBoxData.height = data.height * ratio;
          }
    
          this.setCropBoxData(cropBoxData);
        }
      },
    
    
      /**
       * Get the container size data.
       * @returns {Object} The result container data.
       */
      getContainerData: function getContainerData() {
        return this.ready ? $.extend({}, this.container) : {};
      },
    
    
      /**
       * Get the image position and size data.
       * @returns {Object} The result image data.
       */
      getImageData: function getImageData() {
        return this.loaded ? $.extend({}, this.image) : {};
      },
    
    
      /**
       * Get the canvas position and size data.
       * @returns {Object} The result canvas data.
       */
      getCanvasData: function getCanvasData() {
        var canvas = this.canvas;
    
        var data = {};
    
        if (this.ready) {
          $.each(['left', 'top', 'width', 'height', 'naturalWidth', 'naturalHeight'], function (i, n) {
            data[n] = canvas[n];
          });
        }
    
        return data;
      },
    
    
      /**
       * Set the canvas position and size with new data.
       * @param {Object} data - The new canvas data.
       */
      setCanvasData: function setCanvasData(data) {
        var canvas = this.canvas;
        var aspectRatio = canvas.aspectRatio;
    
    
        if ($.isFunction(data)) {
          data = data.call(this.$element);
        }
    
        if (this.ready && !this.disabled && $.isPlainObject(data)) {
          if (isNumber(data.left)) {
            canvas.left = data.left;
          }
    
          if (isNumber(data.top)) {
            canvas.top = data.top;
          }
    
          if (isNumber(data.width)) {
            canvas.width = data.width;
            canvas.height = data.width / aspectRatio;
          } else if (isNumber(data.height)) {
            canvas.height = data.height;
            canvas.width = data.height * aspectRatio;
          }
    
          this.renderCanvas(true);
        }
      },
    
    
      /**
       * Get the crop box position and size data.
       * @returns {Object} The result crop box data.
       */
      getCropBoxData: function getCropBoxData() {
        var cropBox = this.cropBox;
    
    
        return this.ready && this.cropped ? {
          left: cropBox.left,
          top: cropBox.top,
          width: cropBox.width,
          height: cropBox.height
        } : {};
      },
    
    
      /**
       * Set the crop box position and size with new data.
       * @param {Object} data - The new crop box data.
       */
      setCropBoxData: function setCropBoxData(data) {
        var cropBox = this.cropBox;
        var aspectRatio = this.options.aspectRatio;
    
        var widthChanged = void 0;
        var heightChanged = void 0;
    
        if ($.isFunction(data)) {
          data = data.call(this.$element);
        }
    
        if (this.ready && this.cropped && !this.disabled && $.isPlainObject(data)) {
          if (isNumber(data.left)) {
            cropBox.left = data.left;
          }
    
          if (isNumber(data.top)) {
            cropBox.top = data.top;
          }
    
          if (isNumber(data.width) && data.width !== cropBox.width) {
            widthChanged = true;
            cropBox.width = data.width;
          }
    
          if (isNumber(data.height) && data.height !== cropBox.height) {
            heightChanged = true;
            cropBox.height = data.height;
          }
    
          if (aspectRatio) {
            if (widthChanged) {
              cropBox.height = cropBox.width / aspectRatio;
            } else if (heightChanged) {
              cropBox.width = cropBox.height * aspectRatio;
            }
          }
    
          this.renderCropBox();
        }
      },
    
    
      /**
       * Get a canvas drawn the cropped image.
       * @param {Object} [options={}] - The config options.
       * @returns {HTMLCanvasElement} - The result canvas.
       */
      getCroppedCanvas: function getCroppedCanvas() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    
        if (!this.ready || !window.HTMLCanvasElement) {
          return null;
        }
    
        var canvasData = this.canvas;
    
        var source = getSourceCanvas(this.$clone[0], this.image, canvasData, options);
    
        // Returns the source canvas if it is not cropped.
        if (!this.cropped) {
          return source;
        }
    
        var _getData = this.getData(),
            x = _getData.x,
            y = _getData.y,
            initialWidth = _getData.width,
            initialHeight = _getData.height;
    
        var aspectRatio = initialWidth / initialHeight;
        var maxSizes = getContainSizes({
          aspectRatio: aspectRatio,
          width: options.maxWidth || Infinity,
          height: options.maxHeight || Infinity
        });
        var minSizes = getContainSizes({
          aspectRatio: aspectRatio,
          width: options.minWidth || 0,
          height: options.minHeight || 0
        });
    
        var _getContainSizes = getContainSizes({
          aspectRatio: aspectRatio,
          width: options.width || initialWidth,
          height: options.height || initialHeight
        }),
            width = _getContainSizes.width,
            height = _getContainSizes.height;
    
        width = Math.min(maxSizes.width, Math.max(minSizes.width, width));
        height = Math.min(maxSizes.height, Math.max(minSizes.height, height));
    
        var canvas = document.createElement('canvas');
        var context = canvas.getContext('2d');
    
        canvas.width = normalizeDecimalNumber(width);
        canvas.height = normalizeDecimalNumber(height);
        context.fillStyle = options.fillColor || 'transparent';
        context.fillRect(0, 0, width, height);
    
        var _options$imageSmoothi = options.imageSmoothingEnabled,
            imageSmoothingEnabled = _options$imageSmoothi === undefined ? true : _options$imageSmoothi,
            imageSmoothingQuality = options.imageSmoothingQuality;
    
    
        context.imageSmoothingEnabled = imageSmoothingEnabled;
    
        if (imageSmoothingQuality) {
          context.imageSmoothingQuality = imageSmoothingQuality;
        }
    
        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.drawImage
        var sourceWidth = source.width;
        var sourceHeight = source.height;
    
        // Source canvas parameters
        var srcX = x;
        var srcY = y;
        var srcWidth = void 0;
        var srcHeight = void 0;
    
        // Destination canvas parameters
        var dstX = void 0;
        var dstY = void 0;
        var dstWidth = void 0;
        var dstHeight = void 0;
    
        if (srcX <= -initialWidth || srcX > sourceWidth) {
          srcX = 0;
          srcWidth = 0;
          dstX = 0;
          dstWidth = 0;
        } else if (srcX <= 0) {
          dstX = -srcX;
          srcX = 0;
          srcWidth = Math.min(sourceWidth, initialWidth + srcX);
          dstWidth = srcWidth;
        } else if (srcX <= sourceWidth) {
          dstX = 0;
          srcWidth = Math.min(initialWidth, sourceWidth - srcX);
          dstWidth = srcWidth;
        }
    
        if (srcWidth <= 0 || srcY <= -initialHeight || srcY > sourceHeight) {
          srcY = 0;
          srcHeight = 0;
          dstY = 0;
          dstHeight = 0;
        } else if (srcY <= 0) {
          dstY = -srcY;
          srcY = 0;
          srcHeight = Math.min(sourceHeight, initialHeight + srcY);
          dstHeight = srcHeight;
        } else if (srcY <= sourceHeight) {
          dstY = 0;
          srcHeight = Math.min(initialHeight, sourceHeight - srcY);
          dstHeight = srcHeight;
        }
    
        // All the numerical parameters should be integer for `drawImage`
        // https://github.com/fengyuanchen/cropper/issues/476
        var params = [srcX, srcY, srcWidth, srcHeight];
    
        // Avoid "IndexSizeError"
        if (dstWidth > 0 && dstHeight > 0) {
          var scale = width / initialWidth;
    
          params.push(dstX * scale, dstY * scale, dstWidth * scale, dstHeight * scale);
        }
    
        context.drawImage.apply(context, [source].concat(_toConsumableArray$1($.map(params, function (param) {
          return Math.floor(normalizeDecimalNumber(param));
        }))));
        return canvas;
      },
    
    
      /**
       * Change the aspect ratio of the crop box.
       * @param {number} aspectRatio - The new aspect ratio.
       */
      setAspectRatio: function setAspectRatio(aspectRatio) {
        var options = this.options;
    
    
        if (!this.disabled && !isUndefined(aspectRatio)) {
          // 0 -> NaN
          options.aspectRatio = Math.max(0, aspectRatio) || NaN;
    
          if (this.ready) {
            this.initCropBox();
    
            if (this.cropped) {
              this.renderCropBox();
            }
          }
        }
      },
    
    
      /**
       * Change the drag mode.
       * @param {string} mode - The new drag mode.
       */
      setDragMode: function setDragMode(mode) {
        var options = this.options;
    
        var croppable = void 0;
        var movable = void 0;
    
        if (this.loaded && !this.disabled) {
          croppable = mode === DRAG_MODE_CROP;
          movable = options.movable && mode === DRAG_MODE_MOVE;
          mode = croppable || movable ? mode : DRAG_MODE_NONE;
    
          this.$dragBox.data(DATA_ACTION, mode).toggleClass(CLASS_CROP, croppable).toggleClass(CLASS_MOVE, movable);
    
          if (!options.cropBoxMovable) {
            // Sync drag mode to crop box when it is not movable(#300)
            this.$face.data(DATA_ACTION, mode).toggleClass(CLASS_CROP, croppable).toggleClass(CLASS_MOVE, movable);
          }
        }
      }
    };
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var Cropper = function () {
      /**
       * Create a new Cropper.
       * @param {Element} element - The target element for cropping.
       * @param {Object} [options={}] - The configuration options.
       */
      function Cropper(element) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    
        _classCallCheck(this, Cropper);
    
        if (!element || !REGEXP_TAG_NAME.test(element.tagName)) {
          throw new Error('The first argument is required and must be an <img> or <canvas> element.');
        }
    
        this.element = element;
        this.$element = $(element);
        this.options = $.extend({}, DEFAULTS, $.isPlainObject(options) && options);
        this.completed = false;
        this.cropped = false;
        this.disabled = false;
        this.isImg = false;
        this.limited = false;
        this.loaded = false;
        this.ready = false;
        this.replaced = false;
        this.wheeling = false;
        this.originalUrl = '';
        this.canvas = null;
        this.cropBox = null;
        this.pointers = {};
        this.init();
      }
    
      _createClass(Cropper, [{
        key: 'init',
        value: function init() {
          var $element = this.$element;
    
          var url = void 0;
    
          if ($element.is('img')) {
            this.isImg = true;
    
            // Should use `$.fn.attr` here. e.g.: "img/picture.jpg"
            url = $element.attr('src') || '';
            this.originalUrl = url;
    
            // Stop when it's a blank image
            if (!url) {
              return;
            }
    
            // Should use `$.fn.prop` here. e.g.: "http://example.com/img/picture.jpg"
            url = $element.prop('src');
          } else if ($element.is('canvas') && window.HTMLCanvasElement) {
            url = $element[0].toDataURL();
          }
    
          this.load(url);
        }
    
        // A shortcut for triggering custom events
    
      }, {
        key: 'trigger',
        value: function trigger(type, data) {
          var e = $.Event(type, data);
    
          this.$element.trigger(e);
    
          return e;
        }
      }, {
        key: 'load',
        value: function load(url) {
          var _this = this;
    
          if (!url) {
            return;
          }
    
          this.url = url;
          this.image = {};
    
          var $element = this.$element,
              options = this.options;
    
    
          if (!options.checkOrientation || !window.ArrayBuffer) {
            this.clone();
            return;
          }
    
          // XMLHttpRequest disallows to open a Data URL in some browsers like IE11 and Safari
          if (REGEXP_DATA_URL.test(url)) {
            if (REGEXP_DATA_URL_JPEG.test(url)) {
              this.read(dataURLToArrayBuffer(url));
            } else {
              this.clone();
            }
    
            return;
          }
    
          var xhr = new XMLHttpRequest();
    
          xhr.onerror = function () {
            _this.clone();
          };
    
          xhr.onload = function () {
            _this.read(xhr.response);
          };
    
          if (options.checkCrossOrigin && isCrossOriginURL(url) && $element.prop('crossOrigin')) {
            url = addTimestamp(url);
          }
    
          xhr.open('get', url);
          xhr.responseType = 'arraybuffer';
          xhr.withCredentials = $element.prop('crossOrigin') === 'use-credentials';
          xhr.send();
        }
      }, {
        key: 'read',
        value: function read(arrayBuffer) {
          var options = this.options,
              image = this.image;
    
          var orientation = getOrientation(arrayBuffer);
          var rotate = 0;
          var scaleX = 1;
          var scaleY = 1;
    
          if (orientation > 1) {
            this.url = arrayBufferToDataURL(arrayBuffer, 'image/jpeg');
    
            var _parseOrientation = parseOrientation(orientation);
    
            rotate = _parseOrientation.rotate;
            scaleX = _parseOrientation.scaleX;
            scaleY = _parseOrientation.scaleY;
          }
    
          if (options.rotatable) {
            image.rotate = rotate;
          }
    
          if (options.scalable) {
            image.scaleX = scaleX;
            image.scaleY = scaleY;
          }
    
          this.clone();
        }
      }, {
        key: 'clone',
        value: function clone() {
          var $element = this.$element,
              options = this.options,
              url = this.url;
    
          var crossOrigin = '';
          var crossOriginUrl = void 0;
    
          if (options.checkCrossOrigin && isCrossOriginURL(url)) {
            crossOrigin = $element.prop('crossOrigin');
    
            if (crossOrigin) {
              crossOriginUrl = url;
            } else {
              crossOrigin = 'anonymous';
    
              // Bust cache (#148) when there is not a "crossOrigin" property
              crossOriginUrl = addTimestamp(url);
            }
          }
    
          this.crossOrigin = crossOrigin;
          this.crossOriginUrl = crossOriginUrl;
    
          var image = document.createElement('img');
    
          if (crossOrigin) {
            image.crossOrigin = crossOrigin;
          }
    
          image.src = crossOriginUrl || url;
    
          var $clone = $(image);
    
          this.$clone = $clone;
    
          if (this.isImg) {
            if (this.element.complete) {
              this.start();
            } else {
              $element.one(EVENT_LOAD, $.proxy(this.start, this));
            }
          } else {
            $clone.one(EVENT_LOAD, $.proxy(this.start, this)).one(EVENT_ERROR, $.proxy(this.stop, this)).addClass(CLASS_HIDE).insertAfter($element);
          }
        }
      }, {
        key: 'start',
        value: function start() {
          var _this2 = this;
    
          var $clone = this.$clone;
    
          var $image = this.$element;
    
          if (!this.isImg) {
            $clone.off(EVENT_ERROR, this.stop);
            $image = $clone;
          }
    
          getImageNaturalSizes($image[0], function (naturalWidth, naturalHeight) {
            $.extend(_this2.image, {
              naturalWidth: naturalWidth,
              naturalHeight: naturalHeight,
              aspectRatio: naturalWidth / naturalHeight
            });
    
            _this2.loaded = true;
            _this2.build();
          });
        }
      }, {
        key: 'stop',
        value: function stop() {
          this.$clone.remove();
          this.$clone = null;
        }
      }, {
        key: 'build',
        value: function build() {
          var _this3 = this;
    
          if (!this.loaded) {
            return;
          }
    
          // Unbuild first when replace
          if (this.ready) {
            this.unbuild();
          }
    
          var $element = this.$element,
              options = this.options,
              $clone = this.$clone;
    
          var $cropper = $(TEMPLATE);
          var $cropBox = $cropper.find('.' + NAMESPACE + '-crop-box');
          var $face = $cropBox.find('.' + NAMESPACE + '-face');
    
          // Create cropper elements
          this.$container = $element.parent();
          this.$cropper = $cropper;
          this.$canvas = $cropper.find('.' + NAMESPACE + '-canvas').append($clone);
          this.$dragBox = $cropper.find('.' + NAMESPACE + '-drag-box');
          this.$cropBox = $cropBox;
          this.$viewBox = $cropper.find('.' + NAMESPACE + '-view-box');
          this.$face = $face;
    
          // Hide the original image
          $element.addClass(CLASS_HIDDEN).after($cropper);
    
          // Show the clone image if is hidden
          if (!this.isImg) {
            $clone.removeClass(CLASS_HIDE);
          }
    
          this.initPreview();
          this.bind();
    
          options.aspectRatio = Math.max(0, options.aspectRatio) || NaN;
          options.viewMode = Math.max(0, Math.min(3, Math.round(options.viewMode))) || 0;
    
          this.cropped = options.autoCrop;
    
          if (options.autoCrop) {
            if (options.modal) {
              this.$dragBox.addClass(CLASS_MODAL);
            }
          } else {
            $cropBox.addClass(CLASS_HIDDEN);
          }
    
          if (!options.guides) {
            $cropBox.find('.' + NAMESPACE + '-dashed').addClass(CLASS_HIDDEN);
          }
    
          if (!options.center) {
            $cropBox.find('.' + NAMESPACE + '-center').addClass(CLASS_HIDDEN);
          }
    
          if (options.cropBoxMovable) {
            $face.addClass(CLASS_MOVE).data(DATA_ACTION, ACTION_ALL);
          }
    
          if (!options.highlight) {
            $face.addClass(CLASS_INVISIBLE);
          }
    
          if (options.background) {
            $cropper.addClass(NAMESPACE + '-bg');
          }
    
          if (!options.cropBoxResizable) {
            $cropBox.find('.' + NAMESPACE + '-line,.' + NAMESPACE + '-point').addClass(CLASS_HIDDEN);
          }
    
          this.setDragMode(options.dragMode);
          this.render();
          this.ready = true;
          this.setData(options.data);
    
          // Trigger the ready event asynchronously to keep `data('cropper')` is defined
          this.completing = setTimeout(function () {
            if ($.isFunction(options.ready)) {
              $element.one(EVENT_READY, options.ready);
            }
    
            _this3.trigger(EVENT_READY);
            _this3.trigger(EVENT_CROP, _this3.getData());
            _this3.completed = true;
          }, 0);
        }
      }, {
        key: 'unbuild',
        value: function unbuild() {
          if (!this.ready) {
            return;
          }
    
          if (!this.completed) {
            clearTimeout(this.completing);
          }
    
          this.ready = false;
          this.completed = false;
          this.initialImage = null;
    
          // Clear `initialCanvas` is necessary when replace
          this.initialCanvas = null;
          this.initialCropBox = null;
          this.container = null;
          this.canvas = null;
    
          // Clear `cropBox` is necessary when replace
          this.cropBox = null;
          this.unbind();
    
          this.resetPreview();
          this.$preview = null;
    
          this.$viewBox = null;
          this.$cropBox = null;
          this.$dragBox = null;
          this.$canvas = null;
          this.$container = null;
    
          this.$cropper.remove();
          this.$cropper = null;
        }
    
        /**
         * Change the default options.
         * @param {Object} options - The new default options.
         */
    
      }], [{
        key: 'setDefaults',
        value: function setDefaults(options) {
          $.extend(DEFAULTS, $.isPlainObject(options) && options);
        }
      }]);
    
      return Cropper;
    }();
    
    if ($.extend) {
      $.extend(Cropper.prototype, render, preview, events, handlers, change, methods);
    }
    
    if ($.fn) {
      var AnotherCropper = $.fn.cropper;
    
      $.fn.cropper = function jQueryCropper(option) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
    
        var result = void 0;
    
        this.each(function (i, element) {
          var $element = $(element);
          var data = $element.data(NAMESPACE);
    
          if (!data) {
            if (/destroy/.test(option)) {
              return;
            }
    
            var options = $.extend({}, $element.data(), $.isPlainObject(option) && option);
    
            data = new Cropper(element, options);
            $element.data(NAMESPACE, data);
          }
    
          if (isString(option)) {
            var fn = data[option];
    
            if ($.isFunction(fn)) {
              result = fn.apply(data, args);
            }
          }
        });
    
        return isUndefined(result) ? this : result;
      };
    
      $.fn.cropper.Constructor = Cropper;
      $.fn.cropper.setDefaults = Cropper.setDefaults;
      $.fn.cropper.noConflict = function noConflict() {
        $.fn.cropper = AnotherCropper;
        return this;
      };
    }
    
    })));
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    },{"jquery":63}],42:[function(require,module,exports){
    var $ = require('jquery');
    
    /**
     * @module dispatcher test
     */
    
    module.exports = function () {
        /* fireCallback */
    
        function fireCallback(callback, parameter) {
            if ($.isFunction(callback)) {
                callback(parameter);
            }
        }
    
        function fireCallbacks(callbacks, parameter) {
            for (var i = 0; i < callbacks.length; i++) {
                fireCallback(callbacks[i], parameter);
            }
        }
    
        return {
            fireCallbacks: fireCallbacks
        };
    }();
    },{"jquery":63}],43:[function(require,module,exports){
    /* 
     This is meant to solve the common problem we have with needing to set consistent heights to items 
     that will be visually side by side but within container items.
    
      Options
        data-equalizer-dynamic: set on the same html element as data-equalizer, this option makes the
            calculation of rows responsive so that heights are so appropriately when 1-N columns in a
            row across breakpoints.
    
    */
    
    var $ = require('jquery');
    var viewport = require('./viewport');
    
    module.exports = function () {
    
        var $equalizeContainers = $("[data-equalizer]"),
            $equalizeContainersImageAlign = $("[data-equalizer-image-align]"),
            doNotEqualizeIfHasClasses = ".slick-initialized";
    
        function equalize($equalizeContainer, cols) {
    
            var maxHeight = 0;
            var $equalizedItems = $equalizeContainer.find('[data-equalizer-watch]');
    
            // do not equalize
            if ($equalizeContainer.is(doNotEqualizeIfHasClasses)) {
                $equalizedItems.height('inherit');
                return;
            }
    
            // if dynamic mode has grouped rows, equalize cols by grouped row
            if (typeof cols !== 'undefined') {
    
                while ($equalizedItems.length) {
                    var currentEqualizedItemGroup = $($equalizedItems.splice(0, cols));
    
                    maxHeight = 0;
                    currentEqualizedItemGroup.height('inherit');
                    currentEqualizedItemGroup.each(function (i, element) {
                        var height = $(element).outerHeight();
                        if (height > maxHeight) {
                            maxHeight = height;
                        }
                    });
                    currentEqualizedItemGroup.height(maxHeight);
                }
            } else {
                $equalizedItems.height('inherit');
                $equalizedItems.each(function (i, element) {
                    var height = $(element).height();
                    if (height > maxHeight) {
                        maxHeight = height;
                    }
                });
                $equalizedItems.height(maxHeight);
            }
        }
    
        function equalizeImages($equalizeContainer, cols) {
    
            var maxHeight = 0;
            var $equalizedItems = $equalizeContainer.find('[data-equalizer-watch]');
    
            // do not equalize
            if ($equalizeContainer.is(doNotEqualizeIfHasClasses)) {
                $equalizedItems.height('inherit');
                return;
            }
    
            if ($equalizedItems.length < 2) {
                $equalizedItems.height('inherit');
                return;
            }
    
            $equalizedItems.height('inherit');
            $equalizedItems.each(function (i, element) {
                var $image = $(element).find('svg, img');
                $(element).height($image.height());
                var height = $(element).height();
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });
            $equalizedItems.height(maxHeight);
        }
    
        /* Summary: gets the column count of the first row in order to split all the columns into groups if set to dynamic mode
            - previous data-equalizer-watch elements may not be direct siblings, so we can get the collected columns of a row by index instead
        */
        function getRowColCount($container) {
            var $cols = $container.find('[data-equalizer-watch]');
            if ($cols) {
    
                var tempCount = 0;
                $cols.each(function (index) {
                    var $col = $(this);
    
                    if (index - 1 >= 0) {
                        if ($col.offset().top !== $cols.eq(index - 1).offset().top) {
                            return false;
                        }
                        tempCount++;
                    } else {
                        tempCount++;
                    }
                });
                return tempCount;
            }
            return $cols.length;
        }
    
        function equalizeAll() {
            $equalizeContainers.each(function (i, element) {
                var $container = $(element);
    
                // if need equalize each row group in container
                if (typeof $container.attr('data-equalizer-dynamic') === "string") {
                    var rowColCount = getRowColCount($container);
    
                    equalize($container, rowColCount);
                } else {
                    equalize($container);
                }
            });
            $equalizeContainersImageAlign.each(function (i, element) {
                var $container = $(element);
                equalizeImages($container);
            });
        }
    
        function load() {
            //equalizeAll();
            viewport.resize(equalizeAll);
        }
    
        $(document).ready(function () {
            load();
        });
    }();
    },{"./viewport":50,"jquery":63}],44:[function(require,module,exports){
    module.exports = function () {
    
        return {
            maxMobileBreakpoint: 767,
            maxTabletPortraitBreakpoint: 840,
            maxTabletBreakpoint: 1024,
            desktopContainerBreakpoint: 1170,
            // generates a unique ID based on the current date
            uniqueID: function () {
                if (!Date.now) {
                    Date.now = function () { return new Date().getTime(); };
                }
                return Date.now();
            },
            // checks if a variable is defined or if an object exists or if an array contains any elements
            exists: function (el) {
                if (typeof el != "undefined" && el != null) {
                    if (typeof el.length != "undefined" && el.length === 0) {
                        return false;
                    }
                    return true;
                }
                return false;
            },
            // if both objects have the same property, the value in obj2 takes precedence
            merge: function (obj1, obj2) {
                var obj = {};
    
                for (var x in obj1)
                    if (obj1.hasOwnProperty(x))
                        obj[x] = obj1[x];
    
                for (var y in obj2)
                    if (obj2.hasOwnProperty(y))
                        obj[y] = obj2[y];
    
                return obj;
            },
            // executes a callback function after a given delay
            delay: (function () {
                var timer = 0;
                return function (callback, ms) {
                    clearTimeout(timer);
                    timer = setTimeout(callback, ms);
                };
            })(),
            getURIParameterByName: function (name, url) {
                if (!url) url = window.location.href;
                name = name.replace(/[\[\]]/g, "\\$&");
                var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)", "i"),
                    results = regex.exec(url);
                if (!results) return null;
                if (!results[2]) return '';
                return decodeURIComponent(results[2].replace(/\+/g, " "));
            }
        };
    
    }();
    },{}],45:[function(require,module,exports){
    /*
     * custom knockout binding handlers, extenders, and utility fn
     * 
     */
    require('jquery-ui/ui/widgets/datepicker');
    var _ = require("underscore");
    var ko = require("knockout");
    
    exports.init = function ($) {
    
        (function() {
            
            // helpers
            var formatPhone = function(inputVal, prevLen) {
                prevLen = prevLen || inputVal.length;
                var newVal = '';
    
                var strippedNewVal = inputVal.replace(/[^0-9\s]/gi, '').replace(/[-\s]/g, '');
                var phoneLen = strippedNewVal.length;
    
                if (prevLen > inputVal.length) {
                    newVal = inputVal;
                } else if (phoneLen >= 10) {
                    newVal = strippedNewVal.slice(0, 3) + "-" + strippedNewVal.slice(3, 6) + "-" + strippedNewVal.slice(6, 10);
                } else if (phoneLen > 6 && phoneLen <= 10) {
                    newVal = strippedNewVal.slice(0, 3) + "-" + strippedNewVal.slice(3, 6) + "-" + strippedNewVal.slice(6, phoneLen);
                } else if (phoneLen >= 3 && phoneLen <= 6) {
                    newVal = strippedNewVal.slice(0, 3) + "-" + strippedNewVal.slice(3, phoneLen);
                } else {
                    newVal = strippedNewVal;
                }
    
                return newVal;
            };
    
            // bindingHandlers
            ko.bindingHandlers.limitCharacters = {
                update: function(element, valueAccessor, allBindingsAccessor, viewModel) {
                    var allowedNumberOfCharacters = valueAccessor();
                    var currentValue = allBindingsAccessor.get('value');
                    var cutText = ko.unwrap(currentValue).substr(0, allowedNumberOfCharacters);
                    currentValue(cutText);
                }
            };
            ko.bindingHandlers.phoneFormatter = {
                init: function (element, valueAccessor, allBindings) {
                    var observable = valueAccessor();
                    var value = ko.unwrap(observable);
    
                    if (typeof value === "string") {
                        var newVal = formatPhone(value);
                        observable(newVal);
                    }
    
                    // set event binding
                    $(element).on('input', function (e) {           // keyup input paste
                        var inputvalue = $(element).val().trim();
                        var observable = valueAccessor();
                        var prevLen = observable() != null ? observable().length : 0;
                        var newVal = formatPhone(inputvalue, prevLen);
    
                        // notify change explicitly
                        if (observable.peek() === newVal) {
                            observable.notifySubscribers(newVal);
                        } else {
                            observable(newVal);
                        }
                    });
                },
                update: function(element, valueAccessor, allBindings) {
                    var valueUnwrapped = ko.utils.unwrapObservable(valueAccessor());
                    $(element).val(valueUnwrapped);
                }
            };
    
            // extenders
            ko.extenders.titlecase = function (target, option) {
                target.subscribe(function (newValue) {
                    target(newValue.charAt(0).toUpperCase() + newValue.substr(1));
                });
                return target;
            };
    
            // functions
            ko.observableArray.fn.pushAll = function (valuesToPush) {
                var underlyingArray = this();
                this.valueWillMutate();
                ko.utils.arrayPushAll(underlyingArray, valuesToPush);
                this.valueHasMutated();
                return this;
            };
        })();
    
    };
    },{"jquery-ui/ui/widgets/datepicker":62,"knockout":64,"underscore":66}],46:[function(require,module,exports){
    module.exports = function() {
    
        return {
    
            // converts location with geocode to get bounding square and passes success data to callback
            GetHospitals: function (geocoder, zip, radius, callback) {
    
                //Use the Geocoder to resolve the zip to a coordinate set
                geocoder.geocode({ 'address': zip }, function (results, status) {
                    if (status === google.maps.GeocoderStatus.OK) {
    
                        var circleData = {
                            center: results[0].geometry.location,
                            radius: radius * 1609.34
                        };
    
                        //Create a circle with the appropriate data
                        var boundingData = new google.maps.Circle(circleData).getBounds();
                        callback(boundingData, results[0].geometry.location);
                    } else {
                        console.log("Geocode was not successful for the following reason: " + status);
                    }
                });
            },
            GetHospitalsByCoordinates: function (geocoder, coordinates, radius, callback) {
    
                //Use the Geocoder to get the place data based on a coordinate set
                geocoder.geocode({ location: coordinates }, function (results, status) {
                    if (status === google.maps.GeocoderStatus.OK) {
    
                        var circleData = {
                            center: results[0].geometry.location,
                            radius: radius * 1609.34
                        };
    
                        //Create a circle with the appropriate data
                        var boundingData = new google.maps.Circle(circleData).getBounds();
                        callback(boundingData, results[0].geometry.location);
                    } else {
                        console.log("Geocode was not successful for the following reason: " + status);
                    }
                });
            }
        }
    
    }();
    },{}],47:[function(require,module,exports){
    exports.init = function ($) {
    
        var OptGroupAdder = (function () {
    
            function addOptGroup() {
                var selects = document.querySelectorAll("select");
                for (var i = 0; i < selects.length; i++) {
                    selects[i].appendChild(document.createElement("optgroup"));
                }
            }
    
            function initialize() {
                addOptGroup();
            }
    
            return {
                init: initialize
            };
    
        })();
    
        OptGroupAdder.init();
    };
    },{}],48:[function(require,module,exports){
    
    module.exports = function() {
        return {
            getUrlVars: function() {
    
                var vars = [], hash;
                var hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');
                for (var i = 0; i < hashes.length; i++) {
                    hash = hashes[i].split('=');
                    vars.push(hash[0]);
                    vars[hash[0]] = hash[1];
                }
                return vars;
            }
        }
    }();
    
    },{}],49:[function(require,module,exports){
    exports.init = function ($) {
    
        function ReturnToTop() {
            // ===== Scroll to Top ==== 
            $(window).scroll(function () {
                if ($(this).scrollTop() >= 50) {        // If page is scrolled more than 50px
                    $('#return-to-top').fadeIn(200);    // Fade in the arrow
                } else {
                    $('#return-to-top').fadeOut(200);   // Else fade out the arrow
                }
            });
            $('#return-to-top').click(function () {      // When arrow is clicked
                $('body,html').animate({
                    scrollTop: 0                       // Scroll to top of body
                }, 500);
            });
        }
    
        ReturnToTop();
    };
    },{}],50:[function(require,module,exports){
    var $ = require('jquery');
    var dispatcher = require('./dispatcher');
    
    module.exports = function () {
    
        var $window = $(window);
        var $document = $(document);
        var $htmlBody = $('html, body');
    
        var documentHeight = '';
    
        var currentViewport = {
            width: 0,
            height: 0
        };
    
        var callbacks = {
            scroll: [],
            scrollUp: [],
            scrollDown: [],
            resize: []
        };
    
        //public methods
        function resize(callback) {
            callbacks.resize.push(callback);
        }
    
        function get() {
            return currentViewport;
        }
    
        //private methods
        function updateCurrentViewport() {
            currentViewport.width = $window.width();
            currentViewport.height = $window.height();
        }
    
        function handleResize() {
            updateCurrentViewport();
            dispatcher.fireCallbacks(callbacks.resize);
        }
    
        function checkHtmlSize() {
            if (documentHeight !== $document.height()) {
                documentHeight = $document.height();
    
                handleResize();
            }
        }
    
        function checkHtmlResize() {
            setInterval(checkHtmlSize, 1);
        }
    
        function load() {
            updateCurrentViewport();
            $window.resize(handleResize);
            checkHtmlResize();
        }
    
        load();
    
        return {
            resize: resize,
            get: get
        };
    }();
    },{"./dispatcher":42,"jquery":63}],51:[function(require,module,exports){
    (function (global){
    
    ; $ = global.$ = require("jQuery");
    ; var __browserify_shim_require__=require;(function browserifyShim(module, exports, require, define, browserify_shim__define__module__export__) {
    /*!
     * Bootstrap v3.3.7 (http://getbootstrap.com)
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under the MIT license
     */
    
    if (typeof jQuery === 'undefined') {
      throw new Error('Bootstrap\'s JavaScript requires jQuery')
    }
    
    +function ($) {
      'use strict';
      var version = $.fn.jquery.split(' ')[0].split('.')
      if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1) || (version[0] > 3)) {
        throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4')
      }
    }(jQuery);
    
    /* ========================================================================
     * Bootstrap: transition.js v3.3.7
     * http://getbootstrap.com/javascript/#transitions
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */
    
    
    +function ($) {
      'use strict';
    
      // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
      // ============================================================
    
      function transitionEnd() {
        var el = document.createElement('bootstrap')
    
        var transEndEventNames = {
          WebkitTransition : 'webkitTransitionEnd',
          MozTransition    : 'transitionend',
          OTransition      : 'oTransitionEnd otransitionend',
          transition       : 'transitionend'
        }
    
        for (var name in transEndEventNames) {
          if (el.style[name] !== undefined) {
            return { end: transEndEventNames[name] }
          }
        }
    
        return false // explicit for ie8 (  ._.)
      }
    
      // http://blog.alexmaccaw.com/css-transitions
      $.fn.emulateTransitionEnd = function (duration) {
        var called = false
        var $el = this
        $(this).one('bsTransitionEnd', function () { called = true })
        var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
        setTimeout(callback, duration)
        return this
      }
    
      $(function () {
        $.support.transition = transitionEnd()
    
        if (!$.support.transition) return
    
        $.event.special.bsTransitionEnd = {
          bindType: $.support.transition.end,
          delegateType: $.support.transition.end,
          handle: function (e) {
            if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
          }
        }
      })
    
    }(jQuery);
    
    /* ========================================================================
     * Bootstrap: alert.js v3.3.7
     * http://getbootstrap.com/javascript/#alerts
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */
    
    
    +function ($) {
      'use strict';
    
      // ALERT CLASS DEFINITION
      // ======================
    
      var dismiss = '[data-dismiss="alert"]'
      var Alert   = function (el) {
        $(el).on('click', dismiss, this.close)
      }
    
      Alert.VERSION = '3.3.7'
    
      Alert.TRANSITION_DURATION = 150
    
      Alert.prototype.close = function (e) {
        var $this    = $(this)
        var selector = $this.attr('data-target')
    
        if (!selector) {
          selector = $this.attr('href')
          selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
        }
    
        var $parent = $(selector === '#' ? [] : selector)
    
        if (e) e.preventDefault()
    
        if (!$parent.length) {
          $parent = $this.closest('.alert')
        }
    
        $parent.trigger(e = $.Event('close.bs.alert'))
    
        if (e.isDefaultPrevented()) return
    
        $parent.removeClass('in')
    
        function removeElement() {
          // detach from parent, fire event then clean up data
          $parent.detach().trigger('closed.bs.alert').remove()
        }
    
        $.support.transition && $parent.hasClass('fade') ?
          $parent
            .one('bsTransitionEnd', removeElement)
            .emulateTransitionEnd(Alert.TRANSITION_DURATION) :
          removeElement()
      }
    
    
      // ALERT PLUGIN DEFINITION
      // =======================
    
      function Plugin(option) {
        return this.each(function () {
          var $this = $(this)
          var data  = $this.data('bs.alert')
    
          if (!data) $this.data('bs.alert', (data = new Alert(this)))
          if (typeof option == 'string') data[option].call($this)
        })
      }
    
      var old = $.fn.alert
    
      $.fn.alert             = Plugin
      $.fn.alert.Constructor = Alert
    
    
      // ALERT NO CONFLICT
      // =================
    
      $.fn.alert.noConflict = function () {
        $.fn.alert = old
        return this
      }
    
    
      // ALERT DATA-API
      // ==============
    
      $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)
    
    }(jQuery);
    
    /* ========================================================================
     * Bootstrap: button.js v3.3.7
     * http://getbootstrap.com/javascript/#buttons
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */
    
    
    +function ($) {
      'use strict';
    
      // BUTTON PUBLIC CLASS DEFINITION
      // ==============================
    
      var Button = function (element, options) {
        this.$element  = $(element)
        this.options   = $.extend({}, Button.DEFAULTS, options)
        this.isLoading = false
      }
    
      Button.VERSION  = '3.3.7'
    
      Button.DEFAULTS = {
        loadingText: 'loading...'
      }
    
      Button.prototype.setState = function (state) {
        var d    = 'disabled'
        var $el  = this.$element
        var val  = $el.is('input') ? 'val' : 'html'
        var data = $el.data()
    
        state += 'Text'
    
        if (data.resetText == null) $el.data('resetText', $el[val]())
    
        // push to event loop to allow forms to submit
        setTimeout($.proxy(function () {
          $el[val](data[state] == null ? this.options[state] : data[state])
    
          if (state == 'loadingText') {
            this.isLoading = true
            $el.addClass(d).attr(d, d).prop(d, true)
          } else if (this.isLoading) {
            this.isLoading = false
            $el.removeClass(d).removeAttr(d).prop(d, false)
          }
        }, this), 0)
      }
    
      Button.prototype.toggle = function () {
        var changed = true
        var $parent = this.$element.closest('[data-toggle="buttons"]')
    
        if ($parent.length) {
          var $input = this.$element.find('input')
          if ($input.prop('type') == 'radio') {
            if ($input.prop('checked')) changed = false
            $parent.find('.active').removeClass('active')
            this.$element.addClass('active')
          } else if ($input.prop('type') == 'checkbox') {
            if (($input.prop('checked')) !== this.$element.hasClass('active')) changed = false
            this.$element.toggleClass('active')
          }
          $input.prop('checked', this.$element.hasClass('active'))
          if (changed) $input.trigger('change')
        } else {
          this.$element.attr('aria-pressed', !this.$element.hasClass('active'))
          this.$element.toggleClass('active')
        }
      }
    
    
      // BUTTON PLUGIN DEFINITION
      // ========================
    
      function Plugin(option) {
        return this.each(function () {
          var $this   = $(this)
          var data    = $this.data('bs.button')
          var options = typeof option == 'object' && option
    
          if (!data) $this.data('bs.button', (data = new Button(this, options)))
    
          if (option == 'toggle') data.toggle()
          else if (option) data.setState(option)
        })
      }
    
      var old = $.fn.button
    
      $.fn.button             = Plugin
      $.fn.button.Constructor = Button
    
    
      // BUTTON NO CONFLICT
      // ==================
    
      $.fn.button.noConflict = function () {
        $.fn.button = old
        return this
      }
    
    
      // BUTTON DATA-API
      // ===============
    
      $(document)
        .on('click.bs.button.data-api', '[data-toggle^="button"]', function (e) {
          var $btn = $(e.target).closest('.btn')
          Plugin.call($btn, 'toggle')
          if (!($(e.target).is('input[type="radio"], input[type="checkbox"]'))) {
            // Prevent double click on radios, and the double selections (so cancellation) on checkboxes
            e.preventDefault()
            // The target component still receive the focus
            if ($btn.is('input,button')) $btn.trigger('focus')
            else $btn.find('input:visible,button:visible').first().trigger('focus')
          }
        })
        .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function (e) {
          $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type))
        })
    
    }(jQuery);
    
    /* ========================================================================
     * Bootstrap: carousel.js v3.3.7
     * http://getbootstrap.com/javascript/#carousel
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */
    
    
    +function ($) {
      'use strict';
    
      // CAROUSEL CLASS DEFINITION
      // =========================
    
      var Carousel = function (element, options) {
        this.$element    = $(element)
        this.$indicators = this.$element.find('.carousel-indicators')
        this.options     = options
        this.paused      = null
        this.sliding     = null
        this.interval    = null
        this.$active     = null
        this.$items      = null
    
        this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))
    
        this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element
          .on('mouseenter.bs.carousel', $.proxy(this.pause, this))
          .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))
      }
    
      Carousel.VERSION  = '3.3.7'
    
      Carousel.TRANSITION_DURATION = 600
    
      Carousel.DEFAULTS = {
        interval: 5000,
        pause: 'hover',
        wrap: true,
        keyboard: true
      }
    
      Carousel.prototype.keydown = function (e) {
        if (/input|textarea/i.test(e.target.tagName)) return
        switch (e.which) {
          case 37: this.prev(); break
          case 39: this.next(); break
          default: return
        }
    
        e.preventDefault()
      }
    
      Carousel.prototype.cycle = function (e) {
        e || (this.paused = false)
    
        this.interval && clearInterval(this.interval)
    
        this.options.interval
          && !this.paused
          && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))
    
        return this
      }
    
      Carousel.prototype.getItemIndex = function (item) {
        this.$items = item.parent().children('.item')
        return this.$items.index(item || this.$active)
      }
    
      Carousel.prototype.getItemForDirection = function (direction, active) {
        var activeIndex = this.getItemIndex(active)
        var willWrap = (direction == 'prev' && activeIndex === 0)
                    || (direction == 'next' && activeIndex == (this.$items.length - 1))
        if (willWrap && !this.options.wrap) return active
        var delta = direction == 'prev' ? -1 : 1
        var itemIndex = (activeIndex + delta) % this.$items.length
        return this.$items.eq(itemIndex)
      }
    
      Carousel.prototype.to = function (pos) {
        var that        = this
        var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))
    
        if (pos > (this.$items.length - 1) || pos < 0) return
    
        if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, "slid"
        if (activeIndex == pos) return this.pause().cycle()
    
        return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))
      }
    
      Carousel.prototype.pause = function (e) {
        e || (this.paused = true)
    
        if (this.$element.find('.next, .prev').length && $.support.transition) {
          this.$element.trigger($.support.transition.end)
          this.cycle(true)
        }
    
        this.interval = clearInterval(this.interval)
    
        return this
      }
    
      Carousel.prototype.next = function () {
        if (this.sliding) return
        return this.slide('next')
      }
    
      Carousel.prototype.prev = function () {
        if (this.sliding) return
        return this.slide('prev')
      }
    
      Carousel.prototype.slide = function (type, next) {
        var $active   = this.$element.find('.item.active')
        var $next     = next || this.getItemForDirection(type, $active)
        var isCycling = this.interval
        var direction = type == 'next' ? 'left' : 'right'
        var that      = this
    
        if ($next.hasClass('active')) return (this.sliding = false)
    
        var relatedTarget = $next[0]
        var slideEvent = $.Event('slide.bs.carousel', {
          relatedTarget: relatedTarget,
          direction: direction
        })
        this.$element.trigger(slideEvent)
        if (slideEvent.isDefaultPrevented()) return
    
        this.sliding = true
    
        isCycling && this.pause()
    
        if (this.$indicators.length) {
          this.$indicators.find('.active').removeClass('active')
          var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
          $nextIndicator && $nextIndicator.addClass('active')
        }
    
        var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, "slid"
        if ($.support.transition && this.$element.hasClass('slide')) {
          $next.addClass(type)
          $next[0].offsetWidth // force reflow
          $active.addClass(direction)
          $next.addClass(direction)
          $active
            .one('bsTransitionEnd', function () {
              $next.removeClass([type, direction].join(' ')).addClass('active')
              $active.removeClass(['active', direction].join(' '))
              that.sliding = false
              setTimeout(function () {
                that.$element.trigger(slidEvent)
              }, 0)
            })
            .emulateTransitionEnd(Carousel.TRANSITION_DURATION)
        } else {
          $active.removeClass('active')
          $next.addClass('active')
          this.sliding = false
          this.$element.trigger(slidEvent)
        }
    
        isCycling && this.cycle()
    
        return this
      }
    
    
      // CAROUSEL PLUGIN DEFINITION
      // ==========================
    
      function Plugin(option) {
        return this.each(function () {
          var $this   = $(this)
          var data    = $this.data('bs.carousel')
          var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
          var action  = typeof option == 'string' ? option : options.slide
    
          if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
          if (typeof option == 'number') data.to(option)
          else if (action) data[action]()
          else if (options.interval) data.pause().cycle()
        })
      }
    
      var old = $.fn.carousel
    
      $.fn.carousel             = Plugin
      $.fn.carousel.Constructor = Carousel
    
    
      // CAROUSEL NO CONFLICT
      // ====================
    
      $.fn.carousel.noConflict = function () {
        $.fn.carousel = old
        return this
      }
    
    
      // CAROUSEL DATA-API
      // =================
    
      var clickHandler = function (e) {
        var href
        var $this   = $(this)
        var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) // strip for ie7
        if (!$target.hasClass('carousel')) return
        var options = $.extend({}, $target.data(), $this.data())
        var slideIndex = $this.attr('data-slide-to')
        if (slideIndex) options.interval = false
    
        Plugin.call($target, options)
    
        if (slideIndex) {
          $target.data('bs.carousel').to(slideIndex)
        }
    
        e.preventDefault()
      }
    
      $(document)
        .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)
        .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)
    
      $(window).on('load', function () {
        $('[data-ride="carousel"]').each(function () {
          var $carousel = $(this)
          Plugin.call($carousel, $carousel.data())
        })
      })
    
    }(jQuery);
    
    /* ========================================================================
     * Bootstrap: collapse.js v3.3.7
     * http://getbootstrap.com/javascript/#collapse
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */
    
    /* jshint latedef: false */
    
    +function ($) {
      'use strict';
    
      // COLLAPSE PUBLIC CLASS DEFINITION
      // ================================
    
      var Collapse = function (element, options) {
        this.$element      = $(element)
        this.options       = $.extend({}, Collapse.DEFAULTS, options)
        this.$trigger      = $('[data-toggle="collapse"][href="#' + element.id + '"],' +
                               '[data-toggle="collapse"][data-target="#' + element.id + '"]')
        this.transitioning = null
    
        if (this.options.parent) {
          this.$parent = this.getParent()
        } else {
          this.addAriaAndCollapsedClass(this.$element, this.$trigger)
        }
    
        if (this.options.toggle) this.toggle()
      }
    
      Collapse.VERSION  = '3.3.7'
    
      Collapse.TRANSITION_DURATION = 350
    
      Collapse.DEFAULTS = {
        toggle: true
      }
    
      Collapse.prototype.dimension = function () {
        var hasWidth = this.$element.hasClass('width')
        return hasWidth ? 'width' : 'height'
      }
    
      Collapse.prototype.show = function () {
        if (this.transitioning || this.$element.hasClass('in')) return
    
        var activesData
        var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing')
    
        if (actives && actives.length) {
          activesData = actives.data('bs.collapse')
          if (activesData && activesData.transitioning) return
        }
    
        var startEvent = $.Event('show.bs.collapse')
        this.$element.trigger(startEvent)
        if (startEvent.isDefaultPrevented()) return
    
        if (actives && actives.length) {
          Plugin.call(actives, 'hide')
          activesData || actives.data('bs.collapse', null)
        }
    
        var dimension = this.dimension()
    
        this.$element
          .removeClass('collapse')
          .addClass('collapsing')[dimension](0)
          .attr('aria-expanded', true)
    
        this.$trigger
          .removeClass('collapsed')
          .attr('aria-expanded', true)
    
        this.transitioning = 1
    
        var complete = function () {
          this.$element
            .removeClass('collapsing')
            .addClass('collapse in')[dimension]('')
          this.transitioning = 0
          this.$element
            .trigger('shown.bs.collapse')
        }
    
        if (!$.support.transition) return complete.call(this)
    
        var scrollSize = $.camelCase(['scroll', dimension].join('-'))
    
        this.$element
          .one('bsTransitionEnd', $.proxy(complete, this))
          .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
      }
    
      Collapse.prototype.hide = function () {
        if (this.transitioning || !this.$element.hasClass('in')) return
    
        var startEvent = $.Event('hide.bs.collapse')
        this.$element.trigger(startEvent)
        if (startEvent.isDefaultPrevented()) return
    
        var dimension = this.dimension()
    
        this.$element[dimension](this.$element[dimension]())[0].offsetHeight
    
        this.$element
          .addClass('collapsing')
          .removeClass('collapse in')
          .attr('aria-expanded', false)
    
        this.$trigger
          .addClass('collapsed')
          .attr('aria-expanded', false)
    
        this.transitioning = 1
    
        var complete = function () {
          this.transitioning = 0
          this.$element
            .removeClass('collapsing')
            .addClass('collapse')
            .trigger('hidden.bs.collapse')
        }
    
        if (!$.support.transition) return complete.call(this)
    
        this.$element
          [dimension](0)
          .one('bsTransitionEnd', $.proxy(complete, this))
          .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
      }
    
      Collapse.prototype.toggle = function () {
        this[this.$element.hasClass('in') ? 'hide' : 'show']()
      }
    
      Collapse.prototype.getParent = function () {
        return $(this.options.parent)
          .find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]')
          .each($.proxy(function (i, element) {
            var $element = $(element)
            this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
          }, this))
          .end()
      }
    
      Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
        var isOpen = $element.hasClass('in')
    
        $element.attr('aria-expanded', isOpen)
        $trigger
          .toggleClass('collapsed', !isOpen)
          .attr('aria-expanded', isOpen)
      }
    
      function getTargetFromTrigger($trigger) {
        var href
        var target = $trigger.attr('data-target')
          || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7
    
        return $(target)
      }
    
    
      // COLLAPSE PLUGIN DEFINITION
      // ==========================
    
      function Plugin(option) {
        return this.each(function () {
          var $this   = $(this)
          var data    = $this.data('bs.collapse')
          var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)
    
          if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false
          if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
          if (typeof option == 'string') data[option]()
        })
      }
    
      var old = $.fn.collapse
    
      $.fn.collapse             = Plugin
      $.fn.collapse.Constructor = Collapse
    
    
      // COLLAPSE NO CONFLICT
      // ====================
    
      $.fn.collapse.noConflict = function () {
        $.fn.collapse = old
        return this
      }
    
    
      // COLLAPSE DATA-API
      // =================
    
      $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
        var $this   = $(this)
    
        if (!$this.attr('data-target')) e.preventDefault()
    
        var $target = getTargetFromTrigger($this)
        var data    = $target.data('bs.collapse')
        var option  = data ? 'toggle' : $this.data()
    
        Plugin.call($target, option)
      })
    
    }(jQuery);
    
    /* ========================================================================
     * Bootstrap: dropdown.js v3.3.7
     * http://getbootstrap.com/javascript/#dropdowns
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */
    
    
    +function ($) {
      'use strict';
    
      // DROPDOWN CLASS DEFINITION
      // =========================
    
      var backdrop = '.dropdown-backdrop'
      var toggle   = '[data-toggle="dropdown"]'
      var Dropdown = function (element) {
        $(element).on('click.bs.dropdown', this.toggle)
      }
    
      Dropdown.VERSION = '3.3.7'
    
      function getParent($this) {
        var selector = $this.attr('data-target')
    
        if (!selector) {
          selector = $this.attr('href')
          selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
        }
    
        var $parent = selector && $(selector)
    
        return $parent && $parent.length ? $parent : $this.parent()
      }
    
      function clearMenus(e) {
        if (e && e.which === 3) return
        $(backdrop).remove()
        $(toggle).each(function () {
          var $this         = $(this)
          var $parent       = getParent($this)
          var relatedTarget = { relatedTarget: this }
    
          if (!$parent.hasClass('open')) return
    
          if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return
    
          $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))
    
          if (e.isDefaultPrevented()) return
    
          $this.attr('aria-expanded', 'false')
          $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget))
        })
      }
    
      Dropdown.prototype.toggle = function (e) {
        var $this = $(this)
    
        if ($this.is('.disabled, :disabled')) return
    
        var $parent  = getParent($this)
        var isActive = $parent.hasClass('open')
    
        clearMenus()
    
        if (!isActive) {
          if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
            // if mobile we use a backdrop because click events don't delegate
            $(document.createElement('div'))
              .addClass('dropdown-backdrop')
              .insertAfter($(this))
              .on('click', clearMenus)
          }
    
          var relatedTarget = { relatedTarget: this }
          $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))
    
          if (e.isDefaultPrevented()) return
    
          $this
            .trigger('focus')
            .attr('aria-expanded', 'true')
    
          $parent
            .toggleClass('open')
            .trigger($.Event('shown.bs.dropdown', relatedTarget))
        }
    
        return false
      }
    
      Dropdown.prototype.keydown = function (e) {
        if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return
    
        var $this = $(this)
    
        e.preventDefault()
        e.stopPropagation()
    
        if ($this.is('.disabled, :disabled')) return
    
        var $parent  = getParent($this)
        var isActive = $parent.hasClass('open')
    
        if (!isActive && e.which != 27 || isActive && e.which == 27) {
          if (e.which == 27) $parent.find(toggle).trigger('focus')
          return $this.trigger('click')
        }
    
        var desc = ' li:not(.disabled):visible a'
        var $items = $parent.find('.dropdown-menu' + desc)
    
        if (!$items.length) return
    
        var index = $items.index(e.target)
    
        if (e.which == 38 && index > 0)                 index--         // up
        if (e.which == 40 && index < $items.length - 1) index++         // down
        if (!~index)                                    index = 0
    
        $items.eq(index).trigger('focus')
      }
    
    
      // DROPDOWN PLUGIN DEFINITION
      // ==========================
    
      function Plugin(option) {
        return this.each(function () {
          var $this = $(this)
          var data  = $this.data('bs.dropdown')
    
          if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
          if (typeof option == 'string') data[option].call($this)
        })
      }
    
      var old = $.fn.dropdown
    
      $.fn.dropdown             = Plugin
      $.fn.dropdown.Constructor = Dropdown
    
    
      // DROPDOWN NO CONFLICT
      // ====================
    
      $.fn.dropdown.noConflict = function () {
        $.fn.dropdown = old
        return this
      }
    
    
      // APPLY TO STANDARD DROPDOWN ELEMENTS
      // ===================================
    
      $(document)
        .on('click.bs.dropdown.data-api', clearMenus)
        .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
        .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
        .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
        .on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown)
    
    }(jQuery);
    
    /* ========================================================================
     * Bootstrap: modal.js v3.3.7
     * http://getbootstrap.com/javascript/#modals
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */
    
    
    +function ($) {
      'use strict';
    
      // MODAL CLASS DEFINITION
      // ======================
    
      var Modal = function (element, options) {
        this.options             = options
        this.$body               = $(document.body)
        this.$element            = $(element)
        this.$dialog             = this.$element.find('.modal-dialog')
        this.$backdrop           = null
        this.isShown             = null
        this.originalBodyPad     = null
        this.scrollbarWidth      = 0
        this.ignoreBackdropClick = false
    
        if (this.options.remote) {
          this.$element
            .find('.modal-content')
            .load(this.options.remote, $.proxy(function () {
              this.$element.trigger('loaded.bs.modal')
            }, this))
        }
      }
    
      Modal.VERSION  = '3.3.7'
    
      Modal.TRANSITION_DURATION = 300
      Modal.BACKDROP_TRANSITION_DURATION = 150
    
      Modal.DEFAULTS = {
        backdrop: true,
        keyboard: true,
        show: true
      }
    
      Modal.prototype.toggle = function (_relatedTarget) {
        return this.isShown ? this.hide() : this.show(_relatedTarget)
      }
    
      Modal.prototype.show = function (_relatedTarget) {
        var that = this
        var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })
    
        this.$element.trigger(e)
    
        if (this.isShown || e.isDefaultPrevented()) return
    
        this.isShown = true
    
        this.checkScrollbar()
        this.setScrollbar()
        this.$body.addClass('modal-open')
    
        this.escape()
        this.resize()
    
        this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))
    
        this.$dialog.on('mousedown.dismiss.bs.modal', function () {
          that.$element.one('mouseup.dismiss.bs.modal', function (e) {
            if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true
          })
        })
    
        this.backdrop(function () {
          var transition = $.support.transition && that.$element.hasClass('fade')
    
          if (!that.$element.parent().length) {
            that.$element.appendTo(that.$body) // don't move modals dom position
          }
    
          that.$element
            .show()
            .scrollTop(0)
    
          that.adjustDialog()
    
          if (transition) {
            that.$element[0].offsetWidth // force reflow
          }
    
          that.$element.addClass('in')
    
          that.enforceFocus()
    
          var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })
    
          transition ?
            that.$dialog // wait for modal to slide in
              .one('bsTransitionEnd', function () {
                that.$element.trigger('focus').trigger(e)
              })
              .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
            that.$element.trigger('focus').trigger(e)
        })
      }
    
      Modal.prototype.hide = function (e) {
        if (e) e.preventDefault()
    
        e = $.Event('hide.bs.modal')
    
        this.$element.trigger(e)
    
        if (!this.isShown || e.isDefaultPrevented()) return
    
        this.isShown = false
    
        this.escape()
        this.resize()
    
        $(document).off('focusin.bs.modal')
    
        this.$element
          .removeClass('in')
          .off('click.dismiss.bs.modal')
          .off('mouseup.dismiss.bs.modal')
    
        this.$dialog.off('mousedown.dismiss.bs.modal')
    
        $.support.transition && this.$element.hasClass('fade') ?
          this.$element
            .one('bsTransitionEnd', $.proxy(this.hideModal, this))
            .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
          this.hideModal()
      }
    
      Modal.prototype.enforceFocus = function () {
        $(document)
          .off('focusin.bs.modal') // guard against infinite focus loop
          .on('focusin.bs.modal', $.proxy(function (e) {
            if (document !== e.target &&
                this.$element[0] !== e.target &&
                !this.$element.has(e.target).length) {
              this.$element.trigger('focus')
            }
          }, this))
      }
    
      Modal.prototype.escape = function () {
        if (this.isShown && this.options.keyboard) {
          this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
            e.which == 27 && this.hide()
          }, this))
        } else if (!this.isShown) {
          this.$element.off('keydown.dismiss.bs.modal')
        }
      }
    
      Modal.prototype.resize = function () {
        if (this.isShown) {
          $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))
        } else {
          $(window).off('resize.bs.modal')
        }
      }
    
      Modal.prototype.hideModal = function () {
        var that = this
        this.$element.hide()
        this.backdrop(function () {
          that.$body.removeClass('modal-open')
          that.resetAdjustments()
          that.resetScrollbar()
          that.$element.trigger('hidden.bs.modal')
        })
      }
    
      Modal.prototype.removeBackdrop = function () {
        this.$backdrop && this.$backdrop.remove()
        this.$backdrop = null
      }
    
      Modal.prototype.backdrop = function (callback) {
        var that = this
        var animate = this.$element.hasClass('fade') ? 'fade' : ''
    
        if (this.isShown && this.options.backdrop) {
          var doAnimate = $.support.transition && animate
    
          this.$backdrop = $(document.createElement('div'))
            .addClass('modal-backdrop ' + animate)
            .appendTo(this.$body)
    
          this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
            if (this.ignoreBackdropClick) {
              this.ignoreBackdropClick = false
              return
            }
            if (e.target !== e.currentTarget) return
            this.options.backdrop == 'static'
              ? this.$element[0].focus()
              : this.hide()
          }, this))
    
          if (doAnimate) this.$backdrop[0].offsetWidth // force reflow
    
          this.$backdrop.addClass('in')
    
          if (!callback) return
    
          doAnimate ?
            this.$backdrop
              .one('bsTransitionEnd', callback)
              .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
            callback()
    
        } else if (!this.isShown && this.$backdrop) {
          this.$backdrop.removeClass('in')
    
          var callbackRemove = function () {
            that.removeBackdrop()
            callback && callback()
          }
          $.support.transition && this.$element.hasClass('fade') ?
            this.$backdrop
              .one('bsTransitionEnd', callbackRemove)
              .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
            callbackRemove()
    
        } else if (callback) {
          callback()
        }
      }
    
      // these following methods are used to handle overflowing modals
    
      Modal.prototype.handleUpdate = function () {
        this.adjustDialog()
      }
    
      Modal.prototype.adjustDialog = function () {
        var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight
    
        this.$element.css({
          paddingLeft:  !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
          paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
        })
      }
    
      Modal.prototype.resetAdjustments = function () {
        this.$element.css({
          paddingLeft: '',
          paddingRight: ''
        })
      }
    
      Modal.prototype.checkScrollbar = function () {
        var fullWindowWidth = window.innerWidth
        if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8
          var documentElementRect = document.documentElement.getBoundingClientRect()
          fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)
        }
        this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth
        this.scrollbarWidth = this.measureScrollbar()
      }
    
      Modal.prototype.setScrollbar = function () {
        var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
        this.originalBodyPad = document.body.style.paddingRight || ''
        if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
      }
    
      Modal.prototype.resetScrollbar = function () {
        this.$body.css('padding-right', this.originalBodyPad)
      }
    
      Modal.prototype.measureScrollbar = function () { // thx walsh
        var scrollDiv = document.createElement('div')
        scrollDiv.className = 'modal-scrollbar-measure'
        this.$body.append(scrollDiv)
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
        this.$body[0].removeChild(scrollDiv)
        return scrollbarWidth
      }
    
    
      // MODAL PLUGIN DEFINITION
      // =======================
    
      function Plugin(option, _relatedTarget) {
        return this.each(function () {
          var $this   = $(this)
          var data    = $this.data('bs.modal')
          var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)
    
          if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
          if (typeof option == 'string') data[option](_relatedTarget)
          else if (options.show) data.show(_relatedTarget)
        })
      }
    
      var old = $.fn.modal
    
      $.fn.modal             = Plugin
      $.fn.modal.Constructor = Modal
    
    
      // MODAL NO CONFLICT
      // =================
    
      $.fn.modal.noConflict = function () {
        $.fn.modal = old
        return this
      }
    
    
      // MODAL DATA-API
      // ==============
    
      $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
        var $this   = $(this)
        var href    = $this.attr('href')
        var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) // strip for ie7
        var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())
    
        if ($this.is('a')) e.preventDefault()
    
        $target.one('show.bs.modal', function (showEvent) {
          if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
          $target.one('hidden.bs.modal', function () {
            $this.is(':visible') && $this.trigger('focus')
          })
        })
        Plugin.call($target, option, this)
      })
    
    }(jQuery);
    
    /* ========================================================================
     * Bootstrap: tooltip.js v3.3.7
     * http://getbootstrap.com/javascript/#tooltip
     * Inspired by the original jQuery.tipsy by Jason Frame
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */
    
    
    +function ($) {
      'use strict';
    
      // TOOLTIP PUBLIC CLASS DEFINITION
      // ===============================
    
      var Tooltip = function (element, options) {
        this.type       = null
        this.options    = null
        this.enabled    = null
        this.timeout    = null
        this.hoverState = null
        this.$element   = null
        this.inState    = null
    
        this.init('tooltip', element, options)
      }
    
      Tooltip.VERSION  = '3.3.7'
    
      Tooltip.TRANSITION_DURATION = 150
    
      Tooltip.DEFAULTS = {
        animation: true,
        placement: 'top',
        selector: false,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: 'hover focus',
        title: '',
        delay: 0,
        html: false,
        container: false,
        viewport: {
          selector: 'body',
          padding: 0
        }
      }
    
      Tooltip.prototype.init = function (type, element, options) {
        this.enabled   = true
        this.type      = type
        this.$element  = $(element)
        this.options   = this.getOptions(options)
        this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport))
        this.inState   = { click: false, hover: false, focus: false }
    
        if (this.$element[0] instanceof document.constructor && !this.options.selector) {
          throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!')
        }
    
        var triggers = this.options.trigger.split(' ')
    
        for (var i = triggers.length; i--;) {
          var trigger = triggers[i]
    
          if (trigger == 'click') {
            this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
          } else if (trigger != 'manual') {
            var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'
            var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'
    
            this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
            this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
          }
        }
    
        this.options.selector ?
          (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
          this.fixTitle()
      }
    
      Tooltip.prototype.getDefaults = function () {
        return Tooltip.DEFAULTS
      }
    
      Tooltip.prototype.getOptions = function (options) {
        options = $.extend({}, this.getDefaults(), this.$element.data(), options)
    
        if (options.delay && typeof options.delay == 'number') {
          options.delay = {
            show: options.delay,
            hide: options.delay
          }
        }
    
        return options
      }
    
      Tooltip.prototype.getDelegateOptions = function () {
        var options  = {}
        var defaults = this.getDefaults()
    
        this._options && $.each(this._options, function (key, value) {
          if (defaults[key] != value) options[key] = value
        })
    
        return options
      }
    
      Tooltip.prototype.enter = function (obj) {
        var self = obj instanceof this.constructor ?
          obj : $(obj.currentTarget).data('bs.' + this.type)
    
        if (!self) {
          self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
          $(obj.currentTarget).data('bs.' + this.type, self)
        }
    
        if (obj instanceof $.Event) {
          self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true
        }
    
        if (self.tip().hasClass('in') || self.hoverState == 'in') {
          self.hoverState = 'in'
          return
        }
    
        clearTimeout(self.timeout)
    
        self.hoverState = 'in'
    
        if (!self.options.delay || !self.options.delay.show) return self.show()
    
        self.timeout = setTimeout(function () {
          if (self.hoverState == 'in') self.show()
        }, self.options.delay.show)
      }
    
      Tooltip.prototype.isInStateTrue = function () {
        for (var key in this.inState) {
          if (this.inState[key]) return true
        }
    
        return false
      }
    
      Tooltip.prototype.leave = function (obj) {
        var self = obj instanceof this.constructor ?
          obj : $(obj.currentTarget).data('bs.' + this.type)
    
        if (!self) {
          self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
          $(obj.currentTarget).data('bs.' + this.type, self)
        }
    
        if (obj instanceof $.Event) {
          self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false
        }
    
        if (self.isInStateTrue()) return
    
        clearTimeout(self.timeout)
    
        self.hoverState = 'out'
    
        if (!self.options.delay || !self.options.delay.hide) return self.hide()
    
        self.timeout = setTimeout(function () {
          if (self.hoverState == 'out') self.hide()
        }, self.options.delay.hide)
      }
    
      Tooltip.prototype.show = function () {
        var e = $.Event('show.bs.' + this.type)
    
        if (this.hasContent() && this.enabled) {
          this.$element.trigger(e)
    
          var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
          if (e.isDefaultPrevented() || !inDom) return
          var that = this
    
          var $tip = this.tip()
    
          var tipId = this.getUID(this.type)
    
          this.setContent()
          $tip.attr('id', tipId)
          this.$element.attr('aria-describedby', tipId)
    
          if (this.options.animation) $tip.addClass('fade')
    
          var placement = typeof this.options.placement == 'function' ?
            this.options.placement.call(this, $tip[0], this.$element[0]) :
            this.options.placement
    
          var autoToken = /\s?auto?\s?/i
          var autoPlace = autoToken.test(placement)
          if (autoPlace) placement = placement.replace(autoToken, '') || 'top'
    
          $tip
            .detach()
            .css({ top: 0, left: 0, display: 'block' })
            .addClass(placement)
            .data('bs.' + this.type, this)
    
          this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)
          this.$element.trigger('inserted.bs.' + this.type)
    
          var pos          = this.getPosition()
          var actualWidth  = $tip[0].offsetWidth
          var actualHeight = $tip[0].offsetHeight
    
          if (autoPlace) {
            var orgPlacement = placement
            var viewportDim = this.getPosition(this.$viewport)
    
            placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top'    :
                        placement == 'top'    && pos.top    - actualHeight < viewportDim.top    ? 'bottom' :
                        placement == 'right'  && pos.right  + actualWidth  > viewportDim.width  ? 'left'   :
                        placement == 'left'   && pos.left   - actualWidth  < viewportDim.left   ? 'right'  :
                        placement
    
            $tip
              .removeClass(orgPlacement)
              .addClass(placement)
          }
    
          var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)
    
          this.applyPlacement(calculatedOffset, placement)
    
          var complete = function () {
            var prevHoverState = that.hoverState
            that.$element.trigger('shown.bs.' + that.type)
            that.hoverState = null
    
            if (prevHoverState == 'out') that.leave(that)
          }
    
          $.support.transition && this.$tip.hasClass('fade') ?
            $tip
              .one('bsTransitionEnd', complete)
              .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
            complete()
        }
      }
    
      Tooltip.prototype.applyPlacement = function (offset, placement) {
        var $tip   = this.tip()
        var width  = $tip[0].offsetWidth
        var height = $tip[0].offsetHeight
    
        // manually read margins because getBoundingClientRect includes difference
        var marginTop = parseInt($tip.css('margin-top'), 10)
        var marginLeft = parseInt($tip.css('margin-left'), 10)
    
        // we must check for NaN for ie 8/9
        if (isNaN(marginTop))  marginTop  = 0
        if (isNaN(marginLeft)) marginLeft = 0
    
        offset.top  += marginTop
        offset.left += marginLeft
    
        // $.fn.offset doesn't round pixel values
        // so we use setOffset directly with our own function B-0
        $.offset.setOffset($tip[0], $.extend({
          using: function (props) {
            $tip.css({
              top: Math.round(props.top),
              left: Math.round(props.left)
            })
          }
        }, offset), 0)
    
        $tip.addClass('in')
    
        // check to see if placing tip in new offset caused the tip to resize itself
        var actualWidth  = $tip[0].offsetWidth
        var actualHeight = $tip[0].offsetHeight
    
        if (placement == 'top' && actualHeight != height) {
          offset.top = offset.top + height - actualHeight
        }
    
        var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)
    
        if (delta.left) offset.left += delta.left
        else offset.top += delta.top
    
        var isVertical          = /top|bottom/.test(placement)
        var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
        var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'
    
        $tip.offset(offset)
        this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
      }
    
      Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {
        this.arrow()
          .css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
          .css(isVertical ? 'top' : 'left', '')
      }
    
      Tooltip.prototype.setContent = function () {
        var $tip  = this.tip()
        var title = this.getTitle()
    
        $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
        $tip.removeClass('fade in top bottom left right')
      }
    
      Tooltip.prototype.hide = function (callback) {
        var that = this
        var $tip = $(this.$tip)
        var e    = $.Event('hide.bs.' + this.type)
    
        function complete() {
          if (that.hoverState != 'in') $tip.detach()
          if (that.$element) { // TODO: Check whether guarding this code with this `if` is really necessary.
            that.$element
              .removeAttr('aria-describedby')
              .trigger('hidden.bs.' + that.type)
          }
          callback && callback()
        }
    
        this.$element.trigger(e)
    
        if (e.isDefaultPrevented()) return
    
        $tip.removeClass('in')
    
        $.support.transition && $tip.hasClass('fade') ?
          $tip
            .one('bsTransitionEnd', complete)
            .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
          complete()
    
        this.hoverState = null
    
        return this
      }
    
      Tooltip.prototype.fixTitle = function () {
        var $e = this.$element
        if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
          $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
        }
      }
    
      Tooltip.prototype.hasContent = function () {
        return this.getTitle()
      }
    
      Tooltip.prototype.getPosition = function ($element) {
        $element   = $element || this.$element
    
        var el     = $element[0]
        var isBody = el.tagName == 'BODY'
    
        var elRect    = el.getBoundingClientRect()
        if (elRect.width == null) {
          // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
          elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })
        }
        var isSvg = window.SVGElement && el instanceof window.SVGElement
        // Avoid using $.offset() on SVGs since it gives incorrect results in jQuery 3.
        // See https://github.com/twbs/bootstrap/issues/20280
        var elOffset  = isBody ? { top: 0, left: 0 } : (isSvg ? null : $element.offset())
        var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }
        var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null
    
        return $.extend({}, elRect, scroll, outerDims, elOffset)
      }
    
      Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
        return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2 } :
               placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } :
               placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
            /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width }
    
      }
    
      Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
        var delta = { top: 0, left: 0 }
        if (!this.$viewport) return delta
    
        var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
        var viewportDimensions = this.getPosition(this.$viewport)
    
        if (/right|left/.test(placement)) {
          var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll
          var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
          if (topEdgeOffset < viewportDimensions.top) { // top overflow
            delta.top = viewportDimensions.top - topEdgeOffset
          } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow
            delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
          }
        } else {
          var leftEdgeOffset  = pos.left - viewportPadding
          var rightEdgeOffset = pos.left + viewportPadding + actualWidth
          if (leftEdgeOffset < viewportDimensions.left) { // left overflow
            delta.left = viewportDimensions.left - leftEdgeOffset
          } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow
            delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
          }
        }
    
        return delta
      }
    
      Tooltip.prototype.getTitle = function () {
        var title
        var $e = this.$element
        var o  = this.options
    
        title = $e.attr('data-original-title')
          || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)
    
        return title
      }
    
      Tooltip.prototype.getUID = function (prefix) {
        do prefix += ~~(Math.random() * 1000000)
        while (document.getElementById(prefix))
        return prefix
      }
    
      Tooltip.prototype.tip = function () {
        if (!this.$tip) {
          this.$tip = $(this.options.template)
          if (this.$tip.length != 1) {
            throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!')
          }
        }
        return this.$tip
      }
    
      Tooltip.prototype.arrow = function () {
        return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
      }
    
      Tooltip.prototype.enable = function () {
        this.enabled = true
      }
    
      Tooltip.prototype.disable = function () {
        this.enabled = false
      }
    
      Tooltip.prototype.toggleEnabled = function () {
        this.enabled = !this.enabled
      }
    
      Tooltip.prototype.toggle = function (e) {
        var self = this
        if (e) {
          self = $(e.currentTarget).data('bs.' + this.type)
          if (!self) {
            self = new this.constructor(e.currentTarget, this.getDelegateOptions())
            $(e.currentTarget).data('bs.' + this.type, self)
          }
        }
    
        if (e) {
          self.inState.click = !self.inState.click
          if (self.isInStateTrue()) self.enter(self)
          else self.leave(self)
        } else {
          self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
        }
      }
    
      Tooltip.prototype.destroy = function () {
        var that = this
        clearTimeout(this.timeout)
        this.hide(function () {
          that.$element.off('.' + that.type).removeData('bs.' + that.type)
          if (that.$tip) {
            that.$tip.detach()
          }
          that.$tip = null
          that.$arrow = null
          that.$viewport = null
          that.$element = null
        })
      }
    
    
      // TOOLTIP PLUGIN DEFINITION
      // =========================
    
      function Plugin(option) {
        return this.each(function () {
          var $this   = $(this)
          var data    = $this.data('bs.tooltip')
          var options = typeof option == 'object' && option
    
          if (!data && /destroy|hide/.test(option)) return
          if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
          if (typeof option == 'string') data[option]()
        })
      }
    
      var old = $.fn.tooltip
    
      $.fn.tooltip             = Plugin
      $.fn.tooltip.Constructor = Tooltip
    
    
      // TOOLTIP NO CONFLICT
      // ===================
    
      $.fn.tooltip.noConflict = function () {
        $.fn.tooltip = old
        return this
      }
    
    }(jQuery);
    
    /* ========================================================================
     * Bootstrap: popover.js v3.3.7
     * http://getbootstrap.com/javascript/#popovers
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */
    
    
    +function ($) {
      'use strict';
    
      // POPOVER PUBLIC CLASS DEFINITION
      // ===============================
    
      var Popover = function (element, options) {
        this.init('popover', element, options)
      }
    
      if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')
    
      Popover.VERSION  = '3.3.7'
    
      Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
        placement: 'right',
        trigger: 'click',
        content: '',
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
      })
    
    
      // NOTE: POPOVER EXTENDS tooltip.js
      // ================================
    
      Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)
    
      Popover.prototype.constructor = Popover
    
      Popover.prototype.getDefaults = function () {
        return Popover.DEFAULTS
      }
    
      Popover.prototype.setContent = function () {
        var $tip    = this.tip()
        var title   = this.getTitle()
        var content = this.getContent()
    
        $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
        $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events
          this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
        ](content)
    
        $tip.removeClass('fade top bottom left right in')
    
        // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
        // this manually by checking the contents.
        if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
      }
    
      Popover.prototype.hasContent = function () {
        return this.getTitle() || this.getContent()
      }
    
      Popover.prototype.getContent = function () {
        var $e = this.$element
        var o  = this.options
    
        return $e.attr('data-content')
          || (typeof o.content == 'function' ?
                o.content.call($e[0]) :
                o.content)
      }
    
      Popover.prototype.arrow = function () {
        return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
      }
    
    
      // POPOVER PLUGIN DEFINITION
      // =========================
    
      function Plugin(option) {
        return this.each(function () {
          var $this   = $(this)
          var data    = $this.data('bs.popover')
          var options = typeof option == 'object' && option
    
          if (!data && /destroy|hide/.test(option)) return
          if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
          if (typeof option == 'string') data[option]()
        })
      }
    
      var old = $.fn.popover
    
      $.fn.popover             = Plugin
      $.fn.popover.Constructor = Popover
    
    
      // POPOVER NO CONFLICT
      // ===================
    
      $.fn.popover.noConflict = function () {
        $.fn.popover = old
        return this
      }
    
    }(jQuery);
    
    /* ========================================================================
     * Bootstrap: scrollspy.js v3.3.7
     * http://getbootstrap.com/javascript/#scrollspy
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */
    
    
    +function ($) {
      'use strict';
    
      // SCROLLSPY CLASS DEFINITION
      // ==========================
    
      function ScrollSpy(element, options) {
        this.$body          = $(document.body)
        this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)
        this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)
        this.selector       = (this.options.target || '') + ' .nav li > a'
        this.offsets        = []
        this.targets        = []
        this.activeTarget   = null
        this.scrollHeight   = 0
    
        this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this))
        this.refresh()
        this.process()
      }
    
      ScrollSpy.VERSION  = '3.3.7'
    
      ScrollSpy.DEFAULTS = {
        offset: 10
      }
    
      ScrollSpy.prototype.getScrollHeight = function () {
        return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
      }
    
      ScrollSpy.prototype.refresh = function () {
        var that          = this
        var offsetMethod  = 'offset'
        var offsetBase    = 0
    
        this.offsets      = []
        this.targets      = []
        this.scrollHeight = this.getScrollHeight()
    
        if (!$.isWindow(this.$scrollElement[0])) {
          offsetMethod = 'position'
          offsetBase   = this.$scrollElement.scrollTop()
        }
    
        this.$body
          .find(this.selector)
          .map(function () {
            var $el   = $(this)
            var href  = $el.data('target') || $el.attr('href')
            var $href = /^#./.test(href) && $(href)
    
            return ($href
              && $href.length
              && $href.is(':visible')
              && [[$href[offsetMethod]().top + offsetBase, href]]) || null
          })
          .sort(function (a, b) { return a[0] - b[0] })
          .each(function () {
            that.offsets.push(this[0])
            that.targets.push(this[1])
          })
      }
    
      ScrollSpy.prototype.process = function () {
        var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
        var scrollHeight = this.getScrollHeight()
        var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()
        var offsets      = this.offsets
        var targets      = this.targets
        var activeTarget = this.activeTarget
        var i
    
        if (this.scrollHeight != scrollHeight) {
          this.refresh()
        }
    
        if (scrollTop >= maxScroll) {
          return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)
        }
    
        if (activeTarget && scrollTop < offsets[0]) {
          this.activeTarget = null
          return this.clear()
        }
    
        for (i = offsets.length; i--;) {
          activeTarget != targets[i]
            && scrollTop >= offsets[i]
            && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1])
            && this.activate(targets[i])
        }
      }
    
      ScrollSpy.prototype.activate = function (target) {
        this.activeTarget = target
    
        this.clear()
    
        var selector = this.selector +
          '[data-target="' + target + '"],' +
          this.selector + '[href="' + target + '"]'
    
        var active = $(selector)
          .parents('li')
          .addClass('active')
    
        if (active.parent('.dropdown-menu').length) {
          active = active
            .closest('li.dropdown')
            .addClass('active')
        }
    
        active.trigger('activate.bs.scrollspy')
      }
    
      ScrollSpy.prototype.clear = function () {
        $(this.selector)
          .parentsUntil(this.options.target, '.active')
          .removeClass('active')
      }
    
    
      // SCROLLSPY PLUGIN DEFINITION
      // ===========================
    
      function Plugin(option) {
        return this.each(function () {
          var $this   = $(this)
          var data    = $this.data('bs.scrollspy')
          var options = typeof option == 'object' && option
    
          if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
          if (typeof option == 'string') data[option]()
        })
      }
    
      var old = $.fn.scrollspy
    
      $.fn.scrollspy             = Plugin
      $.fn.scrollspy.Constructor = ScrollSpy
    
    
      // SCROLLSPY NO CONFLICT
      // =====================
    
      $.fn.scrollspy.noConflict = function () {
        $.fn.scrollspy = old
        return this
      }
    
    
      // SCROLLSPY DATA-API
      // ==================
    
      $(window).on('load.bs.scrollspy.data-api', function () {
        $('[data-spy="scroll"]').each(function () {
          var $spy = $(this)
          Plugin.call($spy, $spy.data())
        })
      })
    
    }(jQuery);
    
    /* ========================================================================
     * Bootstrap: tab.js v3.3.7
     * http://getbootstrap.com/javascript/#tabs
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */
    
    
    +function ($) {
      'use strict';
    
      // TAB CLASS DEFINITION
      // ====================
    
      var Tab = function (element) {
        // jscs:disable requireDollarBeforejQueryAssignment
        this.element = $(element)
        // jscs:enable requireDollarBeforejQueryAssignment
      }
    
      Tab.VERSION = '3.3.7'
    
      Tab.TRANSITION_DURATION = 150
    
      Tab.prototype.show = function () {
        var $this    = this.element
        var $ul      = $this.closest('ul:not(.dropdown-menu)')
        var selector = $this.data('target')
    
        if (!selector) {
          selector = $this.attr('href')
          selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
        }
    
        if ($this.parent('li').hasClass('active')) return
    
        var $previous = $ul.find('.active:last a')
        var hideEvent = $.Event('hide.bs.tab', {
          relatedTarget: $this[0]
        })
        var showEvent = $.Event('show.bs.tab', {
          relatedTarget: $previous[0]
        })
    
        $previous.trigger(hideEvent)
        $this.trigger(showEvent)
    
        if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return
    
        var $target = $(selector)
    
        this.activate($this.closest('li'), $ul)
        this.activate($target, $target.parent(), function () {
          $previous.trigger({
            type: 'hidden.bs.tab',
            relatedTarget: $this[0]
          })
          $this.trigger({
            type: 'shown.bs.tab',
            relatedTarget: $previous[0]
          })
        })
      }
    
      Tab.prototype.activate = function (element, container, callback) {
        var $active    = container.find('> .active')
        var transition = callback
          && $.support.transition
          && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length)
    
        function next() {
          $active
            .removeClass('active')
            .find('> .dropdown-menu > .active')
              .removeClass('active')
            .end()
            .find('[data-toggle="tab"]')
              .attr('aria-expanded', false)
    
          element
            .addClass('active')
            .find('[data-toggle="tab"]')
              .attr('aria-expanded', true)
    
          if (transition) {
            element[0].offsetWidth // reflow for transition
            element.addClass('in')
          } else {
            element.removeClass('fade')
          }
    
          if (element.parent('.dropdown-menu').length) {
            element
              .closest('li.dropdown')
                .addClass('active')
              .end()
              .find('[data-toggle="tab"]')
                .attr('aria-expanded', true)
          }
    
          callback && callback()
        }
    
        $active.length && transition ?
          $active
            .one('bsTransitionEnd', next)
            .emulateTransitionEnd(Tab.TRANSITION_DURATION) :
          next()
    
        $active.removeClass('in')
      }
    
    
      // TAB PLUGIN DEFINITION
      // =====================
    
      function Plugin(option) {
        return this.each(function () {
          var $this = $(this)
          var data  = $this.data('bs.tab')
    
          if (!data) $this.data('bs.tab', (data = new Tab(this)))
          if (typeof option == 'string') data[option]()
        })
      }
    
      var old = $.fn.tab
    
      $.fn.tab             = Plugin
      $.fn.tab.Constructor = Tab
    
    
      // TAB NO CONFLICT
      // ===============
    
      $.fn.tab.noConflict = function () {
        $.fn.tab = old
        return this
      }
    
    
      // TAB DATA-API
      // ============
    
      var clickHandler = function (e) {
        e.preventDefault()
        Plugin.call($(this), 'show')
      }
    
      $(document)
        .on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler)
        .on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler)
    
    }(jQuery);
    
    /* ========================================================================
     * Bootstrap: affix.js v3.3.7
     * http://getbootstrap.com/javascript/#affix
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */
    
    
    +function ($) {
      'use strict';
    
      // AFFIX CLASS DEFINITION
      // ======================
    
      var Affix = function (element, options) {
        this.options = $.extend({}, Affix.DEFAULTS, options)
    
        this.$target = $(this.options.target)
          .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
          .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))
    
        this.$element     = $(element)
        this.affixed      = null
        this.unpin        = null
        this.pinnedOffset = null
    
        this.checkPosition()
      }
    
      Affix.VERSION  = '3.3.7'
    
      Affix.RESET    = 'affix affix-top affix-bottom'
    
      Affix.DEFAULTS = {
        offset: 0,
        target: window
      }
    
      Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
        var scrollTop    = this.$target.scrollTop()
        var position     = this.$element.offset()
        var targetHeight = this.$target.height()
    
        if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false
    
        if (this.affixed == 'bottom') {
          if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'
          return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'
        }
    
        var initializing   = this.affixed == null
        var colliderTop    = initializing ? scrollTop : position.top
        var colliderHeight = initializing ? targetHeight : height
    
        if (offsetTop != null && scrollTop <= offsetTop) return 'top'
        if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'
    
        return false
      }
    
      Affix.prototype.getPinnedOffset = function () {
        if (this.pinnedOffset) return this.pinnedOffset
        this.$element.removeClass(Affix.RESET).addClass('affix')
        var scrollTop = this.$target.scrollTop()
        var position  = this.$element.offset()
        return (this.pinnedOffset = position.top - scrollTop)
      }
    
      Affix.prototype.checkPositionWithEventLoop = function () {
        setTimeout($.proxy(this.checkPosition, this), 1)
      }
    
      Affix.prototype.checkPosition = function () {
        if (!this.$element.is(':visible')) return
    
        var height       = this.$element.height()
        var offset       = this.options.offset
        var offsetTop    = offset.top
        var offsetBottom = offset.bottom
        var scrollHeight = Math.max($(document).height(), $(document.body).height())
    
        if (typeof offset != 'object')         offsetBottom = offsetTop = offset
        if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)
        if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)
    
        var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)
    
        if (this.affixed != affix) {
          if (this.unpin != null) this.$element.css('top', '')
    
          var affixType = 'affix' + (affix ? '-' + affix : '')
          var e         = $.Event(affixType + '.bs.affix')
    
          this.$element.trigger(e)
    
          if (e.isDefaultPrevented()) return
    
          this.affixed = affix
          this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null
    
          this.$element
            .removeClass(Affix.RESET)
            .addClass(affixType)
            .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')
        }
    
        if (affix == 'bottom') {
          this.$element.offset({
            top: scrollHeight - height - offsetBottom
          })
        }
      }
    
    
      // AFFIX PLUGIN DEFINITION
      // =======================
    
      function Plugin(option) {
        return this.each(function () {
          var $this   = $(this)
          var data    = $this.data('bs.affix')
          var options = typeof option == 'object' && option
    
          if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
          if (typeof option == 'string') data[option]()
        })
      }
    
      var old = $.fn.affix
    
      $.fn.affix             = Plugin
      $.fn.affix.Constructor = Affix
    
    
      // AFFIX NO CONFLICT
      // =================
    
      $.fn.affix.noConflict = function () {
        $.fn.affix = old
        return this
      }
    
    
      // AFFIX DATA-API
      // ==============
    
      $(window).on('load', function () {
        $('[data-spy="affix"]').each(function () {
          var $spy = $(this)
          var data = $spy.data()
    
          data.offset = data.offset || {}
    
          if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
          if (data.offsetTop    != null) data.offset.top    = data.offsetTop
    
          Plugin.call($spy, data)
        })
      })
    
    }(jQuery);
    
    ; browserify_shim__define__module__export__(typeof bootstrap != "undefined" ? bootstrap : window.bootstrap);
    
    }).call(global, undefined, undefined, undefined, undefined, function defineExport(ex) { module.exports = ex; });
    
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    },{"jQuery":60}],52:[function(require,module,exports){
    (function (global){
    
    ; $ = global.$ = require("jQuery");
    ; var __browserify_shim_require__=require;(function browserifyShim(module, exports, require, define, browserify_shim__define__module__export__) {
    /**
     * bxSlider v4.2.12
     * Copyright 2013-2015 Steven Wanderski
     * Written while drinking Belgian ales and listening to jazz
     * Licensed under MIT (http://opensource.org/licenses/MIT)
     */
    
    ;(function($) {
    
      var defaults = {
    
        // GENERAL
        mode: 'horizontal',
        slideSelector: '',
        infiniteLoop: true,
        hideControlOnEnd: false,
        speed: 500,
        easing: null,
        slideMargin: 0,
        startSlide: 0,
        randomStart: false,
        captions: false,
        ticker: false,
        tickerHover: false,
        adaptiveHeight: false,
        adaptiveHeightSpeed: 500,
        video: false,
        useCSS: true,
        preloadImages: 'visible',
        responsive: true,
        slideZIndex: 50,
        wrapperClass: 'bx-wrapper',
    
        // TOUCH
        touchEnabled: true,
        swipeThreshold: 50,
        oneToOneTouch: true,
        preventDefaultSwipeX: true,
        preventDefaultSwipeY: false,
    
        // ACCESSIBILITY
        ariaLive: true,
        ariaHidden: true,
    
        // KEYBOARD
        keyboardEnabled: false,
    
        // PAGER
        pager: true,
        pagerType: 'full',
        pagerShortSeparator: ' / ',
        pagerSelector: null,
        buildPager: null,
        pagerCustom: null,
    
        // CONTROLS
        controls: true,
        nextText: 'Next',
        prevText: 'Prev',
        nextSelector: null,
        prevSelector: null,
        autoControls: false,
        startText: 'Start',
        stopText: 'Stop',
        autoControlsCombine: false,
        autoControlsSelector: null,
    
        // AUTO
        auto: false,
        pause: 4000,
        autoStart: true,
        autoDirection: 'next',
        stopAutoOnClick: false,
        autoHover: false,
        autoDelay: 0,
        autoSlideForOnePage: false,
    
        // CAROUSEL
        minSlides: 1,
        maxSlides: 1,
        moveSlides: 0,
        slideWidth: 0,
        shrinkItems: false,
    
        // CALLBACKS
        onSliderLoad: function() { return true; },
        onSlideBefore: function() { return true; },
        onSlideAfter: function() { return true; },
        onSlideNext: function() { return true; },
        onSlidePrev: function() { return true; },
        onSliderResize: function() { return true; }
      };
    
      $.fn.bxSlider = function(options) {
    
        if (this.length === 0) {
          return this;
        }
    
        // support multiple elements
        if (this.length > 1) {
          this.each(function() {
            $(this).bxSlider(options);
          });
          return this;
        }
    
        // create a namespace to be used throughout the plugin
        var slider = {},
        // set a reference to our slider element
        el = this,
        // get the original window dimens (thanks a lot IE)
        windowWidth = $(window).width(),
        windowHeight = $(window).height();
    
        // Return if slider is already initialized
        if ($(el).data('bxSlider')) { return; }
    
        /**
         * ===================================================================================
         * = PRIVATE FUNCTIONS
         * ===================================================================================
         */
    
        /**
         * Initializes namespace settings to be used throughout plugin
         */
        var init = function() {
          // Return if slider is already initialized
          if ($(el).data('bxSlider')) { return; }
          // merge user-supplied options with the defaults
          slider.settings = $.extend({}, defaults, options);
          // parse slideWidth setting
          slider.settings.slideWidth = parseInt(slider.settings.slideWidth);
          // store the original children
          slider.children = el.children(slider.settings.slideSelector);
          // check if actual number of slides is less than minSlides / maxSlides
          if (slider.children.length < slider.settings.minSlides) { slider.settings.minSlides = slider.children.length; }
          if (slider.children.length < slider.settings.maxSlides) { slider.settings.maxSlides = slider.children.length; }
          // if random start, set the startSlide setting to random number
          if (slider.settings.randomStart) { slider.settings.startSlide = Math.floor(Math.random() * slider.children.length); }
          // store active slide information
          slider.active = { index: slider.settings.startSlide };
          // store if the slider is in carousel mode (displaying / moving multiple slides)
          slider.carousel = slider.settings.minSlides > 1 || slider.settings.maxSlides > 1 ? true : false;
          // if carousel, force preloadImages = 'all'
          if (slider.carousel) { slider.settings.preloadImages = 'all'; }
          // calculate the min / max width thresholds based on min / max number of slides
          // used to setup and update carousel slides dimensions
          slider.minThreshold = (slider.settings.minSlides * slider.settings.slideWidth) + ((slider.settings.minSlides - 1) * slider.settings.slideMargin);
          slider.maxThreshold = (slider.settings.maxSlides * slider.settings.slideWidth) + ((slider.settings.maxSlides - 1) * slider.settings.slideMargin);
          // store the current state of the slider (if currently animating, working is true)
          slider.working = false;
          // initialize the controls object
          slider.controls = {};
          // initialize an auto interval
          slider.interval = null;
          // determine which property to use for transitions
          slider.animProp = slider.settings.mode === 'vertical' ? 'top' : 'left';
          // determine if hardware acceleration can be used
          slider.usingCSS = slider.settings.useCSS && slider.settings.mode !== 'fade' && (function() {
            // create our test div element
            var div = document.createElement('div'),
            // css transition properties
            props = ['WebkitPerspective', 'MozPerspective', 'OPerspective', 'msPerspective'];
            // test for each property
            for (var i = 0; i < props.length; i++) {
              if (div.style[props[i]] !== undefined) {
                slider.cssPrefix = props[i].replace('Perspective', '').toLowerCase();
                slider.animProp = '-' + slider.cssPrefix + '-transform';
                return true;
              }
            }
            return false;
          }());
          // if vertical mode always make maxSlides and minSlides equal
          if (slider.settings.mode === 'vertical') { slider.settings.maxSlides = slider.settings.minSlides; }
          // save original style data
          el.data('origStyle', el.attr('style'));
          el.children(slider.settings.slideSelector).each(function() {
            $(this).data('origStyle', $(this).attr('style'));
          });
    
          // perform all DOM / CSS modifications
          setup();
        };
    
        /**
         * Performs all DOM and CSS modifications
         */
        var setup = function() {
          var preloadSelector = slider.children.eq(slider.settings.startSlide); // set the default preload selector (visible)
    
          // wrap el in a wrapper
          el.wrap('<div class="' + slider.settings.wrapperClass + '"><div class="bx-viewport"></div></div>');
          // store a namespace reference to .bx-viewport
          slider.viewport = el.parent();
    
          // add aria-live if the setting is enabled and ticker mode is disabled
          if (slider.settings.ariaLive && !slider.settings.ticker) {
            slider.viewport.attr('aria-live', 'polite');
          }
          // add a loading div to display while images are loading
          slider.loader = $('<div class="bx-loading" />');
          slider.viewport.prepend(slider.loader);
          // set el to a massive width, to hold any needed slides
          // also strip any margin and padding from el
          el.css({
            width: slider.settings.mode === 'horizontal' ? (slider.children.length * 1000 + 215) + '%' : 'auto',
            position: 'relative'
          });
          // if using CSS, add the easing property
          if (slider.usingCSS && slider.settings.easing) {
            el.css('-' + slider.cssPrefix + '-transition-timing-function', slider.settings.easing);
          // if not using CSS and no easing value was supplied, use the default JS animation easing (swing)
          } else if (!slider.settings.easing) {
            slider.settings.easing = 'swing';
          }
          // make modifications to the viewport (.bx-viewport)
          slider.viewport.css({
            width: '100%',
            overflow: 'hidden',
            position: 'relative'
          });
          slider.viewport.parent().css({
            maxWidth: getViewportMaxWidth()
          });
          // apply css to all slider children
          slider.children.css({
            float: slider.settings.mode === 'horizontal' ? 'left' : 'none',
            listStyle: 'none',
            position: 'relative'
          });
          // apply the calculated width after the float is applied to prevent scrollbar interference
          slider.children.css('width', getSlideWidth());
          // if slideMargin is supplied, add the css
          if (slider.settings.mode === 'horizontal' && slider.settings.slideMargin > 0) { slider.children.css('marginRight', slider.settings.slideMargin); }
          if (slider.settings.mode === 'vertical' && slider.settings.slideMargin > 0) { slider.children.css('marginBottom', slider.settings.slideMargin); }
          // if "fade" mode, add positioning and z-index CSS
          if (slider.settings.mode === 'fade') {
            slider.children.css({
              position: 'absolute',
              zIndex: 0,
              display: 'none'
            });
            // prepare the z-index on the showing element
            slider.children.eq(slider.settings.startSlide).css({zIndex: slider.settings.slideZIndex, display: 'block'});
          }
          // create an element to contain all slider controls (pager, start / stop, etc)
          slider.controls.el = $('<div class="bx-controls" />');
          // if captions are requested, add them
          if (slider.settings.captions) { appendCaptions(); }
          // check if startSlide is last slide
          slider.active.last = slider.settings.startSlide === getPagerQty() - 1;
          // if video is true, set up the fitVids plugin
          if (slider.settings.video) { el.fitVids(); }
          if (slider.settings.preloadImages === 'all' || slider.settings.ticker) { preloadSelector = slider.children; }
          // only check for control addition if not in "ticker" mode
          if (!slider.settings.ticker) {
            // if controls are requested, add them
            if (slider.settings.controls) { appendControls(); }
            // if auto is true, and auto controls are requested, add them
            if (slider.settings.auto && slider.settings.autoControls) { appendControlsAuto(); }
            // if pager is requested, add it
            if (slider.settings.pager) { appendPager(); }
            // if any control option is requested, add the controls wrapper
            if (slider.settings.controls || slider.settings.autoControls || slider.settings.pager) { slider.viewport.after(slider.controls.el); }
          // if ticker mode, do not allow a pager
          } else {
            slider.settings.pager = false;
          }
          loadElements(preloadSelector, start);
        };
    
        var loadElements = function(selector, callback) {
          var total = selector.find('img:not([src=""]), iframe').length,
          count = 0;
          if (total === 0) {
            callback();
            return;
          }
          selector.find('img:not([src=""]), iframe').each(function() {
            $(this).one('load error', function() {
              if (++count === total) { callback(); }
            }).each(function() {
              if (this.complete) { $(this).trigger('load'); }
            });
          });
        };
    
        /**
         * Start the slider
         */
        var start = function() {
          // if infinite loop, prepare additional slides
          if (slider.settings.infiniteLoop && slider.settings.mode !== 'fade' && !slider.settings.ticker) {
            var slice    = slider.settings.mode === 'vertical' ? slider.settings.minSlides : slider.settings.maxSlides,
            sliceAppend  = slider.children.slice(0, slice).clone(true).addClass('bx-clone'),
            slicePrepend = slider.children.slice(-slice).clone(true).addClass('bx-clone');
            if (slider.settings.ariaHidden) {
              sliceAppend.attr('aria-hidden', true);
              slicePrepend.attr('aria-hidden', true);
            }
            el.append(sliceAppend).prepend(slicePrepend);
          }
          // remove the loading DOM element
          slider.loader.remove();
          // set the left / top position of "el"
          setSlidePosition();
          // if "vertical" mode, always use adaptiveHeight to prevent odd behavior
          if (slider.settings.mode === 'vertical') { slider.settings.adaptiveHeight = true; }
          // set the viewport height
          slider.viewport.height(getViewportHeight());
          // make sure everything is positioned just right (same as a window resize)
          el.redrawSlider();
          // onSliderLoad callback
          slider.settings.onSliderLoad.call(el, slider.active.index);
          // slider has been fully initialized
          slider.initialized = true;
          // bind the resize call to the window
          if (slider.settings.responsive) { $(window).bind('resize', resizeWindow); }
          // if auto is true and has more than 1 page, start the show
          if (slider.settings.auto && slider.settings.autoStart && (getPagerQty() > 1 || slider.settings.autoSlideForOnePage)) { initAuto(); }
          // if ticker is true, start the ticker
          if (slider.settings.ticker) { initTicker(); }
          // if pager is requested, make the appropriate pager link active
          if (slider.settings.pager) { updatePagerActive(slider.settings.startSlide); }
          // check for any updates to the controls (like hideControlOnEnd updates)
          if (slider.settings.controls) { updateDirectionControls(); }
          // if touchEnabled is true, setup the touch events
          if (slider.settings.touchEnabled && !slider.settings.ticker) { initTouch(); }
          // if keyboardEnabled is true, setup the keyboard events
          if (slider.settings.keyboardEnabled && !slider.settings.ticker) {
            $(document).keydown(keyPress);
          }
        };
    
        /**
         * Returns the calculated height of the viewport, used to determine either adaptiveHeight or the maxHeight value
         */
        var getViewportHeight = function() {
          var height = 0;
          // first determine which children (slides) should be used in our height calculation
          var children = $();
          // if mode is not "vertical" and adaptiveHeight is false, include all children
          if (slider.settings.mode !== 'vertical' && !slider.settings.adaptiveHeight) {
            children = slider.children;
          } else {
            // if not carousel, return the single active child
            if (!slider.carousel) {
              children = slider.children.eq(slider.active.index);
            // if carousel, return a slice of children
            } else {
              // get the individual slide index
              var currentIndex = slider.settings.moveSlides === 1 ? slider.active.index : slider.active.index * getMoveBy();
              // add the current slide to the children
              children = slider.children.eq(currentIndex);
              // cycle through the remaining "showing" slides
              for (i = 1; i <= slider.settings.maxSlides - 1; i++) {
                // if looped back to the start
                if (currentIndex + i >= slider.children.length) {
                  children = children.add(slider.children.eq(i - 1));
                } else {
                  children = children.add(slider.children.eq(currentIndex + i));
                }
              }
            }
          }
          // if "vertical" mode, calculate the sum of the heights of the children
          if (slider.settings.mode === 'vertical') {
            children.each(function(index) {
              height += $(this).outerHeight();
            });
            // add user-supplied margins
            if (slider.settings.slideMargin > 0) {
              height += slider.settings.slideMargin * (slider.settings.minSlides - 1);
            }
          // if not "vertical" mode, calculate the max height of the children
          } else {
            height = Math.max.apply(Math, children.map(function() {
              return $(this).outerHeight(false);
            }).get());
          }
    
          if (slider.viewport.css('box-sizing') === 'border-box') {
            height += parseFloat(slider.viewport.css('padding-top')) + parseFloat(slider.viewport.css('padding-bottom')) +
                  parseFloat(slider.viewport.css('border-top-width')) + parseFloat(slider.viewport.css('border-bottom-width'));
          } else if (slider.viewport.css('box-sizing') === 'padding-box') {
            height += parseFloat(slider.viewport.css('padding-top')) + parseFloat(slider.viewport.css('padding-bottom'));
          }
    
          return height;
        };
    
        /**
         * Returns the calculated width to be used for the outer wrapper / viewport
         */
        var getViewportMaxWidth = function() {
          var width = '100%';
          if (slider.settings.slideWidth > 0) {
            if (slider.settings.mode === 'horizontal') {
              width = (slider.settings.maxSlides * slider.settings.slideWidth) + ((slider.settings.maxSlides - 1) * slider.settings.slideMargin);
            } else {
              width = slider.settings.slideWidth;
            }
          }
          return width;
        };
    
        /**
         * Returns the calculated width to be applied to each slide
         */
        var getSlideWidth = function() {
          var newElWidth = slider.settings.slideWidth, // start with any user-supplied slide width
          wrapWidth      = slider.viewport.width();    // get the current viewport width
          // if slide width was not supplied, or is larger than the viewport use the viewport width
          if (slider.settings.slideWidth === 0 ||
            (slider.settings.slideWidth > wrapWidth && !slider.carousel) ||
            slider.settings.mode === 'vertical') {
            newElWidth = wrapWidth;
          // if carousel, use the thresholds to determine the width
          } else if (slider.settings.maxSlides > 1 && slider.settings.mode === 'horizontal') {
            if (wrapWidth > slider.maxThreshold) {
              return newElWidth;
            } else if (wrapWidth < slider.minThreshold) {
              newElWidth = (wrapWidth - (slider.settings.slideMargin * (slider.settings.minSlides - 1))) / slider.settings.minSlides;
            } else if (slider.settings.shrinkItems) {
              newElWidth = Math.floor((wrapWidth + slider.settings.slideMargin) / (Math.ceil((wrapWidth + slider.settings.slideMargin) / (newElWidth + slider.settings.slideMargin))) - slider.settings.slideMargin);
            }
          }
          return newElWidth;
        };
    
        /**
         * Returns the number of slides currently visible in the viewport (includes partially visible slides)
         */
        var getNumberSlidesShowing = function() {
          var slidesShowing = 1,
          childWidth = null;
          if (slider.settings.mode === 'horizontal' && slider.settings.slideWidth > 0) {
            // if viewport is smaller than minThreshold, return minSlides
            if (slider.viewport.width() < slider.minThreshold) {
              slidesShowing = slider.settings.minSlides;
            // if viewport is larger than maxThreshold, return maxSlides
            } else if (slider.viewport.width() > slider.maxThreshold) {
              slidesShowing = slider.settings.maxSlides;
            // if viewport is between min / max thresholds, divide viewport width by first child width
            } else {
              childWidth = slider.children.first().width() + slider.settings.slideMargin;
              slidesShowing = Math.floor((slider.viewport.width() +
                slider.settings.slideMargin) / childWidth);
            }
          // if "vertical" mode, slides showing will always be minSlides
          } else if (slider.settings.mode === 'vertical') {
            slidesShowing = slider.settings.minSlides;
          }
          return slidesShowing;
        };
    
        /**
         * Returns the number of pages (one full viewport of slides is one "page")
         */
        var getPagerQty = function() {
          var pagerQty = 0,
          breakPoint = 0,
          counter = 0;
          // if moveSlides is specified by the user
          if (slider.settings.moveSlides > 0) {
            if (slider.settings.infiniteLoop) {
              pagerQty = Math.ceil(slider.children.length / getMoveBy());
            } else {
              // when breakpoint goes above children length, counter is the number of pages
              while (breakPoint < slider.children.length) {
                ++pagerQty;
                breakPoint = counter + getNumberSlidesShowing();
                counter += slider.settings.moveSlides <= getNumberSlidesShowing() ? slider.settings.moveSlides : getNumberSlidesShowing();
              }
            }
          // if moveSlides is 0 (auto) divide children length by sides showing, then round up
          } else {
            pagerQty = Math.ceil(slider.children.length / getNumberSlidesShowing());
          }
          return pagerQty;
        };
    
        /**
         * Returns the number of individual slides by which to shift the slider
         */
        var getMoveBy = function() {
          // if moveSlides was set by the user and moveSlides is less than number of slides showing
          if (slider.settings.moveSlides > 0 && slider.settings.moveSlides <= getNumberSlidesShowing()) {
            return slider.settings.moveSlides;
          }
          // if moveSlides is 0 (auto)
          return getNumberSlidesShowing();
        };
    
        /**
         * Sets the slider's (el) left or top position
         */
        var setSlidePosition = function() {
          var position, lastChild, lastShowingIndex;
          // if last slide, not infinite loop, and number of children is larger than specified maxSlides
          if (slider.children.length > slider.settings.maxSlides && slider.active.last && !slider.settings.infiniteLoop) {
            if (slider.settings.mode === 'horizontal') {
              // get the last child's position
              lastChild = slider.children.last();
              position = lastChild.position();
              // set the left position
              setPositionProperty(-(position.left - (slider.viewport.width() - lastChild.outerWidth())), 'reset', 0);
            } else if (slider.settings.mode === 'vertical') {
              // get the last showing index's position
              lastShowingIndex = slider.children.length - slider.settings.minSlides;
              position = slider.children.eq(lastShowingIndex).position();
              // set the top position
              setPositionProperty(-position.top, 'reset', 0);
            }
          // if not last slide
          } else {
            // get the position of the first showing slide
            position = slider.children.eq(slider.active.index * getMoveBy()).position();
            // check for last slide
            if (slider.active.index === getPagerQty() - 1) { slider.active.last = true; }
            // set the respective position
            if (position !== undefined) {
              if (slider.settings.mode === 'horizontal') { setPositionProperty(-position.left, 'reset', 0); }
              else if (slider.settings.mode === 'vertical') { setPositionProperty(-position.top, 'reset', 0); }
            }
          }
        };
    
        /**
         * Sets the el's animating property position (which in turn will sometimes animate el).
         * If using CSS, sets the transform property. If not using CSS, sets the top / left property.
         *
         * @param value (int)
         *  - the animating property's value
         *
         * @param type (string) 'slide', 'reset', 'ticker'
         *  - the type of instance for which the function is being
         *
         * @param duration (int)
         *  - the amount of time (in ms) the transition should occupy
         *
         * @param params (array) optional
         *  - an optional parameter containing any variables that need to be passed in
         */
        var setPositionProperty = function(value, type, duration, params) {
          var animateObj, propValue;
          // use CSS transform
          if (slider.usingCSS) {
            // determine the translate3d value
            propValue = slider.settings.mode === 'vertical' ? 'translate3d(0, ' + value + 'px, 0)' : 'translate3d(' + value + 'px, 0, 0)';
            // add the CSS transition-duration
            el.css('-' + slider.cssPrefix + '-transition-duration', duration / 1000 + 's');
            if (type === 'slide') {
              // set the property value
              el.css(slider.animProp, propValue);
              if (duration !== 0) {
                // bind a callback method - executes when CSS transition completes
                el.bind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd', function(e) {
                  //make sure it's the correct one
                  if (!$(e.target).is(el)) { return; }
                  // unbind the callback
                  el.unbind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd');
                  updateAfterSlideTransition();
                });
              } else { //duration = 0
                updateAfterSlideTransition();
              }
            } else if (type === 'reset') {
              el.css(slider.animProp, propValue);
            } else if (type === 'ticker') {
              // make the transition use 'linear'
              el.css('-' + slider.cssPrefix + '-transition-timing-function', 'linear');
              el.css(slider.animProp, propValue);
              if (duration !== 0) {
                el.bind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd', function(e) {
                  //make sure it's the correct one
                  if (!$(e.target).is(el)) { return; }
                  // unbind the callback
                  el.unbind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd');
                  // reset the position
                  setPositionProperty(params.resetValue, 'reset', 0);
                  // start the loop again
                  tickerLoop();
                });
              } else { //duration = 0
                setPositionProperty(params.resetValue, 'reset', 0);
                tickerLoop();
              }
            }
          // use JS animate
          } else {
            animateObj = {};
            animateObj[slider.animProp] = value;
            if (type === 'slide') {
              el.animate(animateObj, duration, slider.settings.easing, function() {
                updateAfterSlideTransition();
              });
            } else if (type === 'reset') {
              el.css(slider.animProp, value);
            } else if (type === 'ticker') {
              el.animate(animateObj, duration, 'linear', function() {
                setPositionProperty(params.resetValue, 'reset', 0);
                // run the recursive loop after animation
                tickerLoop();
              });
            }
          }
        };
    
        /**
         * Populates the pager with proper amount of pages
         */
        var populatePager = function() {
          var pagerHtml = '',
          linkContent = '',
          pagerQty = getPagerQty();
          // loop through each pager item
          for (var i = 0; i < pagerQty; i++) {
            linkContent = '';
            // if a buildPager function is supplied, use it to get pager link value, else use index + 1
            if (slider.settings.buildPager && $.isFunction(slider.settings.buildPager) || slider.settings.pagerCustom) {
              linkContent = slider.settings.buildPager(i);
              slider.pagerEl.addClass('bx-custom-pager');
            } else {
              linkContent = i + 1;
              slider.pagerEl.addClass('bx-default-pager');
            }
            // var linkContent = slider.settings.buildPager && $.isFunction(slider.settings.buildPager) ? slider.settings.buildPager(i) : i + 1;
            // add the markup to the string
            pagerHtml += '<div class="bx-pager-item"><a href="" data-slide-index="' + i + '" class="bx-pager-link">' + linkContent + '</a></div>';
          }
          // populate the pager element with pager links
          slider.pagerEl.html(pagerHtml);
        };
    
        /**
         * Appends the pager to the controls element
         */
        var appendPager = function() {
          if (!slider.settings.pagerCustom) {
            // create the pager DOM element
            slider.pagerEl = $('<div class="bx-pager" />');
            // if a pager selector was supplied, populate it with the pager
            if (slider.settings.pagerSelector) {
              $(slider.settings.pagerSelector).html(slider.pagerEl);
            // if no pager selector was supplied, add it after the wrapper
            } else {
              slider.controls.el.addClass('bx-has-pager').append(slider.pagerEl);
            }
            // populate the pager
            populatePager();
          } else {
            slider.pagerEl = $(slider.settings.pagerCustom);
          }
          // assign the pager click binding
          slider.pagerEl.on('click touchend', 'a', clickPagerBind);
        };
    
        /**
         * Appends prev / next controls to the controls element
         */
        var appendControls = function() {
          slider.controls.next = $('<a class="bx-next" href="">' + slider.settings.nextText + '</a>');
          slider.controls.prev = $('<a class="bx-prev" href="">' + slider.settings.prevText + '</a>');
          // bind click actions to the controls
          slider.controls.next.bind('click touchend', clickNextBind);
          slider.controls.prev.bind('click touchend', clickPrevBind);
          // if nextSelector was supplied, populate it
          if (slider.settings.nextSelector) {
            $(slider.settings.nextSelector).append(slider.controls.next);
          }
          // if prevSelector was supplied, populate it
          if (slider.settings.prevSelector) {
            $(slider.settings.prevSelector).append(slider.controls.prev);
          }
          // if no custom selectors were supplied
          if (!slider.settings.nextSelector && !slider.settings.prevSelector) {
            // add the controls to the DOM
            slider.controls.directionEl = $('<div class="bx-controls-direction" />');
            // add the control elements to the directionEl
            slider.controls.directionEl.append(slider.controls.prev).append(slider.controls.next);
            // slider.viewport.append(slider.controls.directionEl);
            slider.controls.el.addClass('bx-has-controls-direction').append(slider.controls.directionEl);
          }
        };
    
        /**
         * Appends start / stop auto controls to the controls element
         */
        var appendControlsAuto = function() {
          slider.controls.start = $('<div class="bx-controls-auto-item"><a class="bx-start" href="">' + slider.settings.startText + '</a></div>');
          slider.controls.stop = $('<div class="bx-controls-auto-item"><a class="bx-stop" href="">' + slider.settings.stopText + '</a></div>');
          // add the controls to the DOM
          slider.controls.autoEl = $('<div class="bx-controls-auto" />');
          // bind click actions to the controls
          slider.controls.autoEl.on('click', '.bx-start', clickStartBind);
          slider.controls.autoEl.on('click', '.bx-stop', clickStopBind);
          // if autoControlsCombine, insert only the "start" control
          if (slider.settings.autoControlsCombine) {
            slider.controls.autoEl.append(slider.controls.start);
          // if autoControlsCombine is false, insert both controls
          } else {
            slider.controls.autoEl.append(slider.controls.start).append(slider.controls.stop);
          }
          // if auto controls selector was supplied, populate it with the controls
          if (slider.settings.autoControlsSelector) {
            $(slider.settings.autoControlsSelector).html(slider.controls.autoEl);
          // if auto controls selector was not supplied, add it after the wrapper
          } else {
            slider.controls.el.addClass('bx-has-controls-auto').append(slider.controls.autoEl);
          }
          // update the auto controls
          updateAutoControls(slider.settings.autoStart ? 'stop' : 'start');
        };
    
        /**
         * Appends image captions to the DOM
         */
        var appendCaptions = function() {
          // cycle through each child
          slider.children.each(function(index) {
            // get the image title attribute
            var title = $(this).find('img:first').attr('title');
            // append the caption
            if (title !== undefined && ('' + title).length) {
              $(this).append('<div class="bx-caption"><span>' + title + '</span></div>');
            }
          });
        };
    
        /**
         * Click next binding
         *
         * @param e (event)
         *  - DOM event object
         */
        var clickNextBind = function(e) {
          e.preventDefault();
          if (slider.controls.el.hasClass('disabled')) { return; }
          // if auto show is running, stop it
          if (slider.settings.auto && slider.settings.stopAutoOnClick) { el.stopAuto(); }
          el.goToNextSlide();
        };
    
        /**
         * Click prev binding
         *
         * @param e (event)
         *  - DOM event object
         */
        var clickPrevBind = function(e) {
          e.preventDefault();
          if (slider.controls.el.hasClass('disabled')) { return; }
          // if auto show is running, stop it
          if (slider.settings.auto && slider.settings.stopAutoOnClick) { el.stopAuto(); }
          el.goToPrevSlide();
        };
    
        /**
         * Click start binding
         *
         * @param e (event)
         *  - DOM event object
         */
        var clickStartBind = function(e) {
          el.startAuto();
          e.preventDefault();
        };
    
        /**
         * Click stop binding
         *
         * @param e (event)
         *  - DOM event object
         */
        var clickStopBind = function(e) {
          el.stopAuto();
          e.preventDefault();
        };
    
        /**
         * Click pager binding
         *
         * @param e (event)
         *  - DOM event object
         */
        var clickPagerBind = function(e) {
          var pagerLink, pagerIndex;
          e.preventDefault();
          if (slider.controls.el.hasClass('disabled')) {
            return;
          }
          // if auto show is running, stop it
          if (slider.settings.auto  && slider.settings.stopAutoOnClick) { el.stopAuto(); }
          pagerLink = $(e.currentTarget);
          if (pagerLink.attr('data-slide-index') !== undefined) {
            pagerIndex = parseInt(pagerLink.attr('data-slide-index'));
            // if clicked pager link is not active, continue with the goToSlide call
            if (pagerIndex !== slider.active.index) { el.goToSlide(pagerIndex); }
          }
        };
    
        /**
         * Updates the pager links with an active class
         *
         * @param slideIndex (int)
         *  - index of slide to make active
         */
        var updatePagerActive = function(slideIndex) {
          // if "short" pager type
          var len = slider.children.length; // nb of children
          if (slider.settings.pagerType === 'short') {
            if (slider.settings.maxSlides > 1) {
              len = Math.ceil(slider.children.length / slider.settings.maxSlides);
            }
            slider.pagerEl.html((slideIndex + 1) + slider.settings.pagerShortSeparator + len);
            return;
          }
          // remove all pager active classes
          slider.pagerEl.find('a').removeClass('active');
          // apply the active class for all pagers
          slider.pagerEl.each(function(i, el) { $(el).find('a').eq(slideIndex).addClass('active'); });
        };
    
        /**
         * Performs needed actions after a slide transition
         */
        var updateAfterSlideTransition = function() {
          // if infinite loop is true
          if (slider.settings.infiniteLoop) {
            var position = '';
            // first slide
            if (slider.active.index === 0) {
              // set the new position
              position = slider.children.eq(0).position();
            // carousel, last slide
            } else if (slider.active.index === getPagerQty() - 1 && slider.carousel) {
              position = slider.children.eq((getPagerQty() - 1) * getMoveBy()).position();
            // last slide
            } else if (slider.active.index === slider.children.length - 1) {
              position = slider.children.eq(slider.children.length - 1).position();
            }
            if (position) {
              if (slider.settings.mode === 'horizontal') { setPositionProperty(-position.left, 'reset', 0); }
              else if (slider.settings.mode === 'vertical') { setPositionProperty(-position.top, 'reset', 0); }
            }
          }
          // declare that the transition is complete
          slider.working = false;
          // onSlideAfter callback
          slider.settings.onSlideAfter.call(el, slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index);
        };
    
        /**
         * Updates the auto controls state (either active, or combined switch)
         *
         * @param state (string) "start", "stop"
         *  - the new state of the auto show
         */
        var updateAutoControls = function(state) {
          // if autoControlsCombine is true, replace the current control with the new state
          if (slider.settings.autoControlsCombine) {
            slider.controls.autoEl.html(slider.controls[state]);
          // if autoControlsCombine is false, apply the "active" class to the appropriate control
          } else {
            slider.controls.autoEl.find('a').removeClass('active');
            slider.controls.autoEl.find('a:not(.bx-' + state + ')').addClass('active');
          }
        };
    
        /**
         * Updates the direction controls (checks if either should be hidden)
         */
        var updateDirectionControls = function() {
          if (getPagerQty() === 1) {
            slider.controls.prev.addClass('disabled');
            slider.controls.next.addClass('disabled');
          } else if (!slider.settings.infiniteLoop && slider.settings.hideControlOnEnd) {
            // if first slide
            if (slider.active.index === 0) {
              slider.controls.prev.addClass('disabled');
              slider.controls.next.removeClass('disabled');
            // if last slide
            } else if (slider.active.index === getPagerQty() - 1) {
              slider.controls.next.addClass('disabled');
              slider.controls.prev.removeClass('disabled');
            // if any slide in the middle
            } else {
              slider.controls.prev.removeClass('disabled');
              slider.controls.next.removeClass('disabled');
            }
          }
        };
    
        /**
         * Initializes the auto process
         */
        var initAuto = function() {
          // if autoDelay was supplied, launch the auto show using a setTimeout() call
          if (slider.settings.autoDelay > 0) {
            var timeout = setTimeout(el.startAuto, slider.settings.autoDelay);
          // if autoDelay was not supplied, start the auto show normally
          } else {
            el.startAuto();
    
            //add focus and blur events to ensure its running if timeout gets paused
            $(window).focus(function() {
              el.startAuto();
            }).blur(function() {
              el.stopAuto();
            });
          }
          // if autoHover is requested
          if (slider.settings.autoHover) {
            // on el hover
            el.hover(function() {
              // if the auto show is currently playing (has an active interval)
              if (slider.interval) {
                // stop the auto show and pass true argument which will prevent control update
                el.stopAuto(true);
                // create a new autoPaused value which will be used by the relative "mouseout" event
                slider.autoPaused = true;
              }
            }, function() {
              // if the autoPaused value was created be the prior "mouseover" event
              if (slider.autoPaused) {
                // start the auto show and pass true argument which will prevent control update
                el.startAuto(true);
                // reset the autoPaused value
                slider.autoPaused = null;
              }
            });
          }
        };
    
        /**
         * Initializes the ticker process
         */
        var initTicker = function() {
          var startPosition = 0,
          position, transform, value, idx, ratio, property, newSpeed, totalDimens;
          // if autoDirection is "next", append a clone of the entire slider
          if (slider.settings.autoDirection === 'next') {
            el.append(slider.children.clone().addClass('bx-clone'));
          // if autoDirection is "prev", prepend a clone of the entire slider, and set the left position
          } else {
            el.prepend(slider.children.clone().addClass('bx-clone'));
            position = slider.children.first().position();
            startPosition = slider.settings.mode === 'horizontal' ? -position.left : -position.top;
          }
          setPositionProperty(startPosition, 'reset', 0);
          // do not allow controls in ticker mode
          slider.settings.pager = false;
          slider.settings.controls = false;
          slider.settings.autoControls = false;
          // if autoHover is requested
          if (slider.settings.tickerHover) {
            if (slider.usingCSS) {
              idx = slider.settings.mode === 'horizontal' ? 4 : 5;
              slider.viewport.hover(function() {
                transform = el.css('-' + slider.cssPrefix + '-transform');
                value = parseFloat(transform.split(',')[idx]);
                setPositionProperty(value, 'reset', 0);
              }, function() {
                totalDimens = 0;
                slider.children.each(function(index) {
                  totalDimens += slider.settings.mode === 'horizontal' ? $(this).outerWidth(true) : $(this).outerHeight(true);
                });
                // calculate the speed ratio (used to determine the new speed to finish the paused animation)
                ratio = slider.settings.speed / totalDimens;
                // determine which property to use
                property = slider.settings.mode === 'horizontal' ? 'left' : 'top';
                // calculate the new speed
                newSpeed = ratio * (totalDimens - (Math.abs(parseInt(value))));
                tickerLoop(newSpeed);
              });
            } else {
              // on el hover
              slider.viewport.hover(function() {
                el.stop();
              }, function() {
                // calculate the total width of children (used to calculate the speed ratio)
                totalDimens = 0;
                slider.children.each(function(index) {
                  totalDimens += slider.settings.mode === 'horizontal' ? $(this).outerWidth(true) : $(this).outerHeight(true);
                });
                // calculate the speed ratio (used to determine the new speed to finish the paused animation)
                ratio = slider.settings.speed / totalDimens;
                // determine which property to use
                property = slider.settings.mode === 'horizontal' ? 'left' : 'top';
                // calculate the new speed
                newSpeed = ratio * (totalDimens - (Math.abs(parseInt(el.css(property)))));
                tickerLoop(newSpeed);
              });
            }
          }
          // start the ticker loop
          tickerLoop();
        };
    
        /**
         * Runs a continuous loop, news ticker-style
         */
        var tickerLoop = function(resumeSpeed) {
          var speed = resumeSpeed ? resumeSpeed : slider.settings.speed,
          position = {left: 0, top: 0},
          reset = {left: 0, top: 0},
          animateProperty, resetValue, params;
    
          // if "next" animate left position to last child, then reset left to 0
          if (slider.settings.autoDirection === 'next') {
            position = el.find('.bx-clone').first().position();
          // if "prev" animate left position to 0, then reset left to first non-clone child
          } else {
            reset = slider.children.first().position();
          }
          animateProperty = slider.settings.mode === 'horizontal' ? -position.left : -position.top;
          resetValue = slider.settings.mode === 'horizontal' ? -reset.left : -reset.top;
          params = {resetValue: resetValue};
          setPositionProperty(animateProperty, 'ticker', speed, params);
        };
    
        /**
         * Check if el is on screen
         */
        var isOnScreen = function(el) {
          var win = $(window),
          viewport = {
            top: win.scrollTop(),
            left: win.scrollLeft()
          },
          bounds = el.offset();
    
          viewport.right = viewport.left + win.width();
          viewport.bottom = viewport.top + win.height();
          bounds.right = bounds.left + el.outerWidth();
          bounds.bottom = bounds.top + el.outerHeight();
    
          return (!(viewport.right < bounds.left || viewport.left > bounds.right || viewport.bottom < bounds.top || viewport.top > bounds.bottom));
        };
    
        /**
         * Initializes keyboard events
         */
        var keyPress = function(e) {
          var activeElementTag = document.activeElement.tagName.toLowerCase(),
          tagFilters = 'input|textarea',
          p = new RegExp(activeElementTag,['i']),
          result = p.exec(tagFilters);
    
          if (result == null && isOnScreen(el)) {
            if (e.keyCode === 39) {
              clickNextBind(e);
              return false;
            } else if (e.keyCode === 37) {
              clickPrevBind(e);
              return false;
            }
          }
        };
    
        /**
         * Initializes touch events
         */
        var initTouch = function() {
          // initialize object to contain all touch values
          slider.touch = {
            start: {x: 0, y: 0},
            end: {x: 0, y: 0}
          };
          slider.viewport.bind('touchstart MSPointerDown pointerdown', onTouchStart);
    
          //for browsers that have implemented pointer events and fire a click after
          //every pointerup regardless of whether pointerup is on same screen location as pointerdown or not
          slider.viewport.on('click', '.bxslider a', function(e) {
            if (slider.viewport.hasClass('click-disabled')) {
              e.preventDefault();
              slider.viewport.removeClass('click-disabled');
            }
          });
        };
    
        /**
         * Event handler for "touchstart"
         *
         * @param e (event)
         *  - DOM event object
         */
        var onTouchStart = function(e) {
          //disable slider controls while user is interacting with slides to avoid slider freeze that happens on touch devices when a slide swipe happens immediately after interacting with slider controls
          slider.controls.el.addClass('disabled');
    
          if (slider.working) {
            e.preventDefault();
            slider.controls.el.removeClass('disabled');
          } else {
            // record the original position when touch starts
            slider.touch.originalPos = el.position();
            var orig = e.originalEvent,
            touchPoints = (typeof orig.changedTouches !== 'undefined') ? orig.changedTouches : [orig];
            // record the starting touch x, y coordinates
            slider.touch.start.x = touchPoints[0].pageX;
            slider.touch.start.y = touchPoints[0].pageY;
    
            if (slider.viewport.get(0).setPointerCapture) {
              slider.pointerId = orig.pointerId;
              slider.viewport.get(0).setPointerCapture(slider.pointerId);
            }
            // bind a "touchmove" event to the viewport
            slider.viewport.bind('touchmove MSPointerMove pointermove', onTouchMove);
            // bind a "touchend" event to the viewport
            slider.viewport.bind('touchend MSPointerUp pointerup', onTouchEnd);
            slider.viewport.bind('MSPointerCancel pointercancel', onPointerCancel);
          }
        };
    
        /**
         * Cancel Pointer for Windows Phone
         *
         * @param e (event)
         *  - DOM event object
         */
        var onPointerCancel = function(e) {
          /* onPointerCancel handler is needed to deal with situations when a touchend
          doesn't fire after a touchstart (this happens on windows phones only) */
          setPositionProperty(slider.touch.originalPos.left, 'reset', 0);
    
          //remove handlers
          slider.controls.el.removeClass('disabled');
          slider.viewport.unbind('MSPointerCancel pointercancel', onPointerCancel);
          slider.viewport.unbind('touchmove MSPointerMove pointermove', onTouchMove);
          slider.viewport.unbind('touchend MSPointerUp pointerup', onTouchEnd);
          if (slider.viewport.get(0).releasePointerCapture) {
            slider.viewport.get(0).releasePointerCapture(slider.pointerId);
          }
        };
    
        /**
         * Event handler for "touchmove"
         *
         * @param e (event)
         *  - DOM event object
         */
        var onTouchMove = function(e) {
          var orig = e.originalEvent,
          touchPoints = (typeof orig.changedTouches !== 'undefined') ? orig.changedTouches : [orig],
          // if scrolling on y axis, do not prevent default
          xMovement = Math.abs(touchPoints[0].pageX - slider.touch.start.x),
          yMovement = Math.abs(touchPoints[0].pageY - slider.touch.start.y),
          value = 0,
          change = 0;
    
          // x axis swipe
          if ((xMovement * 3) > yMovement && slider.settings.preventDefaultSwipeX) {
            e.preventDefault();
          // y axis swipe
          } else if ((yMovement * 3) > xMovement && slider.settings.preventDefaultSwipeY) {
            e.preventDefault();
          }
          if (slider.settings.mode !== 'fade' && slider.settings.oneToOneTouch) {
            // if horizontal, drag along x axis
            if (slider.settings.mode === 'horizontal') {
              change = touchPoints[0].pageX - slider.touch.start.x;
              value = slider.touch.originalPos.left + change;
            // if vertical, drag along y axis
            } else {
              change = touchPoints[0].pageY - slider.touch.start.y;
              value = slider.touch.originalPos.top + change;
            }
            setPositionProperty(value, 'reset', 0);
          }
        };
    
        /**
         * Event handler for "touchend"
         *
         * @param e (event)
         *  - DOM event object
         */
        var onTouchEnd = function(e) {
          slider.viewport.unbind('touchmove MSPointerMove pointermove', onTouchMove);
          //enable slider controls as soon as user stops interacing with slides
          slider.controls.el.removeClass('disabled');
          var orig    = e.originalEvent,
          touchPoints = (typeof orig.changedTouches !== 'undefined') ? orig.changedTouches : [orig],
          value       = 0,
          distance    = 0;
          // record end x, y positions
          slider.touch.end.x = touchPoints[0].pageX;
          slider.touch.end.y = touchPoints[0].pageY;
          // if fade mode, check if absolute x distance clears the threshold
          if (slider.settings.mode === 'fade') {
            distance = Math.abs(slider.touch.start.x - slider.touch.end.x);
            if (distance >= slider.settings.swipeThreshold) {
              if (slider.touch.start.x > slider.touch.end.x) {
                el.goToNextSlide();
              } else {
                el.goToPrevSlide();
              }
              el.stopAuto();
            }
          // not fade mode
          } else {
            // calculate distance and el's animate property
            if (slider.settings.mode === 'horizontal') {
              distance = slider.touch.end.x - slider.touch.start.x;
              value = slider.touch.originalPos.left;
            } else {
              distance = slider.touch.end.y - slider.touch.start.y;
              value = slider.touch.originalPos.top;
            }
            // if not infinite loop and first / last slide, do not attempt a slide transition
            if (!slider.settings.infiniteLoop && ((slider.active.index === 0 && distance > 0) || (slider.active.last && distance < 0))) {
              setPositionProperty(value, 'reset', 200);
            } else {
              // check if distance clears threshold
              if (Math.abs(distance) >= slider.settings.swipeThreshold) {
                if (distance < 0) {
                  el.goToNextSlide();
                } else {
                  el.goToPrevSlide();
                }
                el.stopAuto();
              } else {
                // el.animate(property, 200);
                setPositionProperty(value, 'reset', 200);
              }
            }
          }
          slider.viewport.unbind('touchend MSPointerUp pointerup', onTouchEnd);
          if (slider.viewport.get(0).releasePointerCapture) {
            slider.viewport.get(0).releasePointerCapture(slider.pointerId);
          }
        };
    
        /**
         * Window resize event callback
         */
        var resizeWindow = function(e) {
          // don't do anything if slider isn't initialized.
          if (!slider.initialized) { return; }
          // Delay if slider working.
          if (slider.working) {
            window.setTimeout(resizeWindow, 10);
          } else {
            // get the new window dimens (again, thank you IE)
            var windowWidthNew = $(window).width(),
            windowHeightNew = $(window).height();
            // make sure that it is a true window resize
            // *we must check this because our dinosaur friend IE fires a window resize event when certain DOM elements
            // are resized. Can you just die already?*
            if (windowWidth !== windowWidthNew || windowHeight !== windowHeightNew) {
              // set the new window dimens
              windowWidth = windowWidthNew;
              windowHeight = windowHeightNew;
              // update all dynamic elements
              el.redrawSlider();
              // Call user resize handler
              slider.settings.onSliderResize.call(el, slider.active.index);
            }
          }
        };
    
        /**
         * Adds an aria-hidden=true attribute to each element
         *
         * @param startVisibleIndex (int)
         *  - the first visible element's index
         */
        var applyAriaHiddenAttributes = function(startVisibleIndex) {
          var numberOfSlidesShowing = getNumberSlidesShowing();
          // only apply attributes if the setting is enabled and not in ticker mode
          if (slider.settings.ariaHidden && !slider.settings.ticker) {
            // add aria-hidden=true to all elements
            slider.children.attr('aria-hidden', 'true');
            // get the visible elements and change to aria-hidden=false
            slider.children.slice(startVisibleIndex, startVisibleIndex + numberOfSlidesShowing).attr('aria-hidden', 'false');
          }
        };
    
        /**
         * Returns index according to present page range
         *
         * @param slideOndex (int)
         *  - the desired slide index
         */
        var setSlideIndex = function(slideIndex) {
          if (slideIndex < 0) {
            if (slider.settings.infiniteLoop) {
              return getPagerQty() - 1;
            }else {
              //we don't go to undefined slides
              return slider.active.index;
            }
          // if slideIndex is greater than children length, set active index to 0 (this happens during infinite loop)
          } else if (slideIndex >= getPagerQty()) {
            if (slider.settings.infiniteLoop) {
              return 0;
            } else {
              //we don't move to undefined pages
              return slider.active.index;
            }
          // set active index to requested slide
          } else {
            return slideIndex;
          }
        };
    
        /**
         * ===================================================================================
         * = PUBLIC FUNCTIONS
         * ===================================================================================
         */
    
        /**
         * Performs slide transition to the specified slide
         *
         * @param slideIndex (int)
         *  - the destination slide's index (zero-based)
         *
         * @param direction (string)
         *  - INTERNAL USE ONLY - the direction of travel ("prev" / "next")
         */
        el.goToSlide = function(slideIndex, direction) {
          // onSlideBefore, onSlideNext, onSlidePrev callbacks
          // Allow transition canceling based on returned value
          var performTransition = true,
          moveBy = 0,
          position = {left: 0, top: 0},
          lastChild = null,
          lastShowingIndex, eq, value, requestEl;
          // store the old index
          slider.oldIndex = slider.active.index;
          //set new index
          slider.active.index = setSlideIndex(slideIndex);
    
          // if plugin is currently in motion, ignore request
          if (slider.working || slider.active.index === slider.oldIndex) { return; }
          // declare that plugin is in motion
          slider.working = true;
    
          performTransition = slider.settings.onSlideBefore.call(el, slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index);
    
          // If transitions canceled, reset and return
          if (typeof (performTransition) !== 'undefined' && !performTransition) {
            slider.active.index = slider.oldIndex; // restore old index
            slider.working = false; // is not in motion
            return;
          }
    
          if (direction === 'next') {
            // Prevent canceling in future functions or lack there-of from negating previous commands to cancel
            if (!slider.settings.onSlideNext.call(el, slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index)) {
              performTransition = false;
            }
          } else if (direction === 'prev') {
            // Prevent canceling in future functions or lack there-of from negating previous commands to cancel
            if (!slider.settings.onSlidePrev.call(el, slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index)) {
              performTransition = false;
            }
          }
    
          // check if last slide
          slider.active.last = slider.active.index >= getPagerQty() - 1;
          // update the pager with active class
          if (slider.settings.pager || slider.settings.pagerCustom) { updatePagerActive(slider.active.index); }
          // // check for direction control update
          if (slider.settings.controls) { updateDirectionControls(); }
          // if slider is set to mode: "fade"
          if (slider.settings.mode === 'fade') {
            // if adaptiveHeight is true and next height is different from current height, animate to the new height
            if (slider.settings.adaptiveHeight && slider.viewport.height() !== getViewportHeight()) {
              slider.viewport.animate({height: getViewportHeight()}, slider.settings.adaptiveHeightSpeed);
            }
            // fade out the visible child and reset its z-index value
            slider.children.filter(':visible').fadeOut(slider.settings.speed).css({zIndex: 0});
            // fade in the newly requested slide
            slider.children.eq(slider.active.index).css('zIndex', slider.settings.slideZIndex + 1).fadeIn(slider.settings.speed, function() {
              $(this).css('zIndex', slider.settings.slideZIndex);
              updateAfterSlideTransition();
            });
          // slider mode is not "fade"
          } else {
            // if adaptiveHeight is true and next height is different from current height, animate to the new height
            if (slider.settings.adaptiveHeight && slider.viewport.height() !== getViewportHeight()) {
              slider.viewport.animate({height: getViewportHeight()}, slider.settings.adaptiveHeightSpeed);
            }
            // if carousel and not infinite loop
            if (!slider.settings.infiniteLoop && slider.carousel && slider.active.last) {
              if (slider.settings.mode === 'horizontal') {
                // get the last child position
                lastChild = slider.children.eq(slider.children.length - 1);
                position = lastChild.position();
                // calculate the position of the last slide
                moveBy = slider.viewport.width() - lastChild.outerWidth();
              } else {
                // get last showing index position
                lastShowingIndex = slider.children.length - slider.settings.minSlides;
                position = slider.children.eq(lastShowingIndex).position();
              }
              // horizontal carousel, going previous while on first slide (infiniteLoop mode)
            } else if (slider.carousel && slider.active.last && direction === 'prev') {
              // get the last child position
              eq = slider.settings.moveSlides === 1 ? slider.settings.maxSlides - getMoveBy() : ((getPagerQty() - 1) * getMoveBy()) - (slider.children.length - slider.settings.maxSlides);
              lastChild = el.children('.bx-clone').eq(eq);
              position = lastChild.position();
            // if infinite loop and "Next" is clicked on the last slide
            } else if (direction === 'next' && slider.active.index === 0) {
              // get the last clone position
              position = el.find('> .bx-clone').eq(slider.settings.maxSlides).position();
              slider.active.last = false;
            // normal non-zero requests
            } else if (slideIndex >= 0) {
              //parseInt is applied to allow floats for slides/page
              requestEl = slideIndex * parseInt(getMoveBy());
              position = slider.children.eq(requestEl).position();
            }
    
            /* If the position doesn't exist
             * (e.g. if you destroy the slider on a next click),
             * it doesn't throw an error.
             */
            if (typeof (position) !== 'undefined') {
              value = slider.settings.mode === 'horizontal' ? -(position.left - moveBy) : -position.top;
              // plugin values to be animated
              setPositionProperty(value, 'slide', slider.settings.speed);
            } else {
              slider.working = false;
            }
          }
          if (slider.settings.ariaHidden) { applyAriaHiddenAttributes(slider.active.index * getMoveBy()); }
        };
    
        /**
         * Transitions to the next slide in the show
         */
        el.goToNextSlide = function() {
          // if infiniteLoop is false and last page is showing, disregard call
          if (!slider.settings.infiniteLoop && slider.active.last) { return; }
          var pagerIndex = parseInt(slider.active.index) + 1;
          el.goToSlide(pagerIndex, 'next');
        };
    
        /**
         * Transitions to the prev slide in the show
         */
        el.goToPrevSlide = function() {
          // if infiniteLoop is false and last page is showing, disregard call
          if (!slider.settings.infiniteLoop && slider.active.index === 0) { return; }
          var pagerIndex = parseInt(slider.active.index) - 1;
          el.goToSlide(pagerIndex, 'prev');
        };
    
        /**
         * Starts the auto show
         *
         * @param preventControlUpdate (boolean)
         *  - if true, auto controls state will not be updated
         */
        el.startAuto = function(preventControlUpdate) {
          // if an interval already exists, disregard call
          if (slider.interval) { return; }
          // create an interval
          slider.interval = setInterval(function() {
            if (slider.settings.autoDirection === 'next') {
              el.goToNextSlide();
            } else {
              el.goToPrevSlide();
            }
          }, slider.settings.pause);
          // if auto controls are displayed and preventControlUpdate is not true
          if (slider.settings.autoControls && preventControlUpdate !== true) { updateAutoControls('stop'); }
        };
    
        /**
         * Stops the auto show
         *
         * @param preventControlUpdate (boolean)
         *  - if true, auto controls state will not be updated
         */
        el.stopAuto = function(preventControlUpdate) {
          // if no interval exists, disregard call
          if (!slider.interval) { return; }
          // clear the interval
          clearInterval(slider.interval);
          slider.interval = null;
          // if auto controls are displayed and preventControlUpdate is not true
          if (slider.settings.autoControls && preventControlUpdate !== true) { updateAutoControls('start'); }
        };
    
        /**
         * Returns current slide index (zero-based)
         */
        el.getCurrentSlide = function() {
          return slider.active.index;
        };
    
        /**
         * Returns current slide element
         */
        el.getCurrentSlideElement = function() {
          return slider.children.eq(slider.active.index);
        };
    
        /**
         * Returns a slide element
         * @param index (int)
         *  - The index (zero-based) of the element you want returned.
         */
        el.getSlideElement = function(index) {
          return slider.children.eq(index);
        };
    
        /**
         * Returns number of slides in show
         */
        el.getSlideCount = function() {
          return slider.children.length;
        };
    
        /**
         * Return slider.working variable
         */
        el.isWorking = function() {
          return slider.working;
        };
    
        /**
         * Update all dynamic slider elements
         */
        el.redrawSlider = function() {
          // resize all children in ratio to new screen size
          slider.children.add(el.find('.bx-clone')).outerWidth(getSlideWidth());
          // adjust the height
          slider.viewport.css('height', getViewportHeight());
          // update the slide position
          if (!slider.settings.ticker) { setSlidePosition(); }
          // if active.last was true before the screen resize, we want
          // to keep it last no matter what screen size we end on
          if (slider.active.last) { slider.active.index = getPagerQty() - 1; }
          // if the active index (page) no longer exists due to the resize, simply set the index as last
          if (slider.active.index >= getPagerQty()) { slider.active.last = true; }
          // if a pager is being displayed and a custom pager is not being used, update it
          if (slider.settings.pager && !slider.settings.pagerCustom) {
            populatePager();
            updatePagerActive(slider.active.index);
          }
          if (slider.settings.ariaHidden) { applyAriaHiddenAttributes(slider.active.index * getMoveBy()); }
        };
    
        /**
         * Destroy the current instance of the slider (revert everything back to original state)
         */
        el.destroySlider = function() {
          // don't do anything if slider has already been destroyed
          if (!slider.initialized) { return; }
          slider.initialized = false;
          $('.bx-clone', this).remove();
          slider.children.each(function() {
            if ($(this).data('origStyle') !== undefined) {
              $(this).attr('style', $(this).data('origStyle'));
            } else {
              $(this).removeAttr('style');
            }
          });
          if ($(this).data('origStyle') !== undefined) {
            this.attr('style', $(this).data('origStyle'));
          } else {
            $(this).removeAttr('style');
          }
          $(this).unwrap().unwrap();
          if (slider.controls.el) { slider.controls.el.remove(); }
          if (slider.controls.next) { slider.controls.next.remove(); }
          if (slider.controls.prev) { slider.controls.prev.remove(); }
          if (slider.pagerEl && slider.settings.controls && !slider.settings.pagerCustom) { slider.pagerEl.remove(); }
          $('.bx-caption', this).remove();
          if (slider.controls.autoEl) { slider.controls.autoEl.remove(); }
          clearInterval(slider.interval);
          if (slider.settings.responsive) { $(window).unbind('resize', resizeWindow); }
          if (slider.settings.keyboardEnabled) { $(document).unbind('keydown', keyPress); }
          //remove self reference in data
          $(this).removeData('bxSlider');
        };
    
        /**
         * Reload the slider (revert all DOM changes, and re-initialize)
         */
        el.reloadSlider = function(settings) {
          if (settings !== undefined) { options = settings; }
          el.destroySlider();
          init();
          //store reference to self in order to access public functions later
          $(el).data('bxSlider', this);
        };
    
        init();
    
        $(el).data('bxSlider', this);
    
        // returns the current jQuery object
        return this;
      };
    
    })(jQuery);
    
    ; browserify_shim__define__module__export__(typeof bxslider != "undefined" ? bxslider : window.bxslider);
    
    }).call(global, undefined, undefined, undefined, undefined, function defineExport(ex) { module.exports = ex; });
    
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    },{"jQuery":60}],53:[function(require,module,exports){
    (function (global){
    
    ; $ = global.$ = require("jQuery");
    ; var __browserify_shim_require__=require;(function browserifyShim(module, exports, require, define, browserify_shim__define__module__export__) {
    /** File generated by Grunt -- do not modify
     *  JQUERY-FORM-VALIDATOR
     *
     *  @version 2.3.77
     *  @website http://formvalidator.net/
     *  @author Victor Jonsson, http://victorjonsson.se
     *  @license MIT
     */
    !function(a,b){"function"==typeof define&&define.amd?define(["jquery"],function(a){return b(a)}):"object"==typeof module&&module.exports?module.exports=b(__browserify_shim_require__("jquery")):b(a.jQuery)}(this,function(a){!function(a,b,c){function d(a,b){this.$form=a,this.$input=b,this.reset(),b.on("change paste",this.reset.bind(this))}var e=function(){return!1},f=null,g={numHalted:0,haltValidation:function(b){this.numHalted++,a.formUtils.haltValidation=!0,b.unbind("submit",e).bind("submit",e).find('*[type="submit"]').addClass("disabled").attr("disabled","disabled")},unHaltValidation:function(b){this.numHalted--,0===this.numHalted&&(a.formUtils.haltValidation=!1,b.unbind("submit",e).find('*[type="submit"]').removeClass("disabled").removeAttr("disabled","disabled"))}};d.prototype.reset=function(){this.haltedFormValidation=!1,this.hasRun=!1,this.isRunning=!1,this.result=c},d.prototype.run=function(a,b){return"keyup"===a?null:this.isRunning?(f=a,this.haltedFormValidation||(g.haltValidation(),this.haltedFormValidation=!0),null):this.hasRun?this.result:(f=a,g.haltValidation(this.$form),this.haltedFormValidation=!0,this.isRunning=!0,this.$input.attr("disabled","disabled").addClass("async-validation"),this.$form.addClass("async-validation"),b(function(a){this.done(a)}.bind(this)),null)},d.prototype.done=function(a){this.result=a,this.hasRun=!0,this.isRunning=!1,this.$input.removeAttr("disabled").removeClass("async-validation"),this.$form.removeClass("async-validation"),this.haltedFormValidation&&(g.unHaltValidation(this.$form),"submit"===f?this.$form.trigger("submit"):this.$input.trigger("validation.revalidate"))},d.loadInstance=function(a,b,c){var e,f=b.get(0);return f.asyncValidators||(f.asyncValidators={}),f.asyncValidators[a]?e=f.asyncValidators[a]:(e=new d(c,b),f.asyncValidators[a]=e),e},a.formUtils=a.extend(a.formUtils||{},{asyncValidation:function(a,b,c){return this.warn("Use of deprecated function $.formUtils.asyncValidation, use $.formUtils.addAsyncValidator() instead"),d.loadInstance(a,b,c)},addAsyncValidator:function(b){var c=a.extend({},b),e=c.validatorFunction;c.async=!0,c.validatorFunction=function(a,b,f,g,h,i){var j=d.loadInstance(this.name,b,h);return j.run(i,function(d){e.apply(c,[d,a,b,f,g,h,i])})},this.addValidator(c)}}),a(b).bind("validatorsLoaded formValidationSetup",function(b,c){c||(c=a("form")),c.find("[data-validation]").each(function(){var b=a(this);b.valAttr("async",!1),a.each(a.split(b.attr("data-validation")),function(c,d){var e=a.formUtils.validators["validate_"+d];e&&e.async&&b.valAttr("async","yes")})})})}(a,window),function(a,b){"use strict";function c(b){b&&"custom"===b.errorMessagePosition&&"function"==typeof b.errorMessageCustom&&(a.formUtils.warn("Use of deprecated function errorMessageCustom, use config.submitErrorMessageCallback instead"),b.submitErrorMessageCallback=function(a,c){b.errorMessageCustom(a,b.language.errorTitle,c,b)})}function d(b){if(b.errorMessagePosition&&"object"==typeof b.errorMessagePosition){a.formUtils.warn("Deprecated use of config parameter errorMessagePosition, use config.submitErrorMessageCallback instead");var c=b.errorMessagePosition;b.errorMessagePosition="top",b.submitErrorMessageCallback=function(){return c}}}function e(b){var c=b.find("[data-validation-if-checked]");c.length&&a.formUtils.warn('Detected use of attribute "data-validation-if-checked" which is deprecated. Use "data-validation-depends-on" provided by module "logic"'),c.on("beforeValidation",function(){var c=a(this),d=c.valAttr("if-checked"),e=a('input[name="'+d+'"]',b),f=e.is(":checked"),g=(a.formUtils.getValue(e)||"").toString(),h=c.valAttr("if-checked-value");(!f||h&&h!==g)&&c.valAttr("skipped",!0)})}function f(b){var c={se:"sv",cz:"cs",dk:"da"};if(b.lang in c){var d=c[b.lang];a.formUtils.warn('Deprecated use of lang code "'+b.lang+'" use "'+d+'" instead'),b.lang=d}}a.fn.validateForm=function(b,c){return a.formUtils.warn("Use of deprecated function $.validateForm, use $.isValid instead"),this.isValid(b,c,!0)},a(window).on("formValidationPluginInit",function(a,b){f(b),c(b),d(b)}).on("validatorsLoaded formValidationSetup",function(b,c){c||(c=a("form")),e(c)})}(a),function(a){"use strict";var b={resolveErrorMessage:function(a,b,c,d,e){var f=d.validationErrorMsgAttribute+"-"+c.replace("validate_",""),g=a.attr(f);return g||(g=a.attr(d.validationErrorMsgAttribute),g||(g="function"!=typeof b.errorMessageKey?e[b.errorMessageKey]:e[b.errorMessageKey(d)],g||(g=b.errorMessage))),g},getParentContainer:function(b){if(b.valAttr("error-msg-container"))return a(b.valAttr("error-msg-container"));var c=b.parent();return"checkbox"===b.attr("type")&&b.closest(".checkbox").length?c=b.closest(".checkbox").parent():"radio"===b.attr("type")&&b.closest(".radio").length&&(c=b.closest(".radio").parent()),c.closest(".input-group").length&&(c=c.closest(".input-group").parent()),c},applyInputErrorStyling:function(a,b){a.addClass(b.errorElementClass).removeClass(b.successElementClass),this.getParentContainer(a).addClass(b.inputParentClassOnError).removeClass(b.inputParentClassOnSuccess),""!==b.borderColorOnError&&a.css("border-color",b.borderColorOnError)},applyInputSuccessStyling:function(a,b){a.addClass(b.successElementClass),this.getParentContainer(a).addClass(b.inputParentClassOnSuccess)},removeInputStylingAndMessage:function(a,c){a.removeClass(c.successElementClass).removeClass(c.errorElementClass).css("border-color","");var d=b.getParentContainer(a);if(d.removeClass(c.inputParentClassOnError).removeClass(c.inputParentClassOnSuccess),"function"==typeof c.inlineErrorMessageCallback){var e=c.inlineErrorMessageCallback(a,!1,c);e&&e.html("")}else d.find("."+c.errorMessageClass).remove()},removeAllMessagesAndStyling:function(c,d){if("function"==typeof d.submitErrorMessageCallback){var e=d.submitErrorMessageCallback(c,!1,d);e&&e.html("")}else c.find("."+d.errorMessageClass+".alert").remove();c.find("."+d.errorElementClass+",."+d.successElementClass).each(function(){b.removeInputStylingAndMessage(a(this),d)})},setInlineMessage:function(b,c,d){this.applyInputErrorStyling(b,d);var e,f=document.getElementById(b.attr("name")+"_err_msg"),g=!1,h=function(d){a.formUtils.$win.trigger("validationErrorDisplay",[b,d]),d.html(c)},i=function(){var f=!1;g.find("."+d.errorMessageClass).each(function(){if(this.inputReferer===b[0])return f=a(this),!1}),f?c?h(f):f.remove():""!==c&&(e=a('<div class="'+d.errorMessageClass+' alert"></div>'),h(e),e[0].inputReferer=b[0],g.prepend(e))};if(f)a.formUtils.warn("Using deprecated element reference "+f.id),g=a(f),i();else if("function"==typeof d.inlineErrorMessageCallback){if(g=d.inlineErrorMessageCallback(b,c,d),!g)return;i()}else{var j=this.getParentContainer(b);e=j.find("."+d.errorMessageClass+".help-block"),0===e.length&&(e=a("<span></span>").addClass("help-block").addClass(d.errorMessageClass),e.appendTo(j)),h(e)}},setMessageInTopOfForm:function(b,c,d,e){var f='<div class="{errorMessageClass} alert alert-danger"><strong>{errorTitle}</strong><ul>{fields}</ul></div>',g=!1;if("function"!=typeof d.submitErrorMessageCallback||(g=d.submitErrorMessageCallback(b,c,d))){var h={errorTitle:e.errorTitle,fields:"",errorMessageClass:d.errorMessageClass};a.each(c,function(a,b){h.fields+="<li>"+b+"</li>"}),a.each(h,function(a,b){f=f.replace("{"+a+"}",b)}),g?g.html(f):b.children().eq(0).before(a(f))}}};a.formUtils=a.extend(a.formUtils||{},{dialogs:b})}(a),function(a,b,c){"use strict";var d=0;a.fn.validateOnBlur=function(b,c){var d=this,e=this.find("*[data-validation]");return e.each(function(){var e=a(this);if(e.is("[type=radio]")){var f=d.find('[type=radio][name="'+e.attr("name")+'"]');f.bind("blur.validation",function(){e.validateInputOnBlur(b,c,!0,"blur")}),c.validateCheckboxRadioOnClick&&f.bind("click.validation",function(){e.validateInputOnBlur(b,c,!0,"click")})}}),e.bind("blur.validation",function(){a(this).validateInputOnBlur(b,c,!0,"blur")}),c.validateCheckboxRadioOnClick&&this.find("input[type=checkbox][data-validation],input[type=radio][data-validation]").bind("click.validation",function(){a(this).validateInputOnBlur(b,c,!0,"click")}),this},a.fn.validateOnEvent=function(b,c){var d="FORM"===this[0].nodeName?this.find("*[data-validation-event]"):this;return d.each(function(){var d=a(this),e=d.valAttr("event");e&&d.unbind(e+".validation").bind(e+".validation",function(d){9!==(d||{}).keyCode&&a(this).validateInputOnBlur(b,c,!0,e)})}),this},a.fn.showHelpOnFocus=function(b){return b||(b="data-validation-help"),this.find("textarea,input").each(function(){var c=a(this),e="jquery_form_help_"+ ++d,f=c.attr(b);c.removeClass("has-help-text").unbind("focus.help").unbind("blur.help"),f&&c.addClass("has-help-txt").bind("focus.help",function(){var b=c.parent().find("."+e);0===b.length&&(b=a("<span />").addClass(e).addClass("help").addClass("help-block").text(f).hide(),c.after(b)),b.fadeIn()}).bind("blur.help",function(){a(this).parent().find("."+e).fadeOut("slow")})}),this},a.fn.validate=function(b,c,d){var e=a.extend({},a.formUtils.LANG,d||{});this.each(function(){var d=a(this),f=d.closest("form").get(0)||{},g=f.validationConfig||a.formUtils.defaultConfig();d.one("validation",function(a,c){"function"==typeof b&&b(c,this,a)}),d.validateInputOnBlur(e,a.extend({},g,c||{}),!0)})},a.fn.willPostponeValidation=function(){return(this.valAttr("suggestion-nr")||this.valAttr("postpone")||this.hasClass("hasDatepicker"))&&!b.postponedValidation},a.fn.validateInputOnBlur=function(c,d,e,f){if(a.formUtils.eventType=f,this.willPostponeValidation()){var g=this,h=this.valAttr("postpone")||200;return b.postponedValidation=function(){g.validateInputOnBlur(c,d,e,f),b.postponedValidation=!1},setTimeout(function(){b.postponedValidation&&b.postponedValidation()},h),this}c=a.extend({},a.formUtils.LANG,c||{}),a.formUtils.dialogs.removeInputStylingAndMessage(this,d);var i=this,j=i.closest("form"),k=a.formUtils.validateInput(i,c,d,j,f),l=function(){i.validateInputOnBlur(c,d,!1,"blur.revalidated")};return"blur"===f&&i.unbind("validation.revalidate",l).one("validation.revalidate",l),e&&i.removeKeyUpValidation(),k.shouldChangeDisplay&&(k.isValid?a.formUtils.dialogs.applyInputSuccessStyling(i,d):a.formUtils.dialogs.setInlineMessage(i,k.errorMsg,d)),!k.isValid&&e&&i.validateOnKeyUp(c,d),this},a.fn.validateOnKeyUp=function(b,c){return this.each(function(){var d=a(this);d.valAttr("has-keyup-event")||d.valAttr("has-keyup-event","true").bind("keyup.validation",function(a){9!==a.keyCode&&d.validateInputOnBlur(b,c,!1,"keyup")})}),this},a.fn.removeKeyUpValidation=function(){return this.each(function(){a(this).valAttr("has-keyup-event",!1).unbind("keyup.validation")}),this},a.fn.valAttr=function(a,b){return b===c?this.attr("data-validation-"+a):b===!1||null===b?this.removeAttr("data-validation-"+a):(a=a.length>0?"-"+a:"",this.attr("data-validation"+a,b))},a.fn.isValid=function(b,c,d){if(a.formUtils.isLoadingModules){var e=this;return setTimeout(function(){e.isValid(b,c,d)},200),null}c=a.extend({},a.formUtils.defaultConfig(),c||{}),b=a.extend({},a.formUtils.LANG,b||{}),d=d!==!1,a.formUtils.errorDisplayPreventedWhenHalted&&(delete a.formUtils.errorDisplayPreventedWhenHalted,d=!1);var f=function(b,e){a.inArray(b,h)<0&&h.push(b),i.push(e),e.valAttr("current-error",b),d&&a.formUtils.dialogs.applyInputErrorStyling(e,c)},g=[],h=[],i=[],j=this,k=function(b,d){return"submit"===d||"button"===d||"reset"===d||a.inArray(b,c.ignore||[])>-1};if(d&&a.formUtils.dialogs.removeAllMessagesAndStyling(j,c),j.find("input,textarea,select").filter(':not([type="submit"],[type="button"])').each(function(){var d=a(this),e=d.attr("type"),h="radio"===e||"checkbox"===e,i=d.attr("name");if(!k(i,e)&&(!h||a.inArray(i,g)<0)){h&&g.push(i);var l=a.formUtils.validateInput(d,b,c,j,"submit");l.isValid?l.isValid&&l.shouldChangeDisplay&&(d.valAttr("current-error",!1),a.formUtils.dialogs.applyInputSuccessStyling(d,c)):f(l.errorMsg,d)}}),"function"==typeof c.onValidate){var l=c.onValidate(j);a.isArray(l)?a.each(l,function(a,b){f(b.message,b.element)}):l&&l.element&&l.message&&f(l.message,l.element)}return a.formUtils.isValidatingEntireForm=!1,i.length>0&&d&&("top"===c.errorMessagePosition?a.formUtils.dialogs.setMessageInTopOfForm(j,h,c,b):a.each(i,function(b,d){a.formUtils.dialogs.setInlineMessage(d,d.valAttr("current-error"),c)}),c.scrollToTopOnError&&a.formUtils.$win.scrollTop(j.offset().top-20)),!d&&a.formUtils.haltValidation&&(a.formUtils.errorDisplayPreventedWhenHalted=!0),0===i.length&&!a.formUtils.haltValidation},a.fn.restrictLength=function(b){return new a.formUtils.lengthRestriction(this,b),this},a.fn.addSuggestions=function(b){var c=!1;return this.find("input").each(function(){var d=a(this);c=a.split(d.attr("data-suggestions")),c.length>0&&!d.hasClass("has-suggestions")&&(a.formUtils.suggest(d,c,b),d.addClass("has-suggestions"))}),this}}(a,window),function(a){"use strict";a.formUtils=a.extend(a.formUtils||{},{isLoadingModules:!1,loadedModules:{},registerLoadedModule:function(b){this.loadedModules[a.trim(b).toLowerCase()]=!0},hasLoadedModule:function(b){return a.trim(b).toLowerCase()in this.loadedModules},loadModules:function(b,c,d){if(a.formUtils.isLoadingModules)return void setTimeout(function(){a.formUtils.loadModules(b,c,d)},100);var e=function(b,c){var e=a.split(b),f=e.length,g=function(){f--,0===f&&(a.formUtils.isLoadingModules=!1,"function"==typeof d&&d())};f>0&&(a.formUtils.isLoadingModules=!0);var h="?_="+(new Date).getTime(),i=document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0];a.each(e,function(b,d){if(d=a.trim(d),0===d.length||a.formUtils.hasLoadedModule(d))g();else{var e=c+d+(".js"===d.slice(-3)?"":".js"),f=document.createElement("SCRIPT");"function"==typeof define&&define.amd?__browserify_shim_require__([e+(".dev.js"===e.slice(-7)?h:"")],g):(f.type="text/javascript",f.onload=g,f.src=e+(".dev.js"===e.slice(-7)?h:""),f.onerror=function(){a.formUtils.warn("Unable to load form validation module "+e,!0),g()},f.onreadystatechange=function(){"complete"!==this.readyState&&"loaded"!==this.readyState||(g(),this.onload=null,this.onreadystatechange=null)},i.appendChild(f))}})};if(c)e(b,c);else{var f=function(){var c=!1;return a('script[src*="form-validator"]').each(function(){var a=this.src.split("form-validator")[1].split("node_modules").length>1;if(!a)return c=this.src.substr(0,this.src.lastIndexOf("/"))+"/","/"===c&&(c=""),!1}),c!==!1&&(e(b,c),!0)};f()||a(function(){var a=f();a||"function"==typeof d&&d()})}}})}(a),function(a){"use strict";a.split=function(b,c,d){d=void 0===d||d===!0;var e="[,|"+(d?"\\s":"")+"-]\\s*",f=new RegExp(e,"g");if("function"!=typeof c){if(!b)return[];var g=[];return a.each(b.split(c?c:f),function(b,c){c=a.trim(c),c.length&&g.push(c)}),g}b&&a.each(b.split(f),function(b,d){if(d=a.trim(d),d.length)return c(d,b)})},a.validate=function(b){var c=a.extend(a.formUtils.defaultConfig(),{form:"form",validateOnEvent:!1,validateOnBlur:!0,validateCheckboxRadioOnClick:!0,showHelpOnFocus:!0,addSuggestions:!0,modules:"",onModulesLoaded:null,language:!1,onSuccess:!1,onError:!1,onElementValidate:!1});if(b=a.extend(c,b||{}),a(window).trigger("formValidationPluginInit",[b]),b.lang&&"en"!==b.lang){var d="lang/"+b.lang+".js";b.modules+=b.modules.length?","+d:d}a(b.form).each(function(c,d){d.validationConfig=b;var e=a(d);e.trigger("formValidationSetup",[e,b]),e.find(".has-help-txt").unbind("focus.validation").unbind("blur.validation"),e.removeClass("has-validation-callback").unbind("submit.validation").unbind("reset.validation").find("input[data-validation],textarea[data-validation]").unbind("blur.validation"),e.bind("submit.validation",function(c){var d=a(this),e=function(){return c.stopImmediatePropagation(),!1};if(a.formUtils.haltValidation)return e();if(a.formUtils.isLoadingModules)return setTimeout(function(){d.trigger("submit.validation")},200),e();var f=d.isValid(b.language,b);if(a.formUtils.haltValidation)return e();if(!f||"function"!=typeof b.onSuccess)return f||"function"!=typeof b.onError?!!f||e():(b.onError(d),e());var g=b.onSuccess(d);return g===!1?e():void 0}).bind("reset.validation",function(){a.formUtils.dialogs.removeAllMessagesAndStyling(e,b)}).addClass("has-validation-callback"),b.showHelpOnFocus&&e.showHelpOnFocus(),b.addSuggestions&&e.addSuggestions(),b.validateOnBlur&&(e.validateOnBlur(b.language,b),e.bind("html5ValidationAttrsFound",function(){e.validateOnBlur(b.language,b)})),b.validateOnEvent&&e.validateOnEvent(b.language,b)}),""!==b.modules&&a.formUtils.loadModules(b.modules,null,function(){"function"==typeof b.onModulesLoaded&&b.onModulesLoaded();var c="string"==typeof b.form?a(b.form):b.form;a.formUtils.$win.trigger("validatorsLoaded",[c,b])})}}(a),function(a,b){"use strict";var c=a(b);a.formUtils=a.extend(a.formUtils||{},{$win:c,defaultConfig:function(){return{ignore:[],errorElementClass:"error",successElementClass:"valid",borderColorOnError:"#b94a48",errorMessageClass:"form-error",validationRuleAttribute:"data-validation",validationErrorMsgAttribute:"data-validation-error-msg",errorMessagePosition:"inline",errorMessageTemplate:{container:'<div class="{errorMessageClass} alert alert-danger">{messages}</div>',messages:"<strong>{errorTitle}</strong><ul>{fields}</ul>",field:"<li>{msg}</li>"},scrollToTopOnError:!0,dateFormat:"yyyy-mm-dd",addValidClassOnAll:!1,decimalSeparator:".",inputParentClassOnError:"has-error",inputParentClassOnSuccess:"has-success",validateHiddenInputs:!1,inlineErrorMessageCallback:!1,submitErrorMessageCallback:!1}},validators:{},_events:{load:[],valid:[],invalid:[]},haltValidation:!1,addValidator:function(a){var b=0===a.name.indexOf("validate_")?a.name:"validate_"+a.name;void 0===a.validateOnKeyUp&&(a.validateOnKeyUp=!0),this.validators[b]=a},warn:function(a,c){"console"in b?"function"==typeof b.console.warn?b.console.warn(a):"function"==typeof b.console.log&&b.console.log(a):c&&alert(a)},getValue:function(a,b){var c=b?b.find(a):a;if(c.length>0){var d=c.eq(0).attr("type");return"radio"===d||"checkbox"===d?c.filter(":checked").val()||"":c.val()||""}return!1},validateInput:function(b,c,d,e,f){d=d||a.formUtils.defaultConfig(),c=c||a.formUtils.LANG,e.length||(e=b.parent());var g=this.getValue(b);b.valAttr("skipped",!1).one("beforeValidation",function(){(b.attr("disabled")||!b.is(":visible")&&!d.validateHiddenInputs)&&b.valAttr("skipped",1)}).trigger("beforeValidation",[g,c,d]);var h="true"===b.valAttr("optional"),i=!g&&h,j=b.attr(d.validationRuleAttribute),k=!0,l="",m={isValid:!0,shouldChangeDisplay:!0,errorMsg:""};if(!j||i||b.valAttr("skipped"))return m.shouldChangeDisplay=d.addValidClassOnAll,m;var n=b.valAttr("ignore");return n&&a.each(n.split(""),function(a,b){g=g.replace(new RegExp("\\"+b,"g"),"")}),a.split(j,function(h){0!==h.indexOf("validate_")&&(h="validate_"+h);var i=a.formUtils.validators[h];if(!i)throw new Error('Using undefined validator "'+h+'". Maybe you have forgotten to load the module that "'+h+'" belongs to?');if("validate_checkbox_group"===h&&(b=e.find('[name="'+b.attr("name")+'"]:eq(0)')),("keyup"!==f||i.validateOnKeyUp)&&(k=i.validatorFunction(g,b,d,c,e,f)),!k)return d.validateOnBlur&&b.validateOnKeyUp(c,d),l=a.formUtils.dialogs.resolveErrorMessage(b,i,h,d,c),!1}),k===!1?(b.trigger("validation",!1),m.errorMsg=l,m.isValid=!1,m.shouldChangeDisplay=!0):null===k?m.shouldChangeDisplay=!1:(b.trigger("validation",!0),m.shouldChangeDisplay=!0),"function"==typeof d.onElementValidate&&null!==l&&d.onElementValidate(m.isValid,b,e,l),b.trigger("afterValidation",[m,f]),m},parseDate:function(b,c,d){var e,f,g,h,i=c.replace(/[a-zA-Z]/gi,"").substring(0,1),j="^",k=c.split(i||null);if(a.each(k,function(a,b){j+=(a>0?"\\"+i:"")+"(\\d{"+b.length+"})"}),j+="$",d){var l=[];a.each(b.split(i),function(a,b){1===b.length&&(b="0"+b),l.push(b)}),b=l.join(i)}if(e=b.match(new RegExp(j)),null===e)return!1;var m=function(b,c,d){for(var e=0;e<c.length;e++)if(c[e].substring(0,1)===b)return a.formUtils.parseDateInt(d[e+1]);return-1};return g=m("m",k,e),f=m("d",k,e),h=m("y",k,e),!(2===g&&f>28&&(h%4!==0||h%100===0&&h%400!==0)||2===g&&f>29&&(h%4===0||h%100!==0&&h%400===0)||g>12||0===g)&&(!(this.isShortMonth(g)&&f>30||!this.isShortMonth(g)&&f>31||0===f)&&[h,g,f])},parseDateInt:function(a){return 0===a.indexOf("0")&&(a=a.replace("0","")),parseInt(a,10)},isShortMonth:function(a){return a%2===0&&a<7||a%2!==0&&a>7},lengthRestriction:function(b,c){var d=parseInt(c.text(),10),e=0,f=function(){var a=b.val().length;if(a>d){var f=b.scrollTop();b.val(b.val().substring(0,d)),b.scrollTop(f)}e=d-a,e<0&&(e=0),c.text(e)};a(b).bind("keydown keyup keypress focus blur",f).bind("cut paste",function(){setTimeout(f,100)}),a(document).bind("ready",f)},numericRangeCheck:function(b,c){var d=a.split(c),e=parseInt(c.substr(3),10);return 1===d.length&&c.indexOf("min")===-1&&c.indexOf("max")===-1&&(d=[c,c]),2===d.length&&(b<parseInt(d[0],10)||b>parseInt(d[1],10))?["out",d[0],d[1]]:0===c.indexOf("min")&&b<e?["min",e]:0===c.indexOf("max")&&b>e?["max",e]:["ok"]},_numSuggestionElements:0,_selectedSuggestion:null,_previousTypedVal:null,suggest:function(b,d,e){var f={css:{maxHeight:"150px",background:"#FFF",lineHeight:"150%",textDecoration:"underline",overflowX:"hidden",overflowY:"auto",border:"#CCC solid 1px",borderTop:"none",cursor:"pointer"},activeSuggestionCSS:{background:"#E9E9E9"}},g=function(a,b){var c=b.offset();a.css({width:b.outerWidth(),left:c.left+"px",top:c.top+b.outerHeight()+"px"})};e&&a.extend(f,e),f.css.position="absolute",f.css["z-index"]=9999,b.attr("autocomplete","off"),0===this._numSuggestionElements&&c.bind("resize",function(){a(".jquery-form-suggestions").each(function(){var b=a(this),c=b.attr("data-suggest-container");g(b,a(".suggestions-"+c).eq(0))})}),this._numSuggestionElements++;var h=function(b){var c=b.valAttr("suggestion-nr");a.formUtils._selectedSuggestion=null,a.formUtils._previousTypedVal=null,a(".jquery-form-suggestion-"+c).fadeOut("fast")};return b.data("suggestions",d).valAttr("suggestion-nr",this._numSuggestionElements).unbind("focus.suggest").bind("focus.suggest",function(){a(this).trigger("keyup"),a.formUtils._selectedSuggestion=null}).unbind("keyup.suggest").bind("keyup.suggest",function(){var c=a(this),d=[],e=a.trim(c.val()).toLocaleLowerCase();if(e!==a.formUtils._previousTypedVal){a.formUtils._previousTypedVal=e;var i=!1,j=c.valAttr("suggestion-nr"),k=a(".jquery-form-suggestion-"+j);if(k.scrollTop(0),""!==e){var l=e.length>2;a.each(c.data("suggestions"),function(a,b){var c=b.toLocaleLowerCase();return c===e?(d.push("<strong>"+b+"</strong>"),i=!0,!1):void((0===c.indexOf(e)||l&&c.indexOf(e)>-1)&&d.push(b.replace(new RegExp(e,"gi"),"<strong>$&</strong>")))})}i||0===d.length&&k.length>0?k.hide():d.length>0&&0===k.length?(k=a("<div></div>").css(f.css).appendTo("body"),b.addClass("suggestions-"+j),k.attr("data-suggest-container",j).addClass("jquery-form-suggestions").addClass("jquery-form-suggestion-"+j)):d.length>0&&!k.is(":visible")&&k.show(),d.length>0&&e.length!==d[0].length&&(g(k,c),k.html(""),a.each(d,function(b,d){a("<div></div>").append(d).css({overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap",padding:"5px"}).addClass("form-suggest-element").appendTo(k).click(function(){c.focus(),c.val(a(this).text()),c.trigger("change"),h(c)})}))}}).unbind("keydown.validation").bind("keydown.validation",function(b){var c,d,e=b.keyCode?b.keyCode:b.which,g=a(this);if(13===e&&null!==a.formUtils._selectedSuggestion){if(c=g.valAttr("suggestion-nr"),d=a(".jquery-form-suggestion-"+c),d.length>0){var i=d.find("div").eq(a.formUtils._selectedSuggestion).text();g.val(i),g.trigger("change"),h(g),b.preventDefault()}}else{c=g.valAttr("suggestion-nr"),d=a(".jquery-form-suggestion-"+c);var j=d.children();if(j.length>0&&a.inArray(e,[38,40])>-1){38===e?(null===a.formUtils._selectedSuggestion?a.formUtils._selectedSuggestion=j.length-1:a.formUtils._selectedSuggestion--,a.formUtils._selectedSuggestion<0&&(a.formUtils._selectedSuggestion=j.length-1)):40===e&&(null===a.formUtils._selectedSuggestion?a.formUtils._selectedSuggestion=0:a.formUtils._selectedSuggestion++,a.formUtils._selectedSuggestion>j.length-1&&(a.formUtils._selectedSuggestion=0));var k=d.innerHeight(),l=d.scrollTop(),m=d.children().eq(0).outerHeight(),n=m*a.formUtils._selectedSuggestion;return(n<l||n>l+k)&&d.scrollTop(n),j.removeClass("active-suggestion").css("background","none").eq(a.formUtils._selectedSuggestion).addClass("active-suggestion").css(f.activeSuggestionCSS),b.preventDefault(),!1}}}).unbind("blur.suggest").bind("blur.suggest",function(){h(a(this))}),b},LANG:{errorTitle:"Form submission failed!",requiredField:"This is a required field",requiredFields:"You have not answered all required fields",badTime:"You have not given a correct time",badEmail:"You have not given a correct e-mail address",badTelephone:"You have not given a correct phone number",badSecurityAnswer:"You have not given a correct answer to the security question",badDate:"You have not given a correct date",lengthBadStart:"The input value must be between ",lengthBadEnd:" characters",lengthTooLongStart:"The input value is longer than ",lengthTooShortStart:"The input value is shorter than ",notConfirmed:"Input values could not be confirmed",badDomain:"Incorrect domain value",badUrl:"The input value is not a correct URL",badCustomVal:"The input value is incorrect",andSpaces:" and spaces ",badInt:"The input value was not a correct number",badSecurityNumber:"Your social security number was incorrect",badUKVatAnswer:"Incorrect UK VAT Number",badUKNin:"Incorrect UK NIN",badUKUtr:"Incorrect UK UTR Number",badStrength:"The password isn't strong enough",badNumberOfSelectedOptionsStart:"You have to choose at least ",badNumberOfSelectedOptionsEnd:" answers",badAlphaNumeric:"The input value can only contain alphanumeric characters ",badAlphaNumericExtra:" and ",wrongFileSize:"The file you are trying to upload is too large (max %s)",wrongFileType:"Only files of type %s is allowed",groupCheckedRangeStart:"Please choose between ",groupCheckedTooFewStart:"Please choose at least ",groupCheckedTooManyStart:"Please choose a maximum of ",groupCheckedEnd:" item(s)",badCreditCard:"The credit card number is not correct",badCVV:"The CVV number was not correct",wrongFileDim:"Incorrect image dimensions,",imageTooTall:"the image can not be taller than",imageTooWide:"the image can not be wider than",imageTooSmall:"the image was too small",min:"min",max:"max",imageRatioNotAccepted:"Image ratio is not be accepted",badBrazilTelephoneAnswer:"The phone number entered is invalid",badBrazilCEPAnswer:"The CEP entered is invalid",badBrazilCPFAnswer:"The CPF entered is invalid",badPlPesel:"The PESEL entered is invalid",badPlNip:"The NIP entered is invalid",badPlRegon:"The REGON entered is invalid",badreCaptcha:"Please confirm that you are not a bot",passwordComplexityStart:"Password must contain at least ",passwordComplexitySeparator:", ",passwordComplexityUppercaseInfo:" uppercase letter(s)",passwordComplexityLowercaseInfo:" lowercase letter(s)",passwordComplexitySpecialCharsInfo:" special character(s)",passwordComplexityNumericCharsInfo:" numeric character(s)",passwordComplexityEnd:"."}})}(a,window),function(a){a.formUtils.addValidator({name:"email",validatorFunction:function(b){var c=b.toLowerCase().split("@"),d=c[0],e=c[1];if(d&&e){if(0===d.indexOf('"')){var f=d.length;if(d=d.replace(/\"/g,""),d.length!==f-2)return!1}return a.formUtils.validators.validate_domain.validatorFunction(c[1])&&0!==d.indexOf(".")&&"."!==d.substring(d.length-1,d.length)&&d.indexOf("..")===-1&&!/[^\w\+\.\-\#\-\_\~\!\$\&\'\(\)\*\+\,\;\=\:]/.test(d)}return!1},errorMessage:"",errorMessageKey:"badEmail"}),a.formUtils.addValidator({name:"domain",validatorFunction:function(a){return a.length>0&&a.length<=253&&!/[^a-zA-Z0-9]/.test(a.slice(-2))&&!/[^a-zA-Z0-9]/.test(a.substr(0,1))&&!/[^a-zA-Z0-9\.\-]/.test(a)&&1===a.split("..").length&&a.split(".").length>1},errorMessage:"",errorMessageKey:"badDomain"}),a.formUtils.addValidator({name:"required",validatorFunction:function(b,c,d,e,f){switch(c.attr("type")){case"checkbox":return c.is(":checked");case"radio":return f.find('input[name="'+c.attr("name")+'"]').filter(":checked").length>0;default:return""!==a.trim(b)}},errorMessage:"",errorMessageKey:function(a){return"top"===a.errorMessagePosition||"function"==typeof a.errorMessagePosition?"requiredFields":"requiredField"}}),a.formUtils.addValidator({name:"length",validatorFunction:function(b,c,d,e){var f=c.valAttr("length"),g=c.attr("type");if(void 0===f)return alert('Please add attribute "data-validation-length" to '+c[0].nodeName+" named "+c.attr("name")),!0;var h,i="file"===g&&void 0!==c.get(0).files?c.get(0).files.length:b.length,j=a.formUtils.numericRangeCheck(i,f);switch(j[0]){case"out":this.errorMessage=e.lengthBadStart+f+e.lengthBadEnd,h=!1;break;case"min":this.errorMessage=e.lengthTooShortStart+j[1]+e.lengthBadEnd,h=!1;break;case"max":this.errorMessage=e.lengthTooLongStart+j[1]+e.lengthBadEnd,h=!1;break;default:h=!0}return h},errorMessage:"",errorMessageKey:""}),a.formUtils.addValidator({name:"url",validatorFunction:function(b){var c=/^(https?|ftp):\/\/((((\w|-|\.|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])(\w|-|\.|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])(\w|-|\.|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/(((\w|-|\.|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/((\w|-|\.|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|\[|\]|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#(((\w|-|\.|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;if(c.test(b)){var d=b.split("://")[1],e=d.indexOf("/");return e>-1&&(d=d.substr(0,e)),a.formUtils.validators.validate_domain.validatorFunction(d)}return!1},errorMessage:"",errorMessageKey:"badUrl"}),a.formUtils.addValidator({name:"number",validatorFunction:function(a,b,c){if(""!==a){var d,e,f=b.valAttr("allowing")||"",g=b.valAttr("decimal-separator")||c.decimalSeparator,h=!1,i=b.valAttr("step")||"",j=!1,k=b.attr("data-sanitize")||"",l=k.match(/(^|[\s])numberFormat([\s]|$)/i);if(l){if(!window.numeral)throw new ReferenceError("The data-sanitize value numberFormat cannot be used without the numeral library. Please see Data Validation in http://www.formvalidator.net for more information.");a.length&&(a=String(numeral().unformat(a)))}if(f.indexOf("number")===-1&&(f+=",number"),f.indexOf("negative")===-1&&0===a.indexOf("-"))return!1;if(f.indexOf("range")>-1&&(d=parseFloat(f.substring(f.indexOf("[")+1,f.indexOf(";"))),e=parseFloat(f.substring(f.indexOf(";")+1,f.indexOf("]"))),h=!0),""!==i&&(j=!0),","===g){if(a.indexOf(".")>-1)return!1;a=a.replace(",",".")}if(""===a.replace(/[0-9-]/g,"")&&(!h||a>=d&&a<=e)&&(!j||a%i===0))return!0;if(f.indexOf("float")>-1&&null!==a.match(new RegExp("^([0-9-]+)\\.([0-9]+)$"))&&(!h||a>=d&&a<=e)&&(!j||a%i===0))return!0}return!1},errorMessage:"",errorMessageKey:"badInt"}),a.formUtils.addValidator({name:"alphanumeric",validatorFunction:function(b,c,d,e){var f="^([a-zA-Z0-9",g="]+)$",h=c.valAttr("allowing"),i="",j=!1;if(h){i=f+h+g;var k=h.replace(/\\/g,"");k.indexOf(" ")>-1&&(j=!0,k=k.replace(" ",""),k+=e.andSpaces||a.formUtils.LANG.andSpaces),e.badAlphaNumericAndExtraAndSpaces&&e.badAlphaNumericAndExtra?j?this.errorMessage=e.badAlphaNumericAndExtraAndSpaces+k:this.errorMessage=e.badAlphaNumericAndExtra+k+e.badAlphaNumericExtra:this.errorMessage=e.badAlphaNumeric+e.badAlphaNumericExtra+k}else i=f+g,this.errorMessage=e.badAlphaNumeric;
    return new RegExp(i).test(b)},errorMessage:"",errorMessageKey:""}),a.formUtils.addValidator({name:"custom",validatorFunction:function(a,b){var c=new RegExp(b.valAttr("regexp"));return c.test(a)},errorMessage:"",errorMessageKey:"badCustomVal"}),a.formUtils.addValidator({name:"date",validatorFunction:function(b,c,d){var e=c.valAttr("format")||d.dateFormat||"yyyy-mm-dd",f="false"===c.valAttr("require-leading-zero");return a.formUtils.parseDate(b,e,f)!==!1},errorMessage:"",errorMessageKey:"badDate"}),a.formUtils.addValidator({name:"checkbox_group",validatorFunction:function(b,c,d,e,f){var g=!0,h=c.attr("name"),i=a('input[type=checkbox][name^="'+h+'"]',f),j=i.filter(":checked").length,k=c.valAttr("qty");if(void 0===k){var l=c.get(0).nodeName;alert('Attribute "data-validation-qty" is missing from '+l+" named "+c.attr("name"))}var m=a.formUtils.numericRangeCheck(j,k);switch(m[0]){case"out":this.errorMessage=e.groupCheckedRangeStart+k+e.groupCheckedEnd,g=!1;break;case"min":this.errorMessage=e.groupCheckedTooFewStart+m[1]+(e.groupCheckedTooFewEnd||e.groupCheckedEnd),g=!1;break;case"max":this.errorMessage=e.groupCheckedTooManyStart+m[1]+(e.groupCheckedTooManyEnd||e.groupCheckedEnd),g=!1;break;default:g=!0}if(!g){var n=function(){i.unbind("click",n),i.filter("*[data-validation]").validateInputOnBlur(e,d,!1,"blur")};i.bind("click",n)}return g}})}(a)});
    ; browserify_shim__define__module__export__(typeof jqueryFormValidator != "undefined" ? jqueryFormValidator : window.jqueryFormValidator);
    
    }).call(global, undefined, undefined, undefined, undefined, function defineExport(ex) { module.exports = ex; });
    
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    },{"jQuery":60}],54:[function(require,module,exports){
    /** File generated by Grunt -- do not modify
     *  JQUERY-FORM-VALIDATOR
     *
     *  @version 2.3.77
     *  @website http://formvalidator.net/
     *  @author Victor Jonsson, http://victorjonsson.se
     *  @license MIT
     */
    !function(a,b){"function"==typeof define&&define.amd?define(["jquery"],function(a){return b(a)}):"object"==typeof module&&module.exports?module.exports=b(require("jquery")):b(a.jQuery)}(this,function(a){!function(a,b){"use strict";a.formUtils.registerLoadedModule("security"),a.formUtils.addValidator({name:"spamcheck",validatorFunction:function(a,b){var c=b.valAttr("captcha");return c===a},errorMessage:"",errorMessageKey:"badSecurityAnswer"}),a.formUtils.addValidator({name:"confirmation",validatorFunction:function(b,c,d,e,f){var g,h=c.valAttr("confirm")||c.attr("name")+"_confirmation",i=f.find('[name="'+h+'"]');if(!i.length)return a.formUtils.warn('Password confirmation validator: could not find an input with name "'+h+'"',!0),!1;if(g=i.val(),d.validateOnBlur&&!i[0].hasValidationCallback){i[0].hasValidationCallback=!0;var j=function(){c.validate()};i.on("keyup",j),f.one("formValidationSetup",function(){i[0].hasValidationCallback=!1,i.off("keyup",j)})}return b===g},errorMessage:"",errorMessageKey:"notConfirmed"});var c={amex:[15,15],diners_club:[14,14],cjb:[16,16],laser:[16,19],visa:[16,16],mastercard:[16,16],maestro:[12,19],discover:[16,16]},d=!1,e=!1;a.formUtils.addValidator({name:"creditcard",validatorFunction:function(b,f){var g=a.split(f.valAttr("allowing")||"");if(e=a.inArray("amex",g)>-1,d=e&&1===g.length,g.length>0){var h=!1;if(a.each(g,function(d,e){if(e in c){if(b.length>=c[e][0]&&b.length<=c[e][1])return h=!0,!1}else a.formUtils.warn('Use of unknown credit card "'+e+'"',!0)}),!h)return!1}if(""!==b.replace(new RegExp("[0-9]","g"),""))return!1;var i=0;return a.each(b.split("").reverse(),function(a,b){b=parseInt(b,10),a%2===0?i+=b:(b*=2,i+=b<10?b:b-9)}),i%10===0},errorMessage:"",errorMessageKey:"badCreditCard"}),a.formUtils.addValidator({name:"cvv",validatorFunction:function(a){return""===a.replace(/[0-9]/g,"")&&(a+="",d?4===a.length:e?3===a.length||4===a.length:3===a.length)},errorMessage:"",errorMessageKey:"badCVV"}),a.formUtils.addValidator({name:"strength",validatorFunction:function(b,c){var d=c.valAttr("strength")||2;return d&&d>3&&(d=3),a.formUtils.validators.validate_strength.calculatePasswordStrength(b)>=d},errorMessage:"",errorMessageKey:"badStrength",calculatePasswordStrength:function(a){if(a.length<4)return 0;var b=0,c=function(a,b){for(var c="",d=0;d<b.length;d++){for(var e=!0,f=0;f<a&&f+d+a<b.length;f++)e=e&&b.charAt(f+d)===b.charAt(f+d+a);f<a&&(e=!1),e?(d+=a-1,e=!1):c+=b.charAt(d)}return c};return b+=4*a.length,b+=1*(c(1,a).length-a.length),b+=1*(c(2,a).length-a.length),b+=1*(c(3,a).length-a.length),b+=1*(c(4,a).length-a.length),a.match(/(.*[0-9].*[0-9].*[0-9])/)&&(b+=5),a.match(/(.*[!,@,#,$,%,^,&,*,?,_,~].*[!,@,#,$,%,^,&,*,?,_,~])/)&&(b+=5),a.match(/([a-z].*[A-Z])|([A-Z].*[a-z])/)&&(b+=10),a.match(/([a-zA-Z])/)&&a.match(/([0-9])/)&&(b+=15),a.match(/([!,@,#,$,%,^,&,*,?,_,~])/)&&a.match(/([0-9])/)&&(b+=15),a.match(/([!,@,#,$,%,^,&,*,?,_,~])/)&&a.match(/([a-zA-Z])/)&&(b+=15),(a.match(/^\w+$/)||a.match(/^\d+$/))&&(b-=10),b<0&&(b=0),b>100&&(b=100),b<20?0:b<40?1:b<=60?2:3},strengthDisplay:function(b,c){var d={fontSize:"12pt",padding:"4px",bad:"Very bad",weak:"Weak",good:"Good",strong:"Strong"};c&&a.extend(d,c),b.bind("keyup",function(){var b=a(this).val(),c="undefined"==typeof d.parent?a(this).parent():a(d.parent),e=c.find(".strength-meter"),f=a.formUtils.validators.validate_strength.calculatePasswordStrength(b),g={background:"pink",color:"#FF0000",fontWeight:"bold",border:"red solid 1px",borderWidth:"0px 0px 4px",display:"inline-block",fontSize:d.fontSize,padding:d.padding},h=d.bad;0===e.length&&(e=a("<span></span>"),e.addClass("strength-meter").appendTo(c)),b?e.show():e.hide(),1===f?h=d.weak:2===f?(g.background="lightyellow",g.borderColor="yellow",g.color="goldenrod",h=d.good):f>=3&&(g.background="lightgreen",g.borderColor="darkgreen",g.color="darkgreen",h=d.strong),e.css(g).text(h)})}});var f=function(b,c,d,e,f){var g=c.valAttr("req-params")||c.data("validation-req-params")||{},h=c.valAttr("param-name")||c.attr("name"),i=function(a,b){b(a)};if(!h)throw new Error("Missing input name used for http requests made by server validator");g||(g={}),"string"==typeof g&&(g=a.parseJSON(g)),g[h]=d,a.ajax({url:b,type:"POST",cache:!1,data:g,dataType:"json",error:function(a){return i({valid:!1,message:"Connection failed with status: "+a.statusText},f),!1},success:function(a){i(a,f)}})};a.formUtils.addAsyncValidator({name:"server",validatorFunction:function(a,b,c,d,e,g){var h=c.valAttr("url")||d.backendUrl||document.location.href;g.addClass("validating-server-side"),c.addClass("validating-server-side"),f(h,c,b,d,function(b){g.removeClass("validating-server-side"),c.removeClass("validating-server-side"),b.message&&c.attr(d.validationErrorMsgAttribute,b.message),a(b.valid)})},errorMessage:"",errorMessageKey:"badBackend"}),a.formUtils.addValidator({name:"letternumeric",validatorFunction:function(b,c,d,e){var f="^([a-zA-Z0-9-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------",g="]+)$",h=c.valAttr("allowing"),i="";if(h){i=f+h+g;var j=h.replace(/\\/g,"");j.indexOf(" ")>-1&&(j=j.replace(" ",""),j+=e.andSpaces||a.formUtils.LANG.andSpaces),this.errorMessage=e.badAlphaNumeric+e.badAlphaNumericExtra+j}else i=f+g,this.errorMessage=e.badAlphaNumeric;return new RegExp(i).test(b)},errorMessage:"",errorMessageKey:"requiredFields"}),a.formUtils.addValidator({name:"complexity",validatorFunction:function(b,c,d,e){var f=c.valAttr("require-uc-letter")||"0",g=c.valAttr("require-lc-letter")||"0",h=c.valAttr("require-special-char")||"0",i=c.valAttr("require-numeral")||"0",j=c.valAttr("require-length")||"0",k={"uc-letter":{pattern:"^(?=(?:.*[A-Z]){"+f+",}).+",numRequired:f,dialogEnd:e.passwordComplexityUppercaseInfo},"lc-letter":{pattern:"^(?=(?:.*[a-z]){"+g+",}).+",numRequired:g,dialogEnd:e.passwordComplexityLowercaseInfo},"special-char":{pattern:"^(?=(?:.*(_|[!\"#$%&'()*+\\\\,-./:;<=>?@[\\]^_`{|}~])){"+h+",}).+",numRequired:h,dialogEnd:e.passwordComplexitySpecialCharsInfo},numeral:{pattern:"^(?=(?:.*\\d){"+i+",}).+",numRequired:i,dialogEnd:e.passwordComplexityNumericCharsInfo},length:{callback:function(a){return a.length>=j},numRequired:j,dialogEnd:e.lengthBadEnd}},l="";return a.each(k,function(a,d){var f=parseInt(d.numRequired,10);if(f){var g=new RegExp(d.pattern),h=!1;h=d.callback?d.callback(b):g.test(b),h?c.trigger("complexityRequirementValidation",[!0,a]):(""===l&&(l=e.passwordComplexityStart),l+=e.passwordComplexitySeparator+f+d.dialogEnd,c.trigger("complexityRequirementValidation",[!1,a]))}}),!l||(this.errorMessage=l+e.passwordComplexityEnd,!1)},errorMessage:"",errorMessageKey:""}),a.formUtils.addValidator({name:"recaptcha",validatorFunction:function(a,b){return""!==grecaptcha.getResponse(b.valAttr("recaptcha-widget-id"))},errorMessage:"",errorMessageKey:"badreCaptcha"}),a.fn.displayPasswordStrength=function(b){return new a.formUtils.validators.validate_strength.strengthDisplay(this,b),this};var g=function(b,c,d){if(c||(c=a("form")),"undefined"!=typeof grecaptcha&&!a.formUtils.hasLoadedGrecaptcha)throw new Error("reCaptcha API can not be loaded by hand, delete reCaptcha API snippet.");if(!a.formUtils.hasLoadedGrecaptcha&&a('[data-validation~="recaptcha"]',c).length){a.formUtils.hasLoadedGrecaptcha=!0;var e="//www.google.com/recaptcha/api.js?onload=reCaptchaLoaded&render=explicit"+(d.lang?"&hl="+d.lang:""),f=document.createElement("script");f.type="text/javascript",f.async=!0,f.defer=!0,f.src=e,document.getElementsByTagName("body")[0].appendChild(f)}};b.reCaptchaLoaded=function(b){b&&"object"==typeof b&&b.length||(b=a("form")),b.each(function(){var b=a(this),c=b.get(0).validationConfig||b.context.validationConfig||!1;c&&a('[data-validation~="recaptcha"]',b).each(function(){var d=a(this),e=document.createElement("DIV"),f=c.reCaptchaSiteKey||d.valAttr("recaptcha-sitekey"),g=c.reCaptchaTheme||d.valAttr("recaptcha-theme")||"light",h=c.reCaptchaSize||d.valAttr("recaptcha-size")||"normal",i=c.reCaptchaType||d.valAttr("recaptcha-type")||"image";if(!f)throw new Error("Google reCaptcha site key is required.");var j=grecaptcha.render(e,{sitekey:f,theme:g,size:h,type:i,callback:function(a){b.find('[data-validation~="recaptcha"]').trigger("validation",a&&""!==a)},"expired-callback":function(){b.find('[data-validation~="recaptcha"]').trigger("validation",!1)}});d.valAttr("recaptcha-widget-id",j).hide().on("beforeValidation",function(a){a.stopImmediatePropagation()}).parent().append(e)})})},a(b).on("validatorsLoaded formValidationSetup",g)}(a,window)});
    },{"jquery":63}],55:[function(require,module,exports){
    (function (global){
    
    ; $ = global.$ = require("jQuery");
    ; var __browserify_shim_require__=require;(function browserifyShim(module, exports, require, define, browserify_shim__define__module__export__) {
    /*!
     * JavaScript Cookie v2.1.4
     * https://github.com/js-cookie/js-cookie
     *
     * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
     * Released under the MIT license
     */
    ;(function (factory) {
        var registeredInModuleLoader = false;
        if (typeof define === 'function' && define.amd) {
            define(factory);
            registeredInModuleLoader = true;
        }
        if (typeof exports === 'object') {
            module.exports = factory();
            registeredInModuleLoader = true;
        }
        if (!registeredInModuleLoader) {
            var OldCookies = window.Cookies;
            var api = window.Cookies = factory();
            api.noConflict = function () {
                window.Cookies = OldCookies;
                return api;
            };
        }
    }(function () {
        function extend () {
            var i = 0;
            var result = {};
            for (; i < arguments.length; i++) {
                var attributes = arguments[ i ];
                for (var key in attributes) {
                    result[key] = attributes[key];
                }
            }
            return result;
        }
    
        function init (converter) {
            function api (key, value, attributes) {
                var result;
                if (typeof document === 'undefined') {
                    return;
                }
    
                // Write
    
                if (arguments.length > 1) {
                    attributes = extend({
                        path: '/'
                    }, api.defaults, attributes);
    
                    if (typeof attributes.expires === 'number') {
                        var expires = new Date();
                        expires.setMilliseconds(expires.getMilliseconds() + attributes.expires * 864e+5);
                        attributes.expires = expires;
                    }
    
                    // We're using "expires" because "max-age" is not supported by IE
                    attributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';
    
                    try {
                        result = JSON.stringify(value);
                        if (/^[\{\[]/.test(result)) {
                            value = result;
                        }
                    } catch (e) {}
    
                    if (!converter.write) {
                        value = encodeURIComponent(String(value))
                            .replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
                    } else {
                        value = converter.write(value, key);
                    }
    
                    key = encodeURIComponent(String(key));
                    key = key.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent);
                    key = key.replace(/[\(\)]/g, escape);
    
                    var stringifiedAttributes = '';
    
                    for (var attributeName in attributes) {
                        if (!attributes[attributeName]) {
                            continue;
                        }
                        stringifiedAttributes += '; ' + attributeName;
                        if (attributes[attributeName] === true) {
                            continue;
                        }
                        stringifiedAttributes += '=' + attributes[attributeName];
                    }
                    return (document.cookie = key + '=' + value + stringifiedAttributes);
                }
    
                // Read
    
                if (!key) {
                    result = {};
                }
    
                // To prevent the for loop in the first place assign an empty array
                // in case there are no cookies at all. Also prevents odd result when
                // calling "get()"
                var cookies = document.cookie ? document.cookie.split('; ') : [];
                var rdecode = /(%[0-9A-Z]{2})+/g;
                var i = 0;
    
                for (; i < cookies.length; i++) {
                    var parts = cookies[i].split('=');
                    var cookie = parts.slice(1).join('=');
    
                    if (cookie.charAt(0) === '"') {
                        cookie = cookie.slice(1, -1);
                    }
    
                    try {
                        var name = parts[0].replace(rdecode, decodeURIComponent);
                        cookie = converter.read ?
                            converter.read(cookie, name) : converter(cookie, name) ||
                            cookie.replace(rdecode, decodeURIComponent);
    
                        if (this.json) {
                            try {
                                cookie = JSON.parse(cookie);
                            } catch (e) {}
                        }
    
                        if (key === name) {
                            result = cookie;
                            break;
                        }
    
                        if (!key) {
                            result[name] = cookie;
                        }
                    } catch (e) {}
                }
    
                return result;
            }
    
            api.set = api;
            api.get = function (key) {
                return api.call(api, key);
            };
            api.getJSON = function () {
                return api.apply({
                    json: true
                }, [].slice.call(arguments));
            };
            api.defaults = {};
    
            api.remove = function (key, attributes) {
                api(key, '', extend(attributes, {
                    expires: -1
                }));
            };
    
            api.withConverter = init;
    
            return api;
        }
    
        return init(function () {});
    }));
    
    ; browserify_shim__define__module__export__(typeof cookie != "undefined" ? cookie : window.cookie);
    
    }).call(global, undefined, undefined, undefined, undefined, function defineExport(ex) { module.exports = ex; });
    
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    },{"jQuery":60}],56:[function(require,module,exports){
    (function (global){
    
    ; $ = global.$ = require("jQuery");
    ; var __browserify_shim_require__=require;(function browserifyShim(module, exports, require, define, browserify_shim__define__module__export__) {
    /*!
     * typeahead.js 0.11.1
     * https://github.com/twitter/typeahead.js
     * Copyright 2013-2015 Twitter, Inc. and other contributors; Licensed MIT
     */
    
    (function(root, factory) {
        if (typeof define === "function" && define.amd) {
            define("bloodhound", [ "jquery" ], function(a0) {
                return root["Bloodhound"] = factory(a0);
            });
        } else if (typeof exports === "object") {
            module.exports = factory(__browserify_shim_require__("jquery"));
        } else {
            root["Bloodhound"] = factory(jQuery);
        }
    })(this, function($) {
        var _ = function() {
            "use strict";
            return {
                isMsie: function() {
                    return /(msie|trident)/i.test(navigator.userAgent) ? navigator.userAgent.match(/(msie |rv:)(\d+(.\d+)?)/i)[2] : false;
                },
                isBlankString: function(str) {
                    return !str || /^\s*$/.test(str);
                },
                escapeRegExChars: function(str) {
                    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
                },
                isString: function(obj) {
                    return typeof obj === "string";
                },
                isNumber: function(obj) {
                    return typeof obj === "number";
                },
                isArray: $.isArray,
                isFunction: $.isFunction,
                isObject: $.isPlainObject,
                isUndefined: function(obj) {
                    return typeof obj === "undefined";
                },
                isElement: function(obj) {
                    return !!(obj && obj.nodeType === 1);
                },
                isJQuery: function(obj) {
                    return obj instanceof $;
                },
                toStr: function toStr(s) {
                    return _.isUndefined(s) || s === null ? "" : s + "";
                },
                bind: $.proxy,
                each: function(collection, cb) {
                    $.each(collection, reverseArgs);
                    function reverseArgs(index, value) {
                        return cb(value, index);
                    }
                },
                map: $.map,
                filter: $.grep,
                every: function(obj, test) {
                    var result = true;
                    if (!obj) {
                        return result;
                    }
                    $.each(obj, function(key, val) {
                        if (!(result = test.call(null, val, key, obj))) {
                            return false;
                        }
                    });
                    return !!result;
                },
                some: function(obj, test) {
                    var result = false;
                    if (!obj) {
                        return result;
                    }
                    $.each(obj, function(key, val) {
                        if (result = test.call(null, val, key, obj)) {
                            return false;
                        }
                    });
                    return !!result;
                },
                mixin: $.extend,
                identity: function(x) {
                    return x;
                },
                clone: function(obj) {
                    return $.extend(true, {}, obj);
                },
                getIdGenerator: function() {
                    var counter = 0;
                    return function() {
                        return counter++;
                    };
                },
                templatify: function templatify(obj) {
                    return $.isFunction(obj) ? obj : template;
                    function template() {
                        return String(obj);
                    }
                },
                defer: function(fn) {
                    setTimeout(fn, 0);
                },
                debounce: function(func, wait, immediate) {
                    var timeout, result;
                    return function() {
                        var context = this, args = arguments, later, callNow;
                        later = function() {
                            timeout = null;
                            if (!immediate) {
                                result = func.apply(context, args);
                            }
                        };
                        callNow = immediate && !timeout;
                        clearTimeout(timeout);
                        timeout = setTimeout(later, wait);
                        if (callNow) {
                            result = func.apply(context, args);
                        }
                        return result;
                    };
                },
                throttle: function(func, wait) {
                    var context, args, timeout, result, previous, later;
                    previous = 0;
                    later = function() {
                        previous = new Date();
                        timeout = null;
                        result = func.apply(context, args);
                    };
                    return function() {
                        var now = new Date(), remaining = wait - (now - previous);
                        context = this;
                        args = arguments;
                        if (remaining <= 0) {
                            clearTimeout(timeout);
                            timeout = null;
                            previous = now;
                            result = func.apply(context, args);
                        } else if (!timeout) {
                            timeout = setTimeout(later, remaining);
                        }
                        return result;
                    };
                },
                stringify: function(val) {
                    return _.isString(val) ? val : JSON.stringify(val);
                },
                noop: function() {}
            };
        }();
        var VERSION = "0.11.1";
        var tokenizers = function() {
            "use strict";
            return {
                nonword: nonword,
                whitespace: whitespace,
                obj: {
                    nonword: getObjTokenizer(nonword),
                    whitespace: getObjTokenizer(whitespace)
                }
            };
            function whitespace(str) {
                str = _.toStr(str);
                return str ? str.split(/\s+/) : [];
            }
            function nonword(str) {
                str = _.toStr(str);
                return str ? str.split(/\W+/) : [];
            }
            function getObjTokenizer(tokenizer) {
                return function setKey(keys) {
                    keys = _.isArray(keys) ? keys : [].slice.call(arguments, 0);
                    return function tokenize(o) {
                        var tokens = [];
                        _.each(keys, function(k) {
                            tokens = tokens.concat(tokenizer(_.toStr(o[k])));
                        });
                        return tokens;
                    };
                };
            }
        }();
        var LruCache = function() {
            "use strict";
            function LruCache(maxSize) {
                this.maxSize = _.isNumber(maxSize) ? maxSize : 100;
                this.reset();
                if (this.maxSize <= 0) {
                    this.set = this.get = $.noop;
                }
            }
            _.mixin(LruCache.prototype, {
                set: function set(key, val) {
                    var tailItem = this.list.tail, node;
                    if (this.size >= this.maxSize) {
                        this.list.remove(tailItem);
                        delete this.hash[tailItem.key];
                        this.size--;
                    }
                    if (node = this.hash[key]) {
                        node.val = val;
                        this.list.moveToFront(node);
                    } else {
                        node = new Node(key, val);
                        this.list.add(node);
                        this.hash[key] = node;
                        this.size++;
                    }
                },
                get: function get(key) {
                    var node = this.hash[key];
                    if (node) {
                        this.list.moveToFront(node);
                        return node.val;
                    }
                },
                reset: function reset() {
                    this.size = 0;
                    this.hash = {};
                    this.list = new List();
                }
            });
            function List() {
                this.head = this.tail = null;
            }
            _.mixin(List.prototype, {
                add: function add(node) {
                    if (this.head) {
                        node.next = this.head;
                        this.head.prev = node;
                    }
                    this.head = node;
                    this.tail = this.tail || node;
                },
                remove: function remove(node) {
                    node.prev ? node.prev.next = node.next : this.head = node.next;
                    node.next ? node.next.prev = node.prev : this.tail = node.prev;
                },
                moveToFront: function(node) {
                    this.remove(node);
                    this.add(node);
                }
            });
            function Node(key, val) {
                this.key = key;
                this.val = val;
                this.prev = this.next = null;
            }
            return LruCache;
        }();
        var PersistentStorage = function() {
            "use strict";
            var LOCAL_STORAGE;
            try {
                LOCAL_STORAGE = window.localStorage;
                LOCAL_STORAGE.setItem("~~~", "!");
                LOCAL_STORAGE.removeItem("~~~");
            } catch (err) {
                LOCAL_STORAGE = null;
            }
            function PersistentStorage(namespace, override) {
                this.prefix = [ "__", namespace, "__" ].join("");
                this.ttlKey = "__ttl__";
                this.keyMatcher = new RegExp("^" + _.escapeRegExChars(this.prefix));
                this.ls = override || LOCAL_STORAGE;
                !this.ls && this._noop();
            }
            _.mixin(PersistentStorage.prototype, {
                _prefix: function(key) {
                    return this.prefix + key;
                },
                _ttlKey: function(key) {
                    return this._prefix(key) + this.ttlKey;
                },
                _noop: function() {
                    this.get = this.set = this.remove = this.clear = this.isExpired = _.noop;
                },
                _safeSet: function(key, val) {
                    try {
                        this.ls.setItem(key, val);
                    } catch (err) {
                        if (err.name === "QuotaExceededError") {
                            this.clear();
                            this._noop();
                        }
                    }
                },
                get: function(key) {
                    if (this.isExpired(key)) {
                        this.remove(key);
                    }
                    return decode(this.ls.getItem(this._prefix(key)));
                },
                set: function(key, val, ttl) {
                    if (_.isNumber(ttl)) {
                        this._safeSet(this._ttlKey(key), encode(now() + ttl));
                    } else {
                        this.ls.removeItem(this._ttlKey(key));
                    }
                    return this._safeSet(this._prefix(key), encode(val));
                },
                remove: function(key) {
                    this.ls.removeItem(this._ttlKey(key));
                    this.ls.removeItem(this._prefix(key));
                    return this;
                },
                clear: function() {
                    var i, keys = gatherMatchingKeys(this.keyMatcher);
                    for (i = keys.length; i--; ) {
                        this.remove(keys[i]);
                    }
                    return this;
                },
                isExpired: function(key) {
                    var ttl = decode(this.ls.getItem(this._ttlKey(key)));
                    return _.isNumber(ttl) && now() > ttl ? true : false;
                }
            });
            return PersistentStorage;
            function now() {
                return new Date().getTime();
            }
            function encode(val) {
                return JSON.stringify(_.isUndefined(val) ? null : val);
            }
            function decode(val) {
                return $.parseJSON(val);
            }
            function gatherMatchingKeys(keyMatcher) {
                var i, key, keys = [], len = LOCAL_STORAGE.length;
                for (i = 0; i < len; i++) {
                    if ((key = LOCAL_STORAGE.key(i)).match(keyMatcher)) {
                        keys.push(key.replace(keyMatcher, ""));
                    }
                }
                return keys;
            }
        }();
        var Transport = function() {
            "use strict";
            var pendingRequestsCount = 0, pendingRequests = {}, maxPendingRequests = 6, sharedCache = new LruCache(10);
            function Transport(o) {
                o = o || {};
                this.cancelled = false;
                this.lastReq = null;
                this._send = o.transport;
                this._get = o.limiter ? o.limiter(this._get) : this._get;
                this._cache = o.cache === false ? new LruCache(0) : sharedCache;
            }
            Transport.setMaxPendingRequests = function setMaxPendingRequests(num) {
                maxPendingRequests = num;
            };
            Transport.resetCache = function resetCache() {
                sharedCache.reset();
            };
            _.mixin(Transport.prototype, {
                _fingerprint: function fingerprint(o) {
                    o = o || {};
                    return o.url + o.type + $.param(o.data || {});
                },
                _get: function(o, cb) {
                    var that = this, fingerprint, jqXhr;
                    fingerprint = this._fingerprint(o);
                    if (this.cancelled || fingerprint !== this.lastReq) {
                        return;
                    }
                    if (jqXhr = pendingRequests[fingerprint]) {
                        jqXhr.done(done).fail(fail);
                    } else if (pendingRequestsCount < maxPendingRequests) {
                        pendingRequestsCount++;
                        pendingRequests[fingerprint] = this._send(o).done(done).fail(fail).always(always);
                    } else {
                        this.onDeckRequestArgs = [].slice.call(arguments, 0);
                    }
                    function done(resp) {
                        cb(null, resp);
                        that._cache.set(fingerprint, resp);
                    }
                    function fail() {
                        cb(true);
                    }
                    function always() {
                        pendingRequestsCount--;
                        delete pendingRequests[fingerprint];
                        if (that.onDeckRequestArgs) {
                            that._get.apply(that, that.onDeckRequestArgs);
                            that.onDeckRequestArgs = null;
                        }
                    }
                },
                get: function(o, cb) {
                    var resp, fingerprint;
                    cb = cb || $.noop;
                    o = _.isString(o) ? {
                        url: o
                    } : o || {};
                    fingerprint = this._fingerprint(o);
                    this.cancelled = false;
                    this.lastReq = fingerprint;
                    if (resp = this._cache.get(fingerprint)) {
                        cb(null, resp);
                    } else {
                        this._get(o, cb);
                    }
                },
                cancel: function() {
                    this.cancelled = true;
                }
            });
            return Transport;
        }();
        var SearchIndex = window.SearchIndex = function() {
            "use strict";
            var CHILDREN = "c", IDS = "i";
            function SearchIndex(o) {
                o = o || {};
                if (!o.datumTokenizer || !o.queryTokenizer) {
                    $.error("datumTokenizer and queryTokenizer are both required");
                }
                this.identify = o.identify || _.stringify;
                this.datumTokenizer = o.datumTokenizer;
                this.queryTokenizer = o.queryTokenizer;
                this.reset();
            }
            _.mixin(SearchIndex.prototype, {
                bootstrap: function bootstrap(o) {
                    this.datums = o.datums;
                    this.trie = o.trie;
                },
                add: function(data) {
                    var that = this;
                    data = _.isArray(data) ? data : [ data ];
                    _.each(data, function(datum) {
                        var id, tokens;
                        that.datums[id = that.identify(datum)] = datum;
                        tokens = normalizeTokens(that.datumTokenizer(datum));
                        _.each(tokens, function(token) {
                            var node, chars, ch;
                            node = that.trie;
                            chars = token.split("");
                            while (ch = chars.shift()) {
                                node = node[CHILDREN][ch] || (node[CHILDREN][ch] = newNode());
                                node[IDS].push(id);
                            }
                        });
                    });
                },
                get: function get(ids) {
                    var that = this;
                    return _.map(ids, function(id) {
                        return that.datums[id];
                    });
                },
                search: function search(query) {
                    var that = this, tokens, matches;
                    tokens = normalizeTokens(this.queryTokenizer(query));
                    _.each(tokens, function(token) {
                        var node, chars, ch, ids;
                        if (matches && matches.length === 0) {
                            return false;
                        }
                        node = that.trie;
                        chars = token.split("");
                        while (node && (ch = chars.shift())) {
                            node = node[CHILDREN][ch];
                        }
                        if (node && chars.length === 0) {
                            ids = node[IDS].slice(0);
                            matches = matches ? getIntersection(matches, ids) : ids;
                        } else {
                            matches = [];
                            return false;
                        }
                    });
                    return matches ? _.map(unique(matches), function(id) {
                        return that.datums[id];
                    }) : [];
                },
                all: function all() {
                    var values = [];
                    for (var key in this.datums) {
                        values.push(this.datums[key]);
                    }
                    return values;
                },
                reset: function reset() {
                    this.datums = {};
                    this.trie = newNode();
                },
                serialize: function serialize() {
                    return {
                        datums: this.datums,
                        trie: this.trie
                    };
                }
            });
            return SearchIndex;
            function normalizeTokens(tokens) {
                tokens = _.filter(tokens, function(token) {
                    return !!token;
                });
                tokens = _.map(tokens, function(token) {
                    return token.toLowerCase();
                });
                return tokens;
            }
            function newNode() {
                var node = {};
                node[IDS] = [];
                node[CHILDREN] = {};
                return node;
            }
            function unique(array) {
                var seen = {}, uniques = [];
                for (var i = 0, len = array.length; i < len; i++) {
                    if (!seen[array[i]]) {
                        seen[array[i]] = true;
                        uniques.push(array[i]);
                    }
                }
                return uniques;
            }
            function getIntersection(arrayA, arrayB) {
                var ai = 0, bi = 0, intersection = [];
                arrayA = arrayA.sort();
                arrayB = arrayB.sort();
                var lenArrayA = arrayA.length, lenArrayB = arrayB.length;
                while (ai < lenArrayA && bi < lenArrayB) {
                    if (arrayA[ai] < arrayB[bi]) {
                        ai++;
                    } else if (arrayA[ai] > arrayB[bi]) {
                        bi++;
                    } else {
                        intersection.push(arrayA[ai]);
                        ai++;
                        bi++;
                    }
                }
                return intersection;
            }
        }();
        var Prefetch = function() {
            "use strict";
            var keys;
            keys = {
                data: "data",
                protocol: "protocol",
                thumbprint: "thumbprint"
            };
            function Prefetch(o) {
                this.url = o.url;
                this.ttl = o.ttl;
                this.cache = o.cache;
                this.prepare = o.prepare;
                this.transform = o.transform;
                this.transport = o.transport;
                this.thumbprint = o.thumbprint;
                this.storage = new PersistentStorage(o.cacheKey);
            }
            _.mixin(Prefetch.prototype, {
                _settings: function settings() {
                    return {
                        url: this.url,
                        type: "GET",
                        dataType: "json"
                    };
                },
                store: function store(data) {
                    if (!this.cache) {
                        return;
                    }
                    this.storage.set(keys.data, data, this.ttl);
                    this.storage.set(keys.protocol, location.protocol, this.ttl);
                    this.storage.set(keys.thumbprint, this.thumbprint, this.ttl);
                },
                fromCache: function fromCache() {
                    var stored = {}, isExpired;
                    if (!this.cache) {
                        return null;
                    }
                    stored.data = this.storage.get(keys.data);
                    stored.protocol = this.storage.get(keys.protocol);
                    stored.thumbprint = this.storage.get(keys.thumbprint);
                    isExpired = stored.thumbprint !== this.thumbprint || stored.protocol !== location.protocol;
                    return stored.data && !isExpired ? stored.data : null;
                },
                fromNetwork: function(cb) {
                    var that = this, settings;
                    if (!cb) {
                        return;
                    }
                    settings = this.prepare(this._settings());
                    this.transport(settings).fail(onError).done(onResponse);
                    function onError() {
                        cb(true);
                    }
                    function onResponse(resp) {
                        cb(null, that.transform(resp));
                    }
                },
                clear: function clear() {
                    this.storage.clear();
                    return this;
                }
            });
            return Prefetch;
        }();
        var Remote = function() {
            "use strict";
            function Remote(o) {
                this.url = o.url;
                this.prepare = o.prepare;
                this.transform = o.transform;
                this.transport = new Transport({
                    cache: o.cache,
                    limiter: o.limiter,
                    transport: o.transport
                });
            }
            _.mixin(Remote.prototype, {
                _settings: function settings() {
                    return {
                        url: this.url,
                        type: "GET",
                        dataType: "json"
                    };
                },
                get: function get(query, cb) {
                    var that = this, settings;
                    if (!cb) {
                        return;
                    }
                    query = query || "";
                    settings = this.prepare(query, this._settings());
                    return this.transport.get(settings, onResponse);
                    function onResponse(err, resp) {
                        err ? cb([]) : cb(that.transform(resp));
                    }
                },
                cancelLastRequest: function cancelLastRequest() {
                    this.transport.cancel();
                }
            });
            return Remote;
        }();
        var oParser = function() {
            "use strict";
            return function parse(o) {
                var defaults, sorter;
                defaults = {
                    initialize: true,
                    identify: _.stringify,
                    datumTokenizer: null,
                    queryTokenizer: null,
                    sufficient: 5,
                    sorter: null,
                    local: [],
                    prefetch: null,
                    remote: null
                };
                o = _.mixin(defaults, o || {});
                !o.datumTokenizer && $.error("datumTokenizer is required");
                !o.queryTokenizer && $.error("queryTokenizer is required");
                sorter = o.sorter;
                o.sorter = sorter ? function(x) {
                    return x.sort(sorter);
                } : _.identity;
                o.local = _.isFunction(o.local) ? o.local() : o.local;
                o.prefetch = parsePrefetch(o.prefetch);
                o.remote = parseRemote(o.remote);
                return o;
            };
            function parsePrefetch(o) {
                var defaults;
                if (!o) {
                    return null;
                }
                defaults = {
                    url: null,
                    ttl: 24 * 60 * 60 * 1e3,
                    cache: true,
                    cacheKey: null,
                    thumbprint: "",
                    prepare: _.identity,
                    transform: _.identity,
                    transport: null
                };
                o = _.isString(o) ? {
                    url: o
                } : o;
                o = _.mixin(defaults, o);
                !o.url && $.error("prefetch requires url to be set");
                o.transform = o.filter || o.transform;
                o.cacheKey = o.cacheKey || o.url;
                o.thumbprint = VERSION + o.thumbprint;
                o.transport = o.transport ? callbackToDeferred(o.transport) : $.ajax;
                return o;
            }
            function parseRemote(o) {
                var defaults;
                if (!o) {
                    return;
                }
                defaults = {
                    url: null,
                    cache: true,
                    prepare: null,
                    replace: null,
                    wildcard: null,
                    limiter: null,
                    rateLimitBy: "debounce",
                    rateLimitWait: 300,
                    transform: _.identity,
                    transport: null
                };
                o = _.isString(o) ? {
                    url: o
                } : o;
                o = _.mixin(defaults, o);
                !o.url && $.error("remote requires url to be set");
                o.transform = o.filter || o.transform;
                o.prepare = toRemotePrepare(o);
                o.limiter = toLimiter(o);
                o.transport = o.transport ? callbackToDeferred(o.transport) : $.ajax;
                delete o.replace;
                delete o.wildcard;
                delete o.rateLimitBy;
                delete o.rateLimitWait;
                return o;
            }
            function toRemotePrepare(o) {
                var prepare, replace, wildcard;
                prepare = o.prepare;
                replace = o.replace;
                wildcard = o.wildcard;
                if (prepare) {
                    return prepare;
                }
                if (replace) {
                    prepare = prepareByReplace;
                } else if (o.wildcard) {
                    prepare = prepareByWildcard;
                } else {
                    prepare = idenityPrepare;
                }
                return prepare;
                function prepareByReplace(query, settings) {
                    settings.url = replace(settings.url, query);
                    return settings;
                }
                function prepareByWildcard(query, settings) {
                    settings.url = settings.url.replace(wildcard, encodeURIComponent(query));
                    return settings;
                }
                function idenityPrepare(query, settings) {
                    return settings;
                }
            }
            function toLimiter(o) {
                var limiter, method, wait;
                limiter = o.limiter;
                method = o.rateLimitBy;
                wait = o.rateLimitWait;
                if (!limiter) {
                    limiter = /^throttle$/i.test(method) ? throttle(wait) : debounce(wait);
                }
                return limiter;
                function debounce(wait) {
                    return function debounce(fn) {
                        return _.debounce(fn, wait);
                    };
                }
                function throttle(wait) {
                    return function throttle(fn) {
                        return _.throttle(fn, wait);
                    };
                }
            }
            function callbackToDeferred(fn) {
                return function wrapper(o) {
                    var deferred = $.Deferred();
                    fn(o, onSuccess, onError);
                    return deferred;
                    function onSuccess(resp) {
                        _.defer(function() {
                            deferred.resolve(resp);
                        });
                    }
                    function onError(err) {
                        _.defer(function() {
                            deferred.reject(err);
                        });
                    }
                };
            }
        }();
        var Bloodhound = function() {
            "use strict";
            var old;
            old = window && window.Bloodhound;
            function Bloodhound(o) {
                o = oParser(o);
                this.sorter = o.sorter;
                this.identify = o.identify;
                this.sufficient = o.sufficient;
                this.local = o.local;
                this.remote = o.remote ? new Remote(o.remote) : null;
                this.prefetch = o.prefetch ? new Prefetch(o.prefetch) : null;
                this.index = new SearchIndex({
                    identify: this.identify,
                    datumTokenizer: o.datumTokenizer,
                    queryTokenizer: o.queryTokenizer
                });
                o.initialize !== false && this.initialize();
            }
            Bloodhound.noConflict = function noConflict() {
                window && (window.Bloodhound = old);
                return Bloodhound;
            };
            Bloodhound.tokenizers = tokenizers;
            _.mixin(Bloodhound.prototype, {
                __ttAdapter: function ttAdapter() {
                    var that = this;
                    return this.remote ? withAsync : withoutAsync;
                    function withAsync(query, sync, async) {
                        return that.search(query, sync, async);
                    }
                    function withoutAsync(query, sync) {
                        return that.search(query, sync);
                    }
                },
                _loadPrefetch: function loadPrefetch() {
                    var that = this, deferred, serialized;
                    deferred = $.Deferred();
                    if (!this.prefetch) {
                        deferred.resolve();
                    } else if (serialized = this.prefetch.fromCache()) {
                        this.index.bootstrap(serialized);
                        deferred.resolve();
                    } else {
                        this.prefetch.fromNetwork(done);
                    }
                    return deferred.promise();
                    function done(err, data) {
                        if (err) {
                            return deferred.reject();
                        }
                        that.add(data);
                        that.prefetch.store(that.index.serialize());
                        deferred.resolve();
                    }
                },
                _initialize: function initialize() {
                    var that = this, deferred;
                    this.clear();
                    (this.initPromise = this._loadPrefetch()).done(addLocalToIndex);
                    return this.initPromise;
                    function addLocalToIndex() {
                        that.add(that.local);
                    }
                },
                initialize: function initialize(force) {
                    return !this.initPromise || force ? this._initialize() : this.initPromise;
                },
                add: function add(data) {
                    this.index.add(data);
                    return this;
                },
                get: function get(ids) {
                    ids = _.isArray(ids) ? ids : [].slice.call(arguments);
                    return this.index.get(ids);
                },
                search: function search(query, sync, async) {
                    var that = this, local;
                    local = this.sorter(this.index.search(query));
                    sync(this.remote ? local.slice() : local);
                    if (this.remote && local.length < this.sufficient) {
                        this.remote.get(query, processRemote);
                    } else if (this.remote) {
                        this.remote.cancelLastRequest();
                    }
                    return this;
                    function processRemote(remote) {
                        var nonDuplicates = [];
                        _.each(remote, function(r) {
                            !_.some(local, function(l) {
                                return that.identify(r) === that.identify(l);
                            }) && nonDuplicates.push(r);
                        });
                        async && async(nonDuplicates);
                    }
                },
                all: function all() {
                    return this.index.all();
                },
                clear: function clear() {
                    this.index.reset();
                    return this;
                },
                clearPrefetchCache: function clearPrefetchCache() {
                    this.prefetch && this.prefetch.clear();
                    return this;
                },
                clearRemoteCache: function clearRemoteCache() {
                    Transport.resetCache();
                    return this;
                },
                ttAdapter: function ttAdapter() {
                    return this.__ttAdapter();
                }
            });
            return Bloodhound;
        }();
        return Bloodhound;
    });
    
    (function(root, factory) {
        if (typeof define === "function" && define.amd) {
            define("typeahead.js", [ "jquery" ], function(a0) {
                return factory(a0);
            });
        } else if (typeof exports === "object") {
            module.exports = factory(__browserify_shim_require__("jquery"));
        } else {
            factory(jQuery);
        }
    })(this, function($) {
        var _ = function() {
            "use strict";
            return {
                isMsie: function() {
                    return /(msie|trident)/i.test(navigator.userAgent) ? navigator.userAgent.match(/(msie |rv:)(\d+(.\d+)?)/i)[2] : false;
                },
                isBlankString: function(str) {
                    return !str || /^\s*$/.test(str);
                },
                escapeRegExChars: function(str) {
                    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
                },
                isString: function(obj) {
                    return typeof obj === "string";
                },
                isNumber: function(obj) {
                    return typeof obj === "number";
                },
                isArray: $.isArray,
                isFunction: $.isFunction,
                isObject: $.isPlainObject,
                isUndefined: function(obj) {
                    return typeof obj === "undefined";
                },
                isElement: function(obj) {
                    return !!(obj && obj.nodeType === 1);
                },
                isJQuery: function(obj) {
                    return obj instanceof $;
                },
                toStr: function toStr(s) {
                    return _.isUndefined(s) || s === null ? "" : s + "";
                },
                bind: $.proxy,
                each: function(collection, cb) {
                    $.each(collection, reverseArgs);
                    function reverseArgs(index, value) {
                        return cb(value, index);
                    }
                },
                map: $.map,
                filter: $.grep,
                every: function(obj, test) {
                    var result = true;
                    if (!obj) {
                        return result;
                    }
                    $.each(obj, function(key, val) {
                        if (!(result = test.call(null, val, key, obj))) {
                            return false;
                        }
                    });
                    return !!result;
                },
                some: function(obj, test) {
                    var result = false;
                    if (!obj) {
                        return result;
                    }
                    $.each(obj, function(key, val) {
                        if (result = test.call(null, val, key, obj)) {
                            return false;
                        }
                    });
                    return !!result;
                },
                mixin: $.extend,
                identity: function(x) {
                    return x;
                },
                clone: function(obj) {
                    return $.extend(true, {}, obj);
                },
                getIdGenerator: function() {
                    var counter = 0;
                    return function() {
                        return counter++;
                    };
                },
                templatify: function templatify(obj) {
                    return $.isFunction(obj) ? obj : template;
                    function template() {
                        return String(obj);
                    }
                },
                defer: function(fn) {
                    setTimeout(fn, 0);
                },
                debounce: function(func, wait, immediate) {
                    var timeout, result;
                    return function() {
                        var context = this, args = arguments, later, callNow;
                        later = function() {
                            timeout = null;
                            if (!immediate) {
                                result = func.apply(context, args);
                            }
                        };
                        callNow = immediate && !timeout;
                        clearTimeout(timeout);
                        timeout = setTimeout(later, wait);
                        if (callNow) {
                            result = func.apply(context, args);
                        }
                        return result;
                    };
                },
                throttle: function(func, wait) {
                    var context, args, timeout, result, previous, later;
                    previous = 0;
                    later = function() {
                        previous = new Date();
                        timeout = null;
                        result = func.apply(context, args);
                    };
                    return function() {
                        var now = new Date(), remaining = wait - (now - previous);
                        context = this;
                        args = arguments;
                        if (remaining <= 0) {
                            clearTimeout(timeout);
                            timeout = null;
                            previous = now;
                            result = func.apply(context, args);
                        } else if (!timeout) {
                            timeout = setTimeout(later, remaining);
                        }
                        return result;
                    };
                },
                stringify: function(val) {
                    return _.isString(val) ? val : JSON.stringify(val);
                },
                noop: function() {}
            };
        }();
        var WWW = function() {
            "use strict";
            var defaultClassNames = {
                wrapper: "twitter-typeahead",
                input: "tt-input",
                hint: "tt-hint",
                menu: "tt-menu",
                dataset: "tt-dataset",
                suggestion: "tt-suggestion",
                selectable: "tt-selectable",
                empty: "tt-empty",
                open: "tt-open",
                cursor: "tt-cursor",
                highlight: "tt-highlight"
            };
            return build;
            function build(o) {
                var www, classes;
                classes = _.mixin({}, defaultClassNames, o);
                www = {
                    css: buildCss(),
                    classes: classes,
                    html: buildHtml(classes),
                    selectors: buildSelectors(classes)
                };
                return {
                    css: www.css,
                    html: www.html,
                    classes: www.classes,
                    selectors: www.selectors,
                    mixin: function(o) {
                        _.mixin(o, www);
                    }
                };
            }
            function buildHtml(c) {
                return {
                    wrapper: '<span class="' + c.wrapper + '"></span>',
                    menu: '<div class="' + c.menu + '"></div>'
                };
            }
            function buildSelectors(classes) {
                var selectors = {};
                _.each(classes, function(v, k) {
                    selectors[k] = "." + v;
                });
                return selectors;
            }
            function buildCss() {
                var css = {
                    wrapper: {
                        position: "relative",
                        display: "inline-block"
                    },
                    hint: {
                        position: "absolute",
                        top: "0",
                        left: "0",
                        borderColor: "transparent",
                        boxShadow: "none",
                        opacity: "1"
                    },
                    input: {
                        position: "relative",
                        verticalAlign: "top",
                        backgroundColor: "transparent"
                    },
                    inputWithNoHint: {
                        position: "relative",
                        verticalAlign: "top"
                    },
                    menu: {
                        position: "absolute",
                        top: "100%",
                        left: "0",
                        zIndex: "100",
                        display: "none"
                    },
                    ltr: {
                        left: "0",
                        right: "auto"
                    },
                    rtl: {
                        left: "auto",
                        right: " 0"
                    }
                };
                if (_.isMsie()) {
                    _.mixin(css.input, {
                        backgroundImage: "url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)"
                    });
                }
                return css;
            }
        }();
        var EventBus = function() {
            "use strict";
            var namespace, deprecationMap;
            namespace = "typeahead:";
            deprecationMap = {
                render: "rendered",
                cursorchange: "cursorchanged",
                select: "selected",
                autocomplete: "autocompleted"
            };
            function EventBus(o) {
                if (!o || !o.el) {
                    $.error("EventBus initialized without el");
                }
                this.$el = $(o.el);
            }
            _.mixin(EventBus.prototype, {
                _trigger: function(type, args) {
                    var $e;
                    $e = $.Event(namespace + type);
                    (args = args || []).unshift($e);
                    this.$el.trigger.apply(this.$el, args);
                    return $e;
                },
                before: function(type) {
                    var args, $e;
                    args = [].slice.call(arguments, 1);
                    $e = this._trigger("before" + type, args);
                    return $e.isDefaultPrevented();
                },
                trigger: function(type) {
                    var deprecatedType;
                    this._trigger(type, [].slice.call(arguments, 1));
                    if (deprecatedType = deprecationMap[type]) {
                        this._trigger(deprecatedType, [].slice.call(arguments, 1));
                    }
                }
            });
            return EventBus;
        }();
        var EventEmitter = function() {
            "use strict";
            var splitter = /\s+/, nextTick = getNextTick();
            return {
                onSync: onSync,
                onAsync: onAsync,
                off: off,
                trigger: trigger
            };
            function on(method, types, cb, context) {
                var type;
                if (!cb) {
                    return this;
                }
                types = types.split(splitter);
                cb = context ? bindContext(cb, context) : cb;
                this._callbacks = this._callbacks || {};
                while (type = types.shift()) {
                    this._callbacks[type] = this._callbacks[type] || {
                        sync: [],
                        async: []
                    };
                    this._callbacks[type][method].push(cb);
                }
                return this;
            }
            function onAsync(types, cb, context) {
                return on.call(this, "async", types, cb, context);
            }
            function onSync(types, cb, context) {
                return on.call(this, "sync", types, cb, context);
            }
            function off(types) {
                var type;
                if (!this._callbacks) {
                    return this;
                }
                types = types.split(splitter);
                while (type = types.shift()) {
                    delete this._callbacks[type];
                }
                return this;
            }
            function trigger(types) {
                var type, callbacks, args, syncFlush, asyncFlush;
                if (!this._callbacks) {
                    return this;
                }
                types = types.split(splitter);
                args = [].slice.call(arguments, 1);
                while ((type = types.shift()) && (callbacks = this._callbacks[type])) {
                    syncFlush = getFlush(callbacks.sync, this, [ type ].concat(args));
                    asyncFlush = getFlush(callbacks.async, this, [ type ].concat(args));
                    syncFlush() && nextTick(asyncFlush);
                }
                return this;
            }
            function getFlush(callbacks, context, args) {
                return flush;
                function flush() {
                    var cancelled;
                    for (var i = 0, len = callbacks.length; !cancelled && i < len; i += 1) {
                        cancelled = callbacks[i].apply(context, args) === false;
                    }
                    return !cancelled;
                }
            }
            function getNextTick() {
                var nextTickFn;
                if (window.setImmediate) {
                    nextTickFn = function nextTickSetImmediate(fn) {
                        setImmediate(function() {
                            fn();
                        });
                    };
                } else {
                    nextTickFn = function nextTickSetTimeout(fn) {
                        setTimeout(function() {
                            fn();
                        }, 0);
                    };
                }
                return nextTickFn;
            }
            function bindContext(fn, context) {
                return fn.bind ? fn.bind(context) : function() {
                    fn.apply(context, [].slice.call(arguments, 0));
                };
            }
        }();
        var highlight = function(doc) {
            "use strict";
            var defaults = {
                node: null,
                pattern: null,
                tagName: "strong",
                className: null,
                wordsOnly: false,
                caseSensitive: false
            };
            return function hightlight(o) {
                var regex;
                o = _.mixin({}, defaults, o);
                if (!o.node || !o.pattern) {
                    return;
                }
                o.pattern = _.isArray(o.pattern) ? o.pattern : [ o.pattern ];
                regex = getRegex(o.pattern, o.caseSensitive, o.wordsOnly);
                traverse(o.node, hightlightTextNode);
                function hightlightTextNode(textNode) {
                    var match, patternNode, wrapperNode;
                    if (match = regex.exec(textNode.data)) {
                        wrapperNode = doc.createElement(o.tagName);
                        o.className && (wrapperNode.className = o.className);
                        patternNode = textNode.splitText(match.index);
                        patternNode.splitText(match[0].length);
                        wrapperNode.appendChild(patternNode.cloneNode(true));
                        textNode.parentNode.replaceChild(wrapperNode, patternNode);
                    }
                    return !!match;
                }
                function traverse(el, hightlightTextNode) {
                    var childNode, TEXT_NODE_TYPE = 3;
                    for (var i = 0; i < el.childNodes.length; i++) {
                        childNode = el.childNodes[i];
                        if (childNode.nodeType === TEXT_NODE_TYPE) {
                            i += hightlightTextNode(childNode) ? 1 : 0;
                        } else {
                            traverse(childNode, hightlightTextNode);
                        }
                    }
                }
            };
            function getRegex(patterns, caseSensitive, wordsOnly) {
                var escapedPatterns = [], regexStr;
                for (var i = 0, len = patterns.length; i < len; i++) {
                    escapedPatterns.push(_.escapeRegExChars(patterns[i]));
                }
                regexStr = wordsOnly ? "\\b(" + escapedPatterns.join("|") + ")\\b" : "(" + escapedPatterns.join("|") + ")";
                return caseSensitive ? new RegExp(regexStr) : new RegExp(regexStr, "i");
            }
        }(window.document);
        var Input = function() {
            "use strict";
            var specialKeyCodeMap;
            specialKeyCodeMap = {
                9: "tab",
                27: "esc",
                37: "left",
                39: "right",
                13: "enter",
                38: "up",
                40: "down"
            };
            function Input(o, www) {
                o = o || {};
                if (!o.input) {
                    $.error("input is missing");
                }
                www.mixin(this);
                this.$hint = $(o.hint);
                this.$input = $(o.input);
                this.query = this.$input.val();
                this.queryWhenFocused = this.hasFocus() ? this.query : null;
                this.$overflowHelper = buildOverflowHelper(this.$input);
                this._checkLanguageDirection();
                if (this.$hint.length === 0) {
                    this.setHint = this.getHint = this.clearHint = this.clearHintIfInvalid = _.noop;
                }
            }
            Input.normalizeQuery = function(str) {
                return _.toStr(str).replace(/^\s*/g, "").replace(/\s{2,}/g, " ");
            };
            _.mixin(Input.prototype, EventEmitter, {
                _onBlur: function onBlur() {
                    this.resetInputValue();
                    this.trigger("blurred");
                },
                _onFocus: function onFocus() {
                    this.queryWhenFocused = this.query;
                    this.trigger("focused");
                },
                _onKeydown: function onKeydown($e) {
                    var keyName = specialKeyCodeMap[$e.which || $e.keyCode];
                    this._managePreventDefault(keyName, $e);
                    if (keyName && this._shouldTrigger(keyName, $e)) {
                        this.trigger(keyName + "Keyed", $e);
                    }
                },
                _onInput: function onInput() {
                    this._setQuery(this.getInputValue());
                    this.clearHintIfInvalid();
                    this._checkLanguageDirection();
                },
                _managePreventDefault: function managePreventDefault(keyName, $e) {
                    var preventDefault;
                    switch (keyName) {
                      case "up":
                      case "down":
                        preventDefault = !withModifier($e);
                        break;
    
                      default:
                        preventDefault = false;
                    }
                    preventDefault && $e.preventDefault();
                },
                _shouldTrigger: function shouldTrigger(keyName, $e) {
                    var trigger;
                    switch (keyName) {
                      case "tab":
                        trigger = !withModifier($e);
                        break;
    
                      default:
                        trigger = true;
                    }
                    return trigger;
                },
                _checkLanguageDirection: function checkLanguageDirection() {
                    var dir = (this.$input.css("direction") || "ltr").toLowerCase();
                    if (this.dir !== dir) {
                        this.dir = dir;
                        this.$hint.attr("dir", dir);
                        this.trigger("langDirChanged", dir);
                    }
                },
                _setQuery: function setQuery(val, silent) {
                    var areEquivalent, hasDifferentWhitespace;
                    areEquivalent = areQueriesEquivalent(val, this.query);
                    hasDifferentWhitespace = areEquivalent ? this.query.length !== val.length : false;
                    this.query = val;
                    if (!silent && !areEquivalent) {
                        this.trigger("queryChanged", this.query);
                    } else if (!silent && hasDifferentWhitespace) {
                        this.trigger("whitespaceChanged", this.query);
                    }
                },
                bind: function() {
                    var that = this, onBlur, onFocus, onKeydown, onInput;
                    onBlur = _.bind(this._onBlur, this);
                    onFocus = _.bind(this._onFocus, this);
                    onKeydown = _.bind(this._onKeydown, this);
                    onInput = _.bind(this._onInput, this);
                    this.$input.on("blur.tt", onBlur).on("focus.tt", onFocus).on("keydown.tt", onKeydown);
                    if (!_.isMsie() || _.isMsie() > 9) {
                        this.$input.on("input.tt", onInput);
                    } else {
                        this.$input.on("keydown.tt keypress.tt cut.tt paste.tt", function($e) {
                            if (specialKeyCodeMap[$e.which || $e.keyCode]) {
                                return;
                            }
                            _.defer(_.bind(that._onInput, that, $e));
                        });
                    }
                    return this;
                },
                focus: function focus() {
                    this.$input.focus();
                },
                blur: function blur() {
                    this.$input.blur();
                },
                getLangDir: function getLangDir() {
                    return this.dir;
                },
                getQuery: function getQuery() {
                    return this.query || "";
                },
                setQuery: function setQuery(val, silent) {
                    this.setInputValue(val);
                    this._setQuery(val, silent);
                },
                hasQueryChangedSinceLastFocus: function hasQueryChangedSinceLastFocus() {
                    return this.query !== this.queryWhenFocused;
                },
                getInputValue: function getInputValue() {
                    return this.$input.val();
                },
                setInputValue: function setInputValue(value) {
                    this.$input.val(value);
                    this.clearHintIfInvalid();
                    this._checkLanguageDirection();
                },
                resetInputValue: function resetInputValue() {
                    this.setInputValue(this.query);
                },
                getHint: function getHint() {
                    return this.$hint.val();
                },
                setHint: function setHint(value) {
                    this.$hint.val(value);
                },
                clearHint: function clearHint() {
                    this.setHint("");
                },
                clearHintIfInvalid: function clearHintIfInvalid() {
                    var val, hint, valIsPrefixOfHint, isValid;
                    val = this.getInputValue();
                    hint = this.getHint();
                    valIsPrefixOfHint = val !== hint && hint.indexOf(val) === 0;
                    isValid = val !== "" && valIsPrefixOfHint && !this.hasOverflow();
                    !isValid && this.clearHint();
                },
                hasFocus: function hasFocus() {
                    return this.$input.is(":focus");
                },
                hasOverflow: function hasOverflow() {
                    var constraint = this.$input.width() - 2;
                    this.$overflowHelper.text(this.getInputValue());
                    return this.$overflowHelper.width() >= constraint;
                },
                isCursorAtEnd: function() {
                    var valueLength, selectionStart, range;
                    valueLength = this.$input.val().length;
                    selectionStart = this.$input[0].selectionStart;
                    if (_.isNumber(selectionStart)) {
                        return selectionStart === valueLength;
                    } else if (document.selection) {
                        range = document.selection.createRange();
                        range.moveStart("character", -valueLength);
                        return valueLength === range.text.length;
                    }
                    return true;
                },
                destroy: function destroy() {
                    this.$hint.off(".tt");
                    this.$input.off(".tt");
                    this.$overflowHelper.remove();
                    this.$hint = this.$input = this.$overflowHelper = $("<div>");
                }
            });
            return Input;
            function buildOverflowHelper($input) {
                return $('<pre aria-hidden="true"></pre>').css({
                    position: "absolute",
                    visibility: "hidden",
                    whiteSpace: "pre",
                    fontFamily: $input.css("font-family"),
                    fontSize: $input.css("font-size"),
                    fontStyle: $input.css("font-style"),
                    fontVariant: $input.css("font-variant"),
                    fontWeight: $input.css("font-weight"),
                    wordSpacing: $input.css("word-spacing"),
                    letterSpacing: $input.css("letter-spacing"),
                    textIndent: $input.css("text-indent"),
                    textRendering: $input.css("text-rendering"),
                    textTransform: $input.css("text-transform")
                }).insertAfter($input);
            }
            function areQueriesEquivalent(a, b) {
                return Input.normalizeQuery(a) === Input.normalizeQuery(b);
            }
            function withModifier($e) {
                return $e.altKey || $e.ctrlKey || $e.metaKey || $e.shiftKey;
            }
        }();
        var Dataset = function() {
            "use strict";
            var keys, nameGenerator;
            keys = {
                val: "tt-selectable-display",
                obj: "tt-selectable-object"
            };
            nameGenerator = _.getIdGenerator();
            function Dataset(o, www) {
                o = o || {};
                o.templates = o.templates || {};
                o.templates.notFound = o.templates.notFound || o.templates.empty;
                if (!o.source) {
                    $.error("missing source");
                }
                if (!o.node) {
                    $.error("missing node");
                }
                if (o.name && !isValidName(o.name)) {
                    $.error("invalid dataset name: " + o.name);
                }
                www.mixin(this);
                this.highlight = !!o.highlight;
                this.name = o.name || nameGenerator();
                this.limit = o.limit || 5;
                this.displayFn = getDisplayFn(o.display || o.displayKey);
                this.templates = getTemplates(o.templates, this.displayFn);
                this.source = o.source.__ttAdapter ? o.source.__ttAdapter() : o.source;
                this.async = _.isUndefined(o.async) ? this.source.length > 2 : !!o.async;
                this._resetLastSuggestion();
                this.$el = $(o.node).addClass(this.classes.dataset).addClass(this.classes.dataset + "-" + this.name);
            }
            Dataset.extractData = function extractData(el) {
                var $el = $(el);
                if ($el.data(keys.obj)) {
                    return {
                        val: $el.data(keys.val) || "",
                        obj: $el.data(keys.obj) || null
                    };
                }
                return null;
            };
            _.mixin(Dataset.prototype, EventEmitter, {
                _overwrite: function overwrite(query, suggestions) {
                    suggestions = suggestions || [];
                    if (suggestions.length) {
                        this._renderSuggestions(query, suggestions);
                    } else if (this.async && this.templates.pending) {
                        this._renderPending(query);
                    } else if (!this.async && this.templates.notFound) {
                        this._renderNotFound(query);
                    } else {
                        this._empty();
                    }
                    this.trigger("rendered", this.name, suggestions, false);
                },
                _append: function append(query, suggestions) {
                    suggestions = suggestions || [];
                    if (suggestions.length && this.$lastSuggestion.length) {
                        this._appendSuggestions(query, suggestions);
                    } else if (suggestions.length) {
                        this._renderSuggestions(query, suggestions);
                    } else if (!this.$lastSuggestion.length && this.templates.notFound) {
                        this._renderNotFound(query);
                    }
                    this.trigger("rendered", this.name, suggestions, true);
                },
                _renderSuggestions: function renderSuggestions(query, suggestions) {
                    var $fragment;
                    $fragment = this._getSuggestionsFragment(query, suggestions);
                    this.$lastSuggestion = $fragment.children().last();
                    this.$el.html($fragment).prepend(this._getHeader(query, suggestions)).append(this._getFooter(query, suggestions));
                },
                _appendSuggestions: function appendSuggestions(query, suggestions) {
                    var $fragment, $lastSuggestion;
                    $fragment = this._getSuggestionsFragment(query, suggestions);
                    $lastSuggestion = $fragment.children().last();
                    this.$lastSuggestion.after($fragment);
                    this.$lastSuggestion = $lastSuggestion;
                },
                _renderPending: function renderPending(query) {
                    var template = this.templates.pending;
                    this._resetLastSuggestion();
                    template && this.$el.html(template({
                        query: query,
                        dataset: this.name
                    }));
                },
                _renderNotFound: function renderNotFound(query) {
                    var template = this.templates.notFound;
                    this._resetLastSuggestion();
                    template && this.$el.html(template({
                        query: query,
                        dataset: this.name
                    }));
                },
                _empty: function empty() {
                    this.$el.empty();
                    this._resetLastSuggestion();
                },
                _getSuggestionsFragment: function getSuggestionsFragment(query, suggestions) {
                    var that = this, fragment;
                    fragment = document.createDocumentFragment();
                    _.each(suggestions, function getSuggestionNode(suggestion) {
                        var $el, context;
                        context = that._injectQuery(query, suggestion);
                        $el = $(that.templates.suggestion(context)).data(keys.obj, suggestion).data(keys.val, that.displayFn(suggestion)).addClass(that.classes.suggestion + " " + that.classes.selectable);
                        fragment.appendChild($el[0]);
                    });
                    this.highlight && highlight({
                        className: this.classes.highlight,
                        node: fragment,
                        pattern: query
                    });
                    return $(fragment);
                },
                _getFooter: function getFooter(query, suggestions) {
                    return this.templates.footer ? this.templates.footer({
                        query: query,
                        suggestions: suggestions,
                        dataset: this.name
                    }) : null;
                },
                _getHeader: function getHeader(query, suggestions) {
                    return this.templates.header ? this.templates.header({
                        query: query,
                        suggestions: suggestions,
                        dataset: this.name
                    }) : null;
                },
                _resetLastSuggestion: function resetLastSuggestion() {
                    this.$lastSuggestion = $();
                },
                _injectQuery: function injectQuery(query, obj) {
                    return _.isObject(obj) ? _.mixin({
                        _query: query
                    }, obj) : obj;
                },
                update: function update(query) {
                    var that = this, canceled = false, syncCalled = false, rendered = 0;
                    this.cancel();
                    this.cancel = function cancel() {
                        canceled = true;
                        that.cancel = $.noop;
                        that.async && that.trigger("asyncCanceled", query);
                    };
                    this.source(query, sync, async);
                    !syncCalled && sync([]);
                    function sync(suggestions) {
                        if (syncCalled) {
                            return;
                        }
                        syncCalled = true;
                        suggestions = (suggestions || []).slice(0, that.limit);
                        rendered = suggestions.length;
                        that._overwrite(query, suggestions);
                        if (rendered < that.limit && that.async) {
                            that.trigger("asyncRequested", query);
                        }
                    }
                    function async(suggestions) {
                        suggestions = suggestions || [];
                        if (!canceled && rendered < that.limit) {
                            that.cancel = $.noop;
                            rendered += suggestions.length;
                            that._append(query, suggestions.slice(0, that.limit - rendered));
                            that.async && that.trigger("asyncReceived", query);
                        }
                    }
                },
                cancel: $.noop,
                clear: function clear() {
                    this._empty();
                    this.cancel();
                    this.trigger("cleared");
                },
                isEmpty: function isEmpty() {
                    return this.$el.is(":empty");
                },
                destroy: function destroy() {
                    this.$el = $("<div>");
                }
            });
            return Dataset;
            function getDisplayFn(display) {
                display = display || _.stringify;
                return _.isFunction(display) ? display : displayFn;
                function displayFn(obj) {
                    return obj[display];
                }
            }
            function getTemplates(templates, displayFn) {
                return {
                    notFound: templates.notFound && _.templatify(templates.notFound),
                    pending: templates.pending && _.templatify(templates.pending),
                    header: templates.header && _.templatify(templates.header),
                    footer: templates.footer && _.templatify(templates.footer),
                    suggestion: templates.suggestion || suggestionTemplate
                };
                function suggestionTemplate(context) {
                    return $("<div>").text(displayFn(context));
                }
            }
            function isValidName(str) {
                return /^[_a-zA-Z0-9-]+$/.test(str);
            }
        }();
        var Menu = function() {
            "use strict";
            function Menu(o, www) {
                var that = this;
                o = o || {};
                if (!o.node) {
                    $.error("node is required");
                }
                www.mixin(this);
                this.$node = $(o.node);
                this.query = null;
                this.datasets = _.map(o.datasets, initializeDataset);
                function initializeDataset(oDataset) {
                    var node = that.$node.find(oDataset.node).first();
                    oDataset.node = node.length ? node : $("<div>").appendTo(that.$node);
                    return new Dataset(oDataset, www);
                }
            }
            _.mixin(Menu.prototype, EventEmitter, {
                _onSelectableClick: function onSelectableClick($e) {
                    this.trigger("selectableClicked", $($e.currentTarget));
                },
                _onRendered: function onRendered(type, dataset, suggestions, async) {
                    this.$node.toggleClass(this.classes.empty, this._allDatasetsEmpty());
                    this.trigger("datasetRendered", dataset, suggestions, async);
                },
                _onCleared: function onCleared() {
                    this.$node.toggleClass(this.classes.empty, this._allDatasetsEmpty());
                    this.trigger("datasetCleared");
                },
                _propagate: function propagate() {
                    this.trigger.apply(this, arguments);
                },
                _allDatasetsEmpty: function allDatasetsEmpty() {
                    return _.every(this.datasets, isDatasetEmpty);
                    function isDatasetEmpty(dataset) {
                        return dataset.isEmpty();
                    }
                },
                _getSelectables: function getSelectables() {
                    return this.$node.find(this.selectors.selectable);
                },
                _removeCursor: function _removeCursor() {
                    var $selectable = this.getActiveSelectable();
                    $selectable && $selectable.removeClass(this.classes.cursor);
                },
                _ensureVisible: function ensureVisible($el) {
                    var elTop, elBottom, nodeScrollTop, nodeHeight;
                    elTop = $el.position().top;
                    elBottom = elTop + $el.outerHeight(true);
                    nodeScrollTop = this.$node.scrollTop();
                    nodeHeight = this.$node.height() + parseInt(this.$node.css("paddingTop"), 10) + parseInt(this.$node.css("paddingBottom"), 10);
                    if (elTop < 0) {
                        this.$node.scrollTop(nodeScrollTop + elTop);
                    } else if (nodeHeight < elBottom) {
                        this.$node.scrollTop(nodeScrollTop + (elBottom - nodeHeight));
                    }
                },
                bind: function() {
                    var that = this, onSelectableClick;
                    onSelectableClick = _.bind(this._onSelectableClick, this);
                    this.$node.on("click.tt", this.selectors.selectable, onSelectableClick);
                    _.each(this.datasets, function(dataset) {
                        dataset.onSync("asyncRequested", that._propagate, that).onSync("asyncCanceled", that._propagate, that).onSync("asyncReceived", that._propagate, that).onSync("rendered", that._onRendered, that).onSync("cleared", that._onCleared, that);
                    });
                    return this;
                },
                isOpen: function isOpen() {
                    return this.$node.hasClass(this.classes.open);
                },
                open: function open() {
                    this.$node.addClass(this.classes.open);
                },
                close: function close() {
                    this.$node.removeClass(this.classes.open);
                    this._removeCursor();
                },
                setLanguageDirection: function setLanguageDirection(dir) {
                    this.$node.attr("dir", dir);
                },
                selectableRelativeToCursor: function selectableRelativeToCursor(delta) {
                    var $selectables, $oldCursor, oldIndex, newIndex;
                    $oldCursor = this.getActiveSelectable();
                    $selectables = this._getSelectables();
                    oldIndex = $oldCursor ? $selectables.index($oldCursor) : -1;
                    newIndex = oldIndex + delta;
                    newIndex = (newIndex + 1) % ($selectables.length + 1) - 1;
                    newIndex = newIndex < -1 ? $selectables.length - 1 : newIndex;
                    return newIndex === -1 ? null : $selectables.eq(newIndex);
                },
                setCursor: function setCursor($selectable) {
                    this._removeCursor();
                    if ($selectable = $selectable && $selectable.first()) {
                        $selectable.addClass(this.classes.cursor);
                        this._ensureVisible($selectable);
                    }
                },
                getSelectableData: function getSelectableData($el) {
                    return $el && $el.length ? Dataset.extractData($el) : null;
                },
                getActiveSelectable: function getActiveSelectable() {
                    var $selectable = this._getSelectables().filter(this.selectors.cursor).first();
                    return $selectable.length ? $selectable : null;
                },
                getTopSelectable: function getTopSelectable() {
                    var $selectable = this._getSelectables().first();
                    return $selectable.length ? $selectable : null;
                },
                update: function update(query) {
                    var isValidUpdate = query !== this.query;
                    if (isValidUpdate) {
                        this.query = query;
                        _.each(this.datasets, updateDataset);
                    }
                    return isValidUpdate;
                    function updateDataset(dataset) {
                        dataset.update(query);
                    }
                },
                empty: function empty() {
                    _.each(this.datasets, clearDataset);
                    this.query = null;
                    this.$node.addClass(this.classes.empty);
                    function clearDataset(dataset) {
                        dataset.clear();
                    }
                },
                destroy: function destroy() {
                    this.$node.off(".tt");
                    this.$node = $("<div>");
                    _.each(this.datasets, destroyDataset);
                    function destroyDataset(dataset) {
                        dataset.destroy();
                    }
                }
            });
            return Menu;
        }();
        var DefaultMenu = function() {
            "use strict";
            var s = Menu.prototype;
            function DefaultMenu() {
                Menu.apply(this, [].slice.call(arguments, 0));
            }
            _.mixin(DefaultMenu.prototype, Menu.prototype, {
                open: function open() {
                    !this._allDatasetsEmpty() && this._show();
                    return s.open.apply(this, [].slice.call(arguments, 0));
                },
                close: function close() {
                    this._hide();
                    return s.close.apply(this, [].slice.call(arguments, 0));
                },
                _onRendered: function onRendered() {
                    if (this._allDatasetsEmpty()) {
                        this._hide();
                    } else {
                        this.isOpen() && this._show();
                    }
                    return s._onRendered.apply(this, [].slice.call(arguments, 0));
                },
                _onCleared: function onCleared() {
                    if (this._allDatasetsEmpty()) {
                        this._hide();
                    } else {
                        this.isOpen() && this._show();
                    }
                    return s._onCleared.apply(this, [].slice.call(arguments, 0));
                },
                setLanguageDirection: function setLanguageDirection(dir) {
                    this.$node.css(dir === "ltr" ? this.css.ltr : this.css.rtl);
                    return s.setLanguageDirection.apply(this, [].slice.call(arguments, 0));
                },
                _hide: function hide() {
                    this.$node.hide();
                },
                _show: function show() {
                    this.$node.css("display", "block");
                }
            });
            return DefaultMenu;
        }();
        var Typeahead = function() {
            "use strict";
            function Typeahead(o, www) {
                var onFocused, onBlurred, onEnterKeyed, onTabKeyed, onEscKeyed, onUpKeyed, onDownKeyed, onLeftKeyed, onRightKeyed, onQueryChanged, onWhitespaceChanged;
                o = o || {};
                if (!o.input) {
                    $.error("missing input");
                }
                if (!o.menu) {
                    $.error("missing menu");
                }
                if (!o.eventBus) {
                    $.error("missing event bus");
                }
                www.mixin(this);
                this.eventBus = o.eventBus;
                this.minLength = _.isNumber(o.minLength) ? o.minLength : 1;
                this.input = o.input;
                this.menu = o.menu;
                this.enabled = true;
                this.active = false;
                this.input.hasFocus() && this.activate();
                this.dir = this.input.getLangDir();
                this._hacks();
                this.menu.bind().onSync("selectableClicked", this._onSelectableClicked, this).onSync("asyncRequested", this._onAsyncRequested, this).onSync("asyncCanceled", this._onAsyncCanceled, this).onSync("asyncReceived", this._onAsyncReceived, this).onSync("datasetRendered", this._onDatasetRendered, this).onSync("datasetCleared", this._onDatasetCleared, this);
                onFocused = c(this, "activate", "open", "_onFocused");
                onBlurred = c(this, "deactivate", "_onBlurred");
                onEnterKeyed = c(this, "isActive", "isOpen", "_onEnterKeyed");
                onTabKeyed = c(this, "isActive", "isOpen", "_onTabKeyed");
                onEscKeyed = c(this, "isActive", "_onEscKeyed");
                onUpKeyed = c(this, "isActive", "open", "_onUpKeyed");
                onDownKeyed = c(this, "isActive", "open", "_onDownKeyed");
                onLeftKeyed = c(this, "isActive", "isOpen", "_onLeftKeyed");
                onRightKeyed = c(this, "isActive", "isOpen", "_onRightKeyed");
                onQueryChanged = c(this, "_openIfActive", "_onQueryChanged");
                onWhitespaceChanged = c(this, "_openIfActive", "_onWhitespaceChanged");
                this.input.bind().onSync("focused", onFocused, this).onSync("blurred", onBlurred, this).onSync("enterKeyed", onEnterKeyed, this).onSync("tabKeyed", onTabKeyed, this).onSync("escKeyed", onEscKeyed, this).onSync("upKeyed", onUpKeyed, this).onSync("downKeyed", onDownKeyed, this).onSync("leftKeyed", onLeftKeyed, this).onSync("rightKeyed", onRightKeyed, this).onSync("queryChanged", onQueryChanged, this).onSync("whitespaceChanged", onWhitespaceChanged, this).onSync("langDirChanged", this._onLangDirChanged, this);
            }
            _.mixin(Typeahead.prototype, {
                _hacks: function hacks() {
                    var $input, $menu;
                    $input = this.input.$input || $("<div>");
                    $menu = this.menu.$node || $("<div>");
                    $input.on("blur.tt", function($e) {
                        var active, isActive, hasActive;
                        active = document.activeElement;
                        isActive = $menu.is(active);
                        hasActive = $menu.has(active).length > 0;
                        if (_.isMsie() && (isActive || hasActive)) {
                            $e.preventDefault();
                            $e.stopImmediatePropagation();
                            _.defer(function() {
                                $input.focus();
                            });
                        }
                    });
                    $menu.on("mousedown.tt", function($e) {
                        $e.preventDefault();
                    });
                },
                _onSelectableClicked: function onSelectableClicked(type, $el) {
                    this.select($el);
                },
                _onDatasetCleared: function onDatasetCleared() {
                    this._updateHint();
                },
                _onDatasetRendered: function onDatasetRendered(type, dataset, suggestions, async) {
                    this._updateHint();
                    this.eventBus.trigger("render", suggestions, async, dataset);
                },
                _onAsyncRequested: function onAsyncRequested(type, dataset, query) {
                    this.eventBus.trigger("asyncrequest", query, dataset);
                },
                _onAsyncCanceled: function onAsyncCanceled(type, dataset, query) {
                    this.eventBus.trigger("asynccancel", query, dataset);
                },
                _onAsyncReceived: function onAsyncReceived(type, dataset, query) {
                    this.eventBus.trigger("asyncreceive", query, dataset);
                },
                _onFocused: function onFocused() {
                    this._minLengthMet() && this.menu.update(this.input.getQuery());
                },
                _onBlurred: function onBlurred() {
                    if (this.input.hasQueryChangedSinceLastFocus()) {
                        this.eventBus.trigger("change", this.input.getQuery());
                    }
                },
                _onEnterKeyed: function onEnterKeyed(type, $e) {
                    var $selectable;
                    if ($selectable = this.menu.getActiveSelectable()) {
                        this.select($selectable) && $e.preventDefault();
                    }
                },
                _onTabKeyed: function onTabKeyed(type, $e) {
                    var $selectable;
                    if ($selectable = this.menu.getActiveSelectable()) {
                        this.select($selectable) && $e.preventDefault();
                    } else if ($selectable = this.menu.getTopSelectable()) {
                        this.autocomplete($selectable) && $e.preventDefault();
                    }
                },
                _onEscKeyed: function onEscKeyed() {
                    this.close();
                },
                _onUpKeyed: function onUpKeyed() {
                    this.moveCursor(-1);
                },
                _onDownKeyed: function onDownKeyed() {
                    this.moveCursor(+1);
                },
                _onLeftKeyed: function onLeftKeyed() {
                    if (this.dir === "rtl" && this.input.isCursorAtEnd()) {
                        this.autocomplete(this.menu.getTopSelectable());
                    }
                },
                _onRightKeyed: function onRightKeyed() {
                    if (this.dir === "ltr" && this.input.isCursorAtEnd()) {
                        this.autocomplete(this.menu.getTopSelectable());
                    }
                },
                _onQueryChanged: function onQueryChanged(e, query) {
                    this._minLengthMet(query) ? this.menu.update(query) : this.menu.empty();
                },
                _onWhitespaceChanged: function onWhitespaceChanged() {
                    this._updateHint();
                },
                _onLangDirChanged: function onLangDirChanged(e, dir) {
                    if (this.dir !== dir) {
                        this.dir = dir;
                        this.menu.setLanguageDirection(dir);
                    }
                },
                _openIfActive: function openIfActive() {
                    this.isActive() && this.open();
                },
                _minLengthMet: function minLengthMet(query) {
                    query = _.isString(query) ? query : this.input.getQuery() || "";
                    return query.length >= this.minLength;
                },
                _updateHint: function updateHint() {
                    var $selectable, data, val, query, escapedQuery, frontMatchRegEx, match;
                    $selectable = this.menu.getTopSelectable();
                    data = this.menu.getSelectableData($selectable);
                    val = this.input.getInputValue();
                    if (data && !_.isBlankString(val) && !this.input.hasOverflow()) {
                        query = Input.normalizeQuery(val);
                        escapedQuery = _.escapeRegExChars(query);
                        frontMatchRegEx = new RegExp("^(?:" + escapedQuery + ")(.+$)", "i");
                        match = frontMatchRegEx.exec(data.val);
                        match && this.input.setHint(val + match[1]);
                    } else {
                        this.input.clearHint();
                    }
                },
                isEnabled: function isEnabled() {
                    return this.enabled;
                },
                enable: function enable() {
                    this.enabled = true;
                },
                disable: function disable() {
                    this.enabled = false;
                },
                isActive: function isActive() {
                    return this.active;
                },
                activate: function activate() {
                    if (this.isActive()) {
                        return true;
                    } else if (!this.isEnabled() || this.eventBus.before("active")) {
                        return false;
                    } else {
                        this.active = true;
                        this.eventBus.trigger("active");
                        return true;
                    }
                },
                deactivate: function deactivate() {
                    if (!this.isActive()) {
                        return true;
                    } else if (this.eventBus.before("idle")) {
                        return false;
                    } else {
                        this.active = false;
                        this.close();
                        this.eventBus.trigger("idle");
                        return true;
                    }
                },
                isOpen: function isOpen() {
                    return this.menu.isOpen();
                },
                open: function open() {
                    if (!this.isOpen() && !this.eventBus.before("open")) {
                        this.menu.open();
                        this._updateHint();
                        this.eventBus.trigger("open");
                    }
                    return this.isOpen();
                },
                close: function close() {
                    if (this.isOpen() && !this.eventBus.before("close")) {
                        this.menu.close();
                        this.input.clearHint();
                        this.input.resetInputValue();
                        this.eventBus.trigger("close");
                    }
                    return !this.isOpen();
                },
                setVal: function setVal(val) {
                    this.input.setQuery(_.toStr(val));
                },
                getVal: function getVal() {
                    return this.input.getQuery();
                },
                select: function select($selectable) {
                    var data = this.menu.getSelectableData($selectable);
                    if (data && !this.eventBus.before("select", data.obj)) {
                        this.input.setQuery(data.val, true);
                        this.eventBus.trigger("select", data.obj);
                        this.close();
                        return true;
                    }
                    return false;
                },
                autocomplete: function autocomplete($selectable) {
                    var query, data, isValid;
                    query = this.input.getQuery();
                    data = this.menu.getSelectableData($selectable);
                    isValid = data && query !== data.val;
                    if (isValid && !this.eventBus.before("autocomplete", data.obj)) {
                        this.input.setQuery(data.val);
                        this.eventBus.trigger("autocomplete", data.obj);
                        return true;
                    }
                    return false;
                },
                moveCursor: function moveCursor(delta) {
                    var query, $candidate, data, payload, cancelMove;
                    query = this.input.getQuery();
                    $candidate = this.menu.selectableRelativeToCursor(delta);
                    data = this.menu.getSelectableData($candidate);
                    payload = data ? data.obj : null;
                    cancelMove = this._minLengthMet() && this.menu.update(query);
                    if (!cancelMove && !this.eventBus.before("cursorchange", payload)) {
                        this.menu.setCursor($candidate);
                        if (data) {
                            this.input.setInputValue(data.val);
                        } else {
                            this.input.resetInputValue();
                            this._updateHint();
                        }
                        this.eventBus.trigger("cursorchange", payload);
                        return true;
                    }
                    return false;
                },
                destroy: function destroy() {
                    this.input.destroy();
                    this.menu.destroy();
                }
            });
            return Typeahead;
            function c(ctx) {
                var methods = [].slice.call(arguments, 1);
                return function() {
                    var args = [].slice.call(arguments);
                    _.each(methods, function(method) {
                        return ctx[method].apply(ctx, args);
                    });
                };
            }
        }();
        (function() {
            "use strict";
            var old, keys, methods;
            old = $.fn.typeahead;
            keys = {
                www: "tt-www",
                attrs: "tt-attrs",
                typeahead: "tt-typeahead"
            };
            methods = {
                initialize: function initialize(o, datasets) {
                    var www;
                    datasets = _.isArray(datasets) ? datasets : [].slice.call(arguments, 1);
                    o = o || {};
                    www = WWW(o.classNames);
                    return this.each(attach);
                    function attach() {
                        var $input, $wrapper, $hint, $menu, defaultHint, defaultMenu, eventBus, input, menu, typeahead, MenuConstructor;
                        _.each(datasets, function(d) {
                            d.highlight = !!o.highlight;
                        });
                        $input = $(this);
                        $wrapper = $(www.html.wrapper);
                        $hint = $elOrNull(o.hint);
                        $menu = $elOrNull(o.menu);
                        defaultHint = o.hint !== false && !$hint;
                        defaultMenu = o.menu !== false && !$menu;
                        defaultHint && ($hint = buildHintFromInput($input, www));
                        defaultMenu && ($menu = $(www.html.menu).css(www.css.menu));
                        $hint && $hint.val("");
                        $input = prepInput($input, www);
                        if (defaultHint || defaultMenu) {
                            $wrapper.css(www.css.wrapper);
                            $input.css(defaultHint ? www.css.input : www.css.inputWithNoHint);
                            $input.wrap($wrapper).parent().prepend(defaultHint ? $hint : null).append(defaultMenu ? $menu : null);
                        }
                        MenuConstructor = defaultMenu ? DefaultMenu : Menu;
                        eventBus = new EventBus({
                            el: $input
                        });
                        input = new Input({
                            hint: $hint,
                            input: $input
                        }, www);
                        menu = new MenuConstructor({
                            node: $menu,
                            datasets: datasets
                        }, www);
                        typeahead = new Typeahead({
                            input: input,
                            menu: menu,
                            eventBus: eventBus,
                            minLength: o.minLength
                        }, www);
                        $input.data(keys.www, www);
                        $input.data(keys.typeahead, typeahead);
                    }
                },
                isEnabled: function isEnabled() {
                    var enabled;
                    ttEach(this.first(), function(t) {
                        enabled = t.isEnabled();
                    });
                    return enabled;
                },
                enable: function enable() {
                    ttEach(this, function(t) {
                        t.enable();
                    });
                    return this;
                },
                disable: function disable() {
                    ttEach(this, function(t) {
                        t.disable();
                    });
                    return this;
                },
                isActive: function isActive() {
                    var active;
                    ttEach(this.first(), function(t) {
                        active = t.isActive();
                    });
                    return active;
                },
                activate: function activate() {
                    ttEach(this, function(t) {
                        t.activate();
                    });
                    return this;
                },
                deactivate: function deactivate() {
                    ttEach(this, function(t) {
                        t.deactivate();
                    });
                    return this;
                },
                isOpen: function isOpen() {
                    var open;
                    ttEach(this.first(), function(t) {
                        open = t.isOpen();
                    });
                    return open;
                },
                open: function open() {
                    ttEach(this, function(t) {
                        t.open();
                    });
                    return this;
                },
                close: function close() {
                    ttEach(this, function(t) {
                        t.close();
                    });
                    return this;
                },
                select: function select(el) {
                    var success = false, $el = $(el);
                    ttEach(this.first(), function(t) {
                        success = t.select($el);
                    });
                    return success;
                },
                autocomplete: function autocomplete(el) {
                    var success = false, $el = $(el);
                    ttEach(this.first(), function(t) {
                        success = t.autocomplete($el);
                    });
                    return success;
                },
                moveCursor: function moveCursoe(delta) {
                    var success = false;
                    ttEach(this.first(), function(t) {
                        success = t.moveCursor(delta);
                    });
                    return success;
                },
                val: function val(newVal) {
                    var query;
                    if (!arguments.length) {
                        ttEach(this.first(), function(t) {
                            query = t.getVal();
                        });
                        return query;
                    } else {
                        ttEach(this, function(t) {
                            t.setVal(newVal);
                        });
                        return this;
                    }
                },
                destroy: function destroy() {
                    ttEach(this, function(typeahead, $input) {
                        revert($input);
                        typeahead.destroy();
                    });
                    return this;
                }
            };
            $.fn.typeahead = function(method) {
                if (methods[method]) {
                    return methods[method].apply(this, [].slice.call(arguments, 1));
                } else {
                    return methods.initialize.apply(this, arguments);
                }
            };
            $.fn.typeahead.noConflict = function noConflict() {
                $.fn.typeahead = old;
                return this;
            };
            function ttEach($els, fn) {
                $els.each(function() {
                    var $input = $(this), typeahead;
                    (typeahead = $input.data(keys.typeahead)) && fn(typeahead, $input);
                });
            }
            function buildHintFromInput($input, www) {
                return $input.clone().addClass(www.classes.hint).removeData().css(www.css.hint).css(getBackgroundStyles($input)).prop("readonly", true).removeAttr("id name placeholder required").attr({
                    autocomplete: "off",
                    spellcheck: "false",
                    tabindex: -1
                });
            }
            function prepInput($input, www) {
                $input.data(keys.attrs, {
                    dir: $input.attr("dir"),
                    autocomplete: $input.attr("autocomplete"),
                    spellcheck: $input.attr("spellcheck"),
                    style: $input.attr("style")
                });
                $input.addClass(www.classes.input).attr({
                    autocomplete: "off",
                    spellcheck: false
                });
                try {
                    !$input.attr("dir") && $input.attr("dir", "auto");
                } catch (e) {}
                return $input;
            }
            function getBackgroundStyles($el) {
                return {
                    backgroundAttachment: $el.css("background-attachment"),
                    backgroundClip: $el.css("background-clip"),
                    backgroundColor: $el.css("background-color"),
                    backgroundImage: $el.css("background-image"),
                    backgroundOrigin: $el.css("background-origin"),
                    backgroundPosition: $el.css("background-position"),
                    backgroundRepeat: $el.css("background-repeat"),
                    backgroundSize: $el.css("background-size")
                };
            }
            function revert($input) {
                var www, $wrapper;
                www = $input.data(keys.www);
                $wrapper = $input.parent().filter(www.selectors.wrapper);
                _.each($input.data(keys.attrs), function(val, key) {
                    _.isUndefined(val) ? $input.removeAttr(key) : $input.attr(key, val);
                });
                $input.removeData(keys.typeahead).removeData(keys.www).removeData(keys.attr).removeClass(www.classes.input);
                if ($wrapper.length) {
                    $input.detach().insertAfter($wrapper);
                    $wrapper.remove();
                }
            }
            function $elOrNull(obj) {
                var isValid, $el;
                isValid = _.isJQuery(obj) || _.isElement(obj);
                $el = isValid ? $(obj).first() : [];
                return $el.length ? $el : null;
            }
        })();
    });
    ; browserify_shim__define__module__export__(typeof typeaheadjs != "undefined" ? typeaheadjs : window.typeaheadjs);
    
    }).call(global, undefined, undefined, undefined, undefined, function defineExport(ex) { module.exports = ex; });
    
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    },{"jQuery":60}],57:[function(require,module,exports){
    /*
     *	jQuery dotdotdot 1.7.0
     *
     *	Copyright (c) Fred Heusschen
     *	www.frebsite.nl
     *
     *	Plugin website:
     *	dotdotdot.frebsite.nl
     *
     *	Licensed under the MIT license.
     *	http://en.wikipedia.org/wiki/MIT_License
     */
    
    (function( $, undef )
    {
        if ( $.fn.dotdotdot )
        {
            return;
        }
    
        $.fn.dotdotdot = function( o )
        {
            if ( this.length == 0 )
            {
                $.fn.dotdotdot.debug( 'No element found for "' + this.selector + '".' );
                return this;
            }
            if ( this.length > 1 )
            {
                return this.each(
                    function()
                    {
                        $(this).dotdotdot( o );
                    }
                );
            }
    
    
            var $dot = this;
    
            if ( $dot.data( 'dotdotdot' ) )
            {
                $dot.trigger( 'destroy.dot' );
            }
    
            $dot.data( 'dotdotdot-style', $dot.attr( 'style' ) || '' );
            $dot.css( 'word-wrap', 'break-word' );
            if ($dot.css( 'white-space' ) === 'nowrap')
            {
                $dot.css( 'white-space', 'normal' );
            }
    
            $dot.bind_events = function()
            {
                $dot.bind(
                    'update.dot',
                    function( e, c )
                    {
                        e.preventDefault();
                        e.stopPropagation();
    
                        opts.maxHeight = ( typeof opts.height == 'number' )
                            ? opts.height
                            : getTrueInnerHeight( $dot );
    
                        opts.maxHeight += opts.tolerance;
    
                        if ( typeof c != 'undefined' )
                        {
                            if ( typeof c == 'string' || c instanceof HTMLElement )
                            {
                                 c = $('<div />').append( c ).contents();
                            }
                            if ( c instanceof $ )
                            {
                                orgContent = c;
                            }
                        }
    
                        $inr = $dot.wrapInner( '<div class="dotdotdot" />' ).children();
                        $inr.contents()
                            .detach()
                            .end()
                            .append( orgContent.clone( true ) )
                            .find( 'br' )
                            .replaceWith( '  <br />  ' )
                            .end()
                            .css({
                                'height'	: 'auto',
                                'width'		: 'auto',
                                'border'	: 'none',
                                'padding'	: 0,
                                'margin'	: 0
                            });
    
                        var after = false,
                            trunc = false;
    
                        if ( conf.afterElement )
                        {
                            after = conf.afterElement.clone( true );
                            after.show();
                            conf.afterElement.detach();
                        }
    
                        if ( test( $inr, opts ) )
                        {
                            if ( opts.wrap == 'children' )
                            {
                                trunc = children( $inr, opts, after );
                            }
                            else
                            {
                                trunc = ellipsis( $inr, $dot, $inr, opts, after );
                            }
                        }
                        $inr.replaceWith( $inr.contents() );
                        $inr = null;
    
                        if ( $.isFunction( opts.callback ) )
                        {
                            opts.callback.call( $dot[ 0 ], trunc, orgContent );
                        }
    
                        conf.isTruncated = trunc;
                        return trunc;
                    }
    
                ).bind(
                    'isTruncated.dot',
                    function( e, fn )
                    {
                        e.preventDefault();
                        e.stopPropagation();
    
                        if ( typeof fn == 'function' )
                        {
                            fn.call( $dot[ 0 ], conf.isTruncated );
                        }
                        return conf.isTruncated;
                    }
    
                ).bind(
                    'originalContent.dot',
                    function( e, fn )
                    {
                        e.preventDefault();
                        e.stopPropagation();
    
                        if ( typeof fn == 'function' )
                        {
                            fn.call( $dot[ 0 ], orgContent );
                        }
                        return orgContent;
                    }
    
                ).bind(
                    'destroy.dot',
                    function( e )
                    {
                        e.preventDefault();
                        e.stopPropagation();
    
                        $dot.unwatch()
                            .unbind_events()
                            .contents()
                            .detach()
                            .end()
                            .append( orgContent )
                            .attr( 'style', $dot.data( 'dotdotdot-style' ) || '' )
                            .data( 'dotdotdot', false );
                    }
                );
                return $dot;
            };	//	/bind_events
    
            $dot.unbind_events = function()
            {
                $dot.unbind('.dot');
                return $dot;
            };	//	/unbind_events
    
            $dot.watch = function()
            {
                $dot.unwatch();
                if ( opts.watch == 'window' )
                {
                    var $window = $(window),
                        _wWidth = $window.width(),
                        _wHeight = $window.height();
    
                    $window.bind(
                        'resize.dot' + conf.dotId,
                        function()
                        {
                            if ( _wWidth != $window.width() || _wHeight != $window.height() || !opts.windowResizeFix )
                            {
                                _wWidth = $window.width();
                                _wHeight = $window.height();
    
                                if ( watchInt )
                                {
                                    clearInterval( watchInt );
                                }
                                watchInt = setTimeout(
                                    function()
                                    {
                                        $dot.trigger( 'update.dot' );
                                    }, 100
                                );
                            }
                        }
                    );
                }
                else
                {
                    watchOrg = getSizes( $dot );
                    watchInt = setInterval(
                        function()
                        {
                            if ( $dot.is( ':visible' ) )
                            {
                                var watchNew = getSizes( $dot );
                                if ( watchOrg.width  != watchNew.width ||
                                     watchOrg.height != watchNew.height )
                                {
                                    $dot.trigger( 'update.dot' );
                                    watchOrg = watchNew;
                                }
                            }
                        }, 500
                    );
                }
                return $dot;
            };
            $dot.unwatch = function()
            {
                $(window).unbind( 'resize.dot' + conf.dotId );
                if ( watchInt )
                {
                    clearInterval( watchInt );
                }
                return $dot;
            };
    
            var	orgContent	= $dot.contents(),
                opts 		= $.extend( true, {}, $.fn.dotdotdot.defaults, o ),
                conf		= {},
                watchOrg	= {},
                watchInt	= null,
                $inr		= null;
    
    
            if ( !( opts.lastCharacter.remove instanceof Array ) )
            {
                opts.lastCharacter.remove = $.fn.dotdotdot.defaultArrays.lastCharacter.remove;
            }
            if ( !( opts.lastCharacter.noEllipsis instanceof Array ) )
            {
                opts.lastCharacter.noEllipsis = $.fn.dotdotdot.defaultArrays.lastCharacter.noEllipsis;
            }
    
    
            conf.afterElement	= getElement( opts.after, $dot );
            conf.isTruncated	= false;
            conf.dotId			= dotId++;
    
    
            $dot.data( 'dotdotdot', true )
                .bind_events()
                .trigger( 'update.dot' );
    
            if ( opts.watch )
            {
                $dot.watch();
            }
    
            return $dot;
        };
    
    
        //	public
        $.fn.dotdotdot.defaults = {
            'ellipsis'			: '... ',
            'wrap'				: 'word',
            'fallbackToLetter'	: true,
            'lastCharacter'		: {},
            'tolerance'			: 0,
            'callback'			: null,
            'after'				: null,
            'height'			: null,
            'watch'				: false,
            'windowResizeFix'	: true
        };
        $.fn.dotdotdot.defaultArrays = {
            'lastCharacter'		: {
                'remove'			: [ ' ', '\u3000', ',', ';', '.', '!', '?' ],
                'noEllipsis'		: []
            }
        };
        $.fn.dotdotdot.debug = function( msg ) {};
    
    
        //	private
        var dotId = 1;
    
        function children( $elem, o, after )
        {
            var $elements 	= $elem.children(),
                isTruncated	= false;
    
            $elem.empty();
    
            for ( var a = 0, l = $elements.length; a < l; a++ )
            {
                var $e = $elements.eq( a );
                $elem.append( $e );
                if ( after )
                {
                    $elem.append( after );
                }
                if ( test( $elem, o ) )
                {
                    $e.remove();
                    isTruncated = true;
                    break;
                }
                else
                {
                    if ( after )
                    {
                        after.detach();
                    }
                }
            }
            return isTruncated;
        }
        function ellipsis( $elem, $d, $i, o, after )
        {
            var isTruncated	= false;
    
            //	Don't put the ellipsis directly inside these elements
            var notx = 'table, thead, tbody, tfoot, tr, col, colgroup, object, embed, param, ol, ul, dl, blockquote, select, optgroup, option, textarea, script, style';
    
            //	Don't remove these elements even if they are after the ellipsis
            var noty = 'script, .dotdotdot-keep';
    
            $elem
                .contents()
                .detach()
                .each(
                    function()
                    {
    
                        var e	= this,
                            $e	= $(e);
    
                        if ( typeof e == 'undefined' || ( e.nodeType == 3 && $.trim( e.data ).length == 0 ) )
                        {
                            return true;
                        }
                        else if ( $e.is( noty ) )
                        {
                            $elem.append( $e );
                        }
                        else if ( isTruncated )
                        {
                            return true;
                        }
                        else
                        {
                            $elem.append( $e );
                            if ( after )
                            {
                                $elem[ $elem.is( notx ) ? 'after' : 'append' ]( after );
                            }
                            if ( test( $i, o ) )
                            {
                                if ( e.nodeType == 3 ) // node is TEXT
                                {
                                    isTruncated = ellipsisElement( $e, $d, $i, o, after );
                                }
                                else
                                {
                                    isTruncated = ellipsis( $e, $d, $i, o, after );
                                }
    
                                if ( !isTruncated )
                                {
                                    $e.detach();
                                    isTruncated = true;
                                }
                            }
    
                            if ( !isTruncated )
                            {
                                if ( after )
                                {
                                    after.detach();
                                }
                            }
                        }
                    }
                );
    
            return isTruncated;
        }
        function ellipsisElement( $e, $d, $i, o, after )
        {
            var e = $e[ 0 ];
    
            if ( !e )
            {
                return false;
            }
    
            var txt			= getTextContent( e ),
                space		= ( txt.indexOf(' ') !== -1 ) ? ' ' : '\u3000',
                separator	= ( o.wrap == 'letter' ) ? '' : space,
                textArr		= txt.split( separator ),
                position 	= -1,
                midPos		= -1,
                startPos	= 0,
                endPos		= textArr.length - 1;
    
    
            //	Only one word
            if ( o.fallbackToLetter && startPos == 0 && endPos == 0 )
            {
                separator	= '';
                textArr		= txt.split( separator );
                endPos		= textArr.length - 1;
            }
    
            while ( startPos <= endPos && !( startPos == 0 && endPos == 0 ) )
            {
                var m = Math.floor( ( startPos + endPos ) / 2 );
                if ( m == midPos )
                {
                    break;
                }
                midPos = m;
    
                setTextContent( e, textArr.slice( 0, midPos + 1 ).join( separator ) + o.ellipsis );
    
                if ( !test( $i, o ) )
                {
                    position = midPos;
                    startPos = midPos;
                }
                else
                {
                    endPos = midPos;
    
                    //	Fallback to letter
                    if (o.fallbackToLetter && startPos == 0 && endPos == 0 )
                    {
                        separator	= '';
                        textArr		= textArr[ 0 ].split( separator );
                        position	= -1;
                        midPos		= -1;
                        startPos	= 0;
                        endPos		= textArr.length - 1;
                    }
                }
            }
    
            if ( position != -1 && !( textArr.length == 1 && textArr[ 0 ].length == 0 ) )
            {
                txt = addEllipsis( textArr.slice( 0, position + 1 ).join( separator ), o );
                setTextContent( e, txt );
            }
            else
            {
                var $w = $e.parent();
                $e.detach();
    
                var afterLength = ( after && after.closest($w).length ) ? after.length : 0;
    
                if ( $w.contents().length > afterLength )
                {
                    e = findLastTextNode( $w.contents().eq( -1 - afterLength ), $d );
                }
                else
                {
                    e = findLastTextNode( $w, $d, true );
                    if ( !afterLength )
                    {
                        $w.detach();
                    }
                }
                if ( e )
                {
                    txt = addEllipsis( getTextContent( e ), o );
                    setTextContent( e, txt );
                    if ( afterLength && after )
                    {
                        $(e).parent().append( after );
                    }
                }
            }
    
            return true;
        }
        function test( $i, o )
        {
            return $i.innerHeight() > o.maxHeight;
        }
        function addEllipsis( txt, o )
        {
            while( $.inArray( txt.slice( -1 ), o.lastCharacter.remove ) > -1 )
            {
                txt = txt.slice( 0, -1 );
            }
            if ( $.inArray( txt.slice( -1 ), o.lastCharacter.noEllipsis ) < 0 )
            {
                txt += o.ellipsis;
            }
            return txt;
        }
        function getSizes( $d )
        {
            return {
                'width'	: $d.innerWidth(),
                'height': $d.innerHeight()
            };
        }
        function setTextContent( e, content )
        {
            if ( e.innerText )
            {
                e.innerText = content;
            }
            else if ( e.nodeValue )
            {
                e.nodeValue = content;
            }
            else if (e.textContent)
            {
                e.textContent = content;
            }
    
        }
        function getTextContent( e )
        {
            if ( e.innerText )
            {
                return e.innerText;
            }
            else if ( e.nodeValue )
            {
                return e.nodeValue;
            }
            else if ( e.textContent )
            {
                return e.textContent;
            }
            else
            {
                return "";
            }
        }
        function getPrevNode( n )
        {
            do
            {
                n = n.previousSibling;
            }
            while ( n && n.nodeType !== 1 && n.nodeType !== 3 );
    
            return n;
        }
        function findLastTextNode( $el, $top, excludeCurrent )
        {
            var e = $el && $el[ 0 ], p;
            if ( e )
            {
                if ( !excludeCurrent )
                {
                    if ( e.nodeType === 3 )
                    {
                        return e;
                    }
                    if ( $.trim( $el.text() ) )
                    {
                        return findLastTextNode( $el.contents().last(), $top );
                    }
                }
                p = getPrevNode( e );
                while ( !p )
                {
                    $el = $el.parent();
                    if ( $el.is( $top ) || !$el.length )
                    {
                        return false;
                    }
                    p = getPrevNode( $el[0] );
                }
                if ( p )
                {
                    return findLastTextNode( $(p), $top );
                }
            }
            return false;
        }
        function getElement( e, $i )
        {
            if ( !e )
            {
                return false;
            }
            if ( typeof e === 'string' )
            {
                e = $(e, $i);
                return ( e.length )
                    ? e
                    : false;
            }
            return !e.jquery
                ? false
                : e;
        }
        function getTrueInnerHeight( $el )
        {
            var h = $el.innerHeight(),
                a = [ 'paddingTop', 'paddingBottom' ];
    
            for ( var z = 0, l = a.length; z < l; z++ )
            {
                var m = parseInt( $el.css( a[ z ] ), 10 );
                if ( isNaN( m ) )
                {
                    m = 0;
                }
                h -= m;
            }
            return h;
        }
    
    
        //	override jQuery.html
        var _orgHtml = $.fn.html;
        $.fn.html = function( str )
        {
            if ( str != undef && !$.isFunction( str ) && this.data( 'dotdotdot' ) )
            {
                return this.trigger( 'update', [ str ] );
            }
            return _orgHtml.apply( this, arguments );
        };
    
    
        //	override jQuery.text
        var _orgText = $.fn.text;
        $.fn.text = function( str )
        {
            if ( str != undef && !$.isFunction( str ) && this.data( 'dotdotdot' ) )
            {
                str = $( '<div />' ).text( str ).html();
                return this.trigger( 'update', [ str ] );
            }
            return _orgText.apply( this, arguments );
        };
    
    
    })( jQuery );
    
    },{}],58:[function(require,module,exports){
    /**
     * @name InfoBox
     * @version 1.1.13 [March 19, 2014]
     * @author Gary Little (inspired by proof-of-concept code from Pamela Fox of Google)
     * @copyright Copyright 2010 Gary Little [gary at luxcentral.com]
     * @fileoverview InfoBox extends the Google Maps JavaScript API V3 <tt>OverlayView</tt> class.
     *  <p>
     *  An InfoBox behaves like a <tt>google.maps.InfoWindow</tt>, but it supports several
     *  additional properties for advanced styling. An InfoBox can also be used as a map label.
     *  <p>
     *  An InfoBox also fires the same events as a <tt>google.maps.InfoWindow</tt>.
     */
    
    /*!
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *       http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    
    /*jslint browser:true */
    /*global google */
    
    /**
     * @name InfoBoxOptions
     * @class This class represents the optional parameter passed to the {@link InfoBox} constructor.
     * @property {string|Node} content The content of the InfoBox (plain text or an HTML DOM node).
     * @property {boolean} [disableAutoPan=false] Disable auto-pan on <tt>open</tt>.
     * @property {number} maxWidth The maximum width (in pixels) of the InfoBox. Set to 0 if no maximum.
     * @property {Size} pixelOffset The offset (in pixels) from the top left corner of the InfoBox
     *  (or the bottom left corner if the <code>alignBottom</code> property is <code>true</code>)
     *  to the map pixel corresponding to <tt>position</tt>.
     * @property {LatLng} position The geographic location at which to display the InfoBox.
     * @property {number} zIndex The CSS z-index style value for the InfoBox.
     *  Note: This value overrides a zIndex setting specified in the <tt>boxStyle</tt> property.
     * @property {string} [boxClass="infoBox"] The name of the CSS class defining the styles for the InfoBox container.
     * @property {Object} [boxStyle] An object literal whose properties define specific CSS
     *  style values to be applied to the InfoBox. Style values defined here override those that may
     *  be defined in the <code>boxClass</code> style sheet. If this property is changed after the
     *  InfoBox has been created, all previously set styles (except those defined in the style sheet)
     *  are removed from the InfoBox before the new style values are applied.
     * @property {string} closeBoxMargin The CSS margin style value for the close box.
     *  The default is "2px" (a 2-pixel margin on all sides).
     * @property {string} closeBoxURL The URL of the image representing the close box.
     *  Note: The default is the URL for Google's standard close box.
     *  Set this property to "" if no close box is required.
     * @property {Size} infoBoxClearance Minimum offset (in pixels) from the InfoBox to the
     *  map edge after an auto-pan.
     * @property {boolean} [isHidden=false] Hide the InfoBox on <tt>open</tt>.
     *  [Deprecated in favor of the <tt>visible</tt> property.]
     * @property {boolean} [visible=true] Show the InfoBox on <tt>open</tt>.
     * @property {boolean} alignBottom Align the bottom left corner of the InfoBox to the <code>position</code>
     *  location (default is <tt>false</tt> which means that the top left corner of the InfoBox is aligned).
     * @property {string} pane The pane where the InfoBox is to appear (default is "floatPane").
     *  Set the pane to "mapPane" if the InfoBox is being used as a map label.
     *  Valid pane names are the property names for the <tt>google.maps.MapPanes</tt> object.
     * @property {boolean} enableEventPropagation Propagate mousedown, mousemove, mouseover, mouseout,
     *  mouseup, click, dblclick, touchstart, touchend, touchmove, and contextmenu events in the InfoBox
     *  (default is <tt>false</tt> to mimic the behavior of a <tt>google.maps.InfoWindow</tt>). Set
     *  this property to <tt>true</tt> if the InfoBox is being used as a map label.
     */
    
    /**
     * Creates an InfoBox with the options specified in {@link InfoBoxOptions}.
     *  Call <tt>InfoBox.open</tt> to add the box to the map.
     * @constructor
     * @param {InfoBoxOptions} [opt_opts]
     */
    function InfoBox(opt_opts) {
    
      opt_opts = opt_opts || {};
    
      google.maps.OverlayView.apply(this, arguments);
    
      // Standard options (in common with google.maps.InfoWindow):
      //
      this.content_ = opt_opts.content || "";
      this.disableAutoPan_ = opt_opts.disableAutoPan || false;
      this.maxWidth_ = opt_opts.maxWidth || 0;
      this.pixelOffset_ = opt_opts.pixelOffset || new google.maps.Size(0, 0);
      this.position_ = opt_opts.position || new google.maps.LatLng(0, 0);
      this.zIndex_ = opt_opts.zIndex || null;
    
      // Additional options (unique to InfoBox):
      //
      this.boxClass_ = opt_opts.boxClass || "infoBox";
      this.boxStyle_ = opt_opts.boxStyle || {};
      this.closeBoxMargin_ = opt_opts.closeBoxMargin || "2px";
      this.closeBoxURL_ = opt_opts.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif";
      if (opt_opts.closeBoxURL === "") {
        this.closeBoxURL_ = "";
      }
      this.infoBoxClearance_ = opt_opts.infoBoxClearance || new google.maps.Size(1, 1);
    
      if (typeof opt_opts.visible === "undefined") {
        if (typeof opt_opts.isHidden === "undefined") {
          opt_opts.visible = true;
        } else {
          opt_opts.visible = !opt_opts.isHidden;
        }
      }
      this.isHidden_ = !opt_opts.visible;
    
      this.alignBottom_ = opt_opts.alignBottom || false;
      this.pane_ = opt_opts.pane || "floatPane";
      this.enableEventPropagation_ = opt_opts.enableEventPropagation || false;
    
      this.div_ = null;
      this.closeListener_ = null;
      this.moveListener_ = null;
      this.mapListener_ = null;
      this.contextListener_ = null;
      this.eventListeners_ = null;
      this.fixedWidthSet_ = null;
    }
    
    /* InfoBox extends OverlayView in the Google Maps API v3.
     */
    InfoBox.prototype = new google.maps.OverlayView();
    
    /**
     * Creates the DIV representing the InfoBox.
     * @private
     */
    InfoBox.prototype.createInfoBoxDiv_ = function () {
    
      var i;
      var events;
      var bw;
      var me = this;
    
      // This handler prevents an event in the InfoBox from being passed on to the map.
      //
      var cancelHandler = function (e) {
        e.cancelBubble = true;
        if (e.stopPropagation) {
          e.stopPropagation();
        }
      };
    
      // This handler ignores the current event in the InfoBox and conditionally prevents
      // the event from being passed on to the map. It is used for the contextmenu event.
      //
      var ignoreHandler = function (e) {
    
        e.returnValue = false;
    
        if (e.preventDefault) {
    
          e.preventDefault();
        }
    
        if (!me.enableEventPropagation_) {
    
          cancelHandler(e);
        }
      };
    
      if (!this.div_) {
    
        this.div_ = document.createElement("div");
    
        this.setBoxStyle_();
    
        if (typeof this.content_.nodeType === "undefined") {
          this.div_.innerHTML = this.getCloseBoxImg_() + this.content_;
        } else {
          this.div_.innerHTML = this.getCloseBoxImg_();
          this.div_.appendChild(this.content_);
        }
    
        // Add the InfoBox DIV to the DOM
        this.getPanes()[this.pane_].appendChild(this.div_);
    
        this.addClickHandler_();
    
        if (this.div_.style.width) {
    
          this.fixedWidthSet_ = true;
    
        } else {
    
          if (this.maxWidth_ !== 0 && this.div_.offsetWidth > this.maxWidth_) {
    
            this.div_.style.width = this.maxWidth_;
            this.fixedWidthSet_ = true;
    
          } else { // The following code is needed to overcome problems with MSIE
    
            bw = this.getBoxWidths_();
    
            this.div_.style.width = (this.div_.offsetWidth - bw.left - bw.right) + "px";
            this.fixedWidthSet_ = false;
          }
        }
    
        this.panBox_(this.disableAutoPan_);
    
        if (!this.enableEventPropagation_) {
    
          this.eventListeners_ = [];
    
          // Cancel event propagation.
          //
          // Note: mousemove not included (to resolve Issue 152)
          events = ["mousedown", "mouseover", "mouseout", "mouseup",
          "click", "dblclick", "touchstart", "touchend", "touchmove"];
    
          for (i = 0; i < events.length; i++) {
    
            this.eventListeners_.push(google.maps.event.addDomListener(this.div_, events[i], cancelHandler));
          }
          
          // Workaround for Google bug that causes the cursor to change to a pointer
          // when the mouse moves over a marker underneath InfoBox.
          this.eventListeners_.push(google.maps.event.addDomListener(this.div_, "mouseover", function (e) {
            this.style.cursor = "default";
          }));
        }
    
        this.contextListener_ = google.maps.event.addDomListener(this.div_, "contextmenu", ignoreHandler);
    
        /**
         * This event is fired when the DIV containing the InfoBox's content is attached to the DOM.
         * @name InfoBox#domready
         * @event
         */
        google.maps.event.trigger(this, "domready");
      }
    };
    
    /**
     * Returns the HTML <IMG> tag for the close box.
     * @private
     */
    InfoBox.prototype.getCloseBoxImg_ = function () {
    
      var img = "";
    
      if (this.closeBoxURL_ !== "") {
    
        img  = "<img";
        img += " src='" + this.closeBoxURL_ + "'";
        img += " align=right"; // Do this because Opera chokes on style='float: right;'
        img += " style='";
        img += " position: relative;"; // Required by MSIE
        img += " cursor: pointer;";
        img += " margin: " + this.closeBoxMargin_ + ";";
        img += "'>";
      }
    
      return img;
    };
    
    /**
     * Adds the click handler to the InfoBox close box.
     * @private
     */
    InfoBox.prototype.addClickHandler_ = function () {
    
      var closeBox;
    
      if (this.closeBoxURL_ !== "") {
    
        closeBox = this.div_.firstChild;
        this.closeListener_ = google.maps.event.addDomListener(closeBox, "click", this.getCloseClickHandler_());
    
      } else {
    
        this.closeListener_ = null;
      }
    };
    
    /**
     * Returns the function to call when the user clicks the close box of an InfoBox.
     * @private
     */
    InfoBox.prototype.getCloseClickHandler_ = function () {
    
      var me = this;
    
      return function (e) {
    
        // 1.0.3 fix: Always prevent propagation of a close box click to the map:
        e.cancelBubble = true;
    
        if (e.stopPropagation) {
    
          e.stopPropagation();
        }
    
        /**
         * This event is fired when the InfoBox's close box is clicked.
         * @name InfoBox#closeclick
         * @event
         */
        google.maps.event.trigger(me, "closeclick");
    
        me.close();
      };
    };
    
    /**
     * Pans the map so that the InfoBox appears entirely within the map's visible area.
     * @private
     */
    InfoBox.prototype.panBox_ = function (disablePan) {
    
      var map;
      var bounds;
      var xOffset = 0, yOffset = 0;
    
      if (!disablePan) {
    
        map = this.getMap();
    
        if (map instanceof google.maps.Map) { // Only pan if attached to map, not panorama
    
          if (!map.getBounds().contains(this.position_)) {
          // Marker not in visible area of map, so set center
          // of map to the marker position first.
            map.setCenter(this.position_);
          }
    
          bounds = map.getBounds();
    
          var mapDiv = map.getDiv();
          var mapWidth = mapDiv.offsetWidth;
          var mapHeight = mapDiv.offsetHeight;
          var iwOffsetX = this.pixelOffset_.width;
          var iwOffsetY = this.pixelOffset_.height;
          var iwWidth = this.div_.offsetWidth;
          var iwHeight = this.div_.offsetHeight;
          var padX = this.infoBoxClearance_.width;
          var padY = this.infoBoxClearance_.height;
          var pixPosition = this.getProjection().fromLatLngToContainerPixel(this.position_);
    
          if (pixPosition.x < (-iwOffsetX + padX)) {
            xOffset = pixPosition.x + iwOffsetX - padX;
          } else if ((pixPosition.x + iwWidth + iwOffsetX + padX) > mapWidth) {
            xOffset = pixPosition.x + iwWidth + iwOffsetX + padX - mapWidth;
          }
          if (this.alignBottom_) {
            if (pixPosition.y < (-iwOffsetY + padY + iwHeight)) {
              yOffset = pixPosition.y + iwOffsetY - padY - iwHeight;
            } else if ((pixPosition.y + iwOffsetY + padY) > mapHeight) {
              yOffset = pixPosition.y + iwOffsetY + padY - mapHeight;
            }
          } else {
            if (pixPosition.y < (-iwOffsetY + padY)) {
              yOffset = pixPosition.y + iwOffsetY - padY;
            } else if ((pixPosition.y + iwHeight + iwOffsetY + padY) > mapHeight) {
              yOffset = pixPosition.y + iwHeight + iwOffsetY + padY - mapHeight;
            }
          }
    
          if (!(xOffset === 0 && yOffset === 0)) {
    
            // Move the map to the shifted center.
            //
            var c = map.getCenter();
            map.panBy(xOffset, yOffset);
          }
        }
      }
    };
    
    /**
     * Sets the style of the InfoBox by setting the style sheet and applying
     * other specific styles requested.
     * @private
     */
    InfoBox.prototype.setBoxStyle_ = function () {
    
      var i, boxStyle;
    
      if (this.div_) {
    
        // Apply style values from the style sheet defined in the boxClass parameter:
        this.div_.className = this.boxClass_;
    
        // Clear existing inline style values:
        this.div_.style.cssText = "";
    
        // Apply style values defined in the boxStyle parameter:
        boxStyle = this.boxStyle_;
        for (i in boxStyle) {
    
          if (boxStyle.hasOwnProperty(i)) {
    
            this.div_.style[i] = boxStyle[i];
          }
        }
    
        // Fix for iOS disappearing InfoBox problem.
        // See http://stackoverflow.com/questions/9229535/google-maps-markers-disappear-at-certain-zoom-level-only-on-iphone-ipad
        this.div_.style.WebkitTransform = "translateZ(0)";
    
        // Fix up opacity style for benefit of MSIE:
        //
        if (typeof this.div_.style.opacity !== "undefined" && this.div_.style.opacity !== "") {
          // See http://www.quirksmode.org/css/opacity.html
          this.div_.style.MsFilter = "\"progid:DXImageTransform.Microsoft.Alpha(Opacity=" + (this.div_.style.opacity * 100) + ")\"";
          this.div_.style.filter = "alpha(opacity=" + (this.div_.style.opacity * 100) + ")";
        }
    
        // Apply required styles:
        //
        this.div_.style.position = "absolute";
        this.div_.style.visibility = 'hidden';
        if (this.zIndex_ !== null) {
    
          this.div_.style.zIndex = this.zIndex_;
        }
        if (!this.div_.style.overflow) {
          this.div_.style.overflow = "auto";
        }
      }
    };
    
    /**
     * Get the widths of the borders of the InfoBox.
     * @private
     * @return {Object} widths object (top, bottom left, right)
     */
    InfoBox.prototype.getBoxWidths_ = function () {
    
      var computedStyle;
      var bw = {top: 0, bottom: 0, left: 0, right: 0};
      var box = this.div_;
    
      if (document.defaultView && document.defaultView.getComputedStyle) {
    
        computedStyle = box.ownerDocument.defaultView.getComputedStyle(box, "");
    
        if (computedStyle) {
    
          // The computed styles are always in pixel units (good!)
          bw.top = parseInt(computedStyle.borderTopWidth, 10) || 0;
          bw.bottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
          bw.left = parseInt(computedStyle.borderLeftWidth, 10) || 0;
          bw.right = parseInt(computedStyle.borderRightWidth, 10) || 0;
        }
    
      } else if (document.documentElement.currentStyle) { // MSIE
    
        if (box.currentStyle) {
    
          // The current styles may not be in pixel units, but assume they are (bad!)
          bw.top = parseInt(box.currentStyle.borderTopWidth, 10) || 0;
          bw.bottom = parseInt(box.currentStyle.borderBottomWidth, 10) || 0;
          bw.left = parseInt(box.currentStyle.borderLeftWidth, 10) || 0;
          bw.right = parseInt(box.currentStyle.borderRightWidth, 10) || 0;
        }
      }
    
      return bw;
    };
    
    /**
     * Invoked when <tt>close</tt> is called. Do not call it directly.
     */
    InfoBox.prototype.onRemove = function () {
    
      if (this.div_) {
    
        this.div_.parentNode.removeChild(this.div_);
        this.div_ = null;
      }
    };
    
    /**
     * Draws the InfoBox based on the current map projection and zoom level.
     */
    InfoBox.prototype.draw = function () {
    
      this.createInfoBoxDiv_();
    
      var pixPosition = this.getProjection().fromLatLngToDivPixel(this.position_);
    
      this.div_.style.left = (pixPosition.x + this.pixelOffset_.width) + "px";
      
      if (this.alignBottom_) {
        this.div_.style.bottom = -(pixPosition.y + this.pixelOffset_.height) + "px";
      } else {
        this.div_.style.top = (pixPosition.y + this.pixelOffset_.height) + "px";
      }
    
      if (this.isHidden_) {
    
        this.div_.style.visibility = "hidden";
    
      } else {
    
        this.div_.style.visibility = "visible";
      }
    };
    
    /**
     * Sets the options for the InfoBox. Note that changes to the <tt>maxWidth</tt>,
     *  <tt>closeBoxMargin</tt>, <tt>closeBoxURL</tt>, and <tt>enableEventPropagation</tt>
     *  properties have no affect until the current InfoBox is <tt>close</tt>d and a new one
     *  is <tt>open</tt>ed.
     * @param {InfoBoxOptions} opt_opts
     */
    InfoBox.prototype.setOptions = function (opt_opts) {
      if (typeof opt_opts.boxClass !== "undefined") { // Must be first
    
        this.boxClass_ = opt_opts.boxClass;
        this.setBoxStyle_();
      }
      if (typeof opt_opts.boxStyle !== "undefined") { // Must be second
    
        this.boxStyle_ = opt_opts.boxStyle;
        this.setBoxStyle_();
      }
      if (typeof opt_opts.content !== "undefined") {
    
        this.setContent(opt_opts.content);
      }
      if (typeof opt_opts.disableAutoPan !== "undefined") {
    
        this.disableAutoPan_ = opt_opts.disableAutoPan;
      }
      if (typeof opt_opts.maxWidth !== "undefined") {
    
        this.maxWidth_ = opt_opts.maxWidth;
      }
      if (typeof opt_opts.pixelOffset !== "undefined") {
    
        this.pixelOffset_ = opt_opts.pixelOffset;
      }
      if (typeof opt_opts.alignBottom !== "undefined") {
    
        this.alignBottom_ = opt_opts.alignBottom;
      }
      if (typeof opt_opts.position !== "undefined") {
    
        this.setPosition(opt_opts.position);
      }
      if (typeof opt_opts.zIndex !== "undefined") {
    
        this.setZIndex(opt_opts.zIndex);
      }
      if (typeof opt_opts.closeBoxMargin !== "undefined") {
    
        this.closeBoxMargin_ = opt_opts.closeBoxMargin;
      }
      if (typeof opt_opts.closeBoxURL !== "undefined") {
    
        this.closeBoxURL_ = opt_opts.closeBoxURL;
      }
      if (typeof opt_opts.infoBoxClearance !== "undefined") {
    
        this.infoBoxClearance_ = opt_opts.infoBoxClearance;
      }
      if (typeof opt_opts.isHidden !== "undefined") {
    
        this.isHidden_ = opt_opts.isHidden;
      }
      if (typeof opt_opts.visible !== "undefined") {
    
        this.isHidden_ = !opt_opts.visible;
      }
      if (typeof opt_opts.enableEventPropagation !== "undefined") {
    
        this.enableEventPropagation_ = opt_opts.enableEventPropagation;
      }
    
      if (this.div_) {
    
        this.draw();
      }
    };
    
    /**
     * Sets the content of the InfoBox.
     *  The content can be plain text or an HTML DOM node.
     * @param {string|Node} content
     */
    InfoBox.prototype.setContent = function (content) {
      this.content_ = content;
    
      if (this.div_) {
    
        if (this.closeListener_) {
    
          google.maps.event.removeListener(this.closeListener_);
          this.closeListener_ = null;
        }
    
        // Odd code required to make things work with MSIE.
        //
        if (!this.fixedWidthSet_) {
    
          this.div_.style.width = "";
        }
    
        if (typeof content.nodeType === "undefined") {
          this.div_.innerHTML = this.getCloseBoxImg_() + content;
        } else {
          this.div_.innerHTML = this.getCloseBoxImg_();
          this.div_.appendChild(content);
        }
    
        // Perverse code required to make things work with MSIE.
        // (Ensures the close box does, in fact, float to the right.)
        //
        if (!this.fixedWidthSet_) {
          this.div_.style.width = this.div_.offsetWidth + "px";
          if (typeof content.nodeType === "undefined") {
            this.div_.innerHTML = this.getCloseBoxImg_() + content;
          } else {
            this.div_.innerHTML = this.getCloseBoxImg_();
            this.div_.appendChild(content);
          }
        }
    
        this.addClickHandler_();
      }
    
      /**
       * This event is fired when the content of the InfoBox changes.
       * @name InfoBox#content_changed
       * @event
       */
      google.maps.event.trigger(this, "content_changed");
    };
    
    /**
     * Sets the geographic location of the InfoBox.
     * @param {LatLng} latlng
     */
    InfoBox.prototype.setPosition = function (latlng) {
    
      this.position_ = latlng;
    
      if (this.div_) {
    
        this.draw();
      }
    
      /**
       * This event is fired when the position of the InfoBox changes.
       * @name InfoBox#position_changed
       * @event
       */
      google.maps.event.trigger(this, "position_changed");
    };
    
    /**
     * Sets the zIndex style for the InfoBox.
     * @param {number} index
     */
    InfoBox.prototype.setZIndex = function (index) {
    
      this.zIndex_ = index;
    
      if (this.div_) {
    
        this.div_.style.zIndex = index;
      }
    
      /**
       * This event is fired when the zIndex of the InfoBox changes.
       * @name InfoBox#zindex_changed
       * @event
       */
      google.maps.event.trigger(this, "zindex_changed");
    };
    
    /**
     * Sets the visibility of the InfoBox.
     * @param {boolean} isVisible
     */
    InfoBox.prototype.setVisible = function (isVisible) {
    
      this.isHidden_ = !isVisible;
      if (this.div_) {
        this.div_.style.visibility = (this.isHidden_ ? "hidden" : "visible");
      }
    };
    
    /**
     * Returns the content of the InfoBox.
     * @returns {string}
     */
    InfoBox.prototype.getContent = function () {
    
      return this.content_;
    };
    
    /**
     * Returns the geographic location of the InfoBox.
     * @returns {LatLng}
     */
    InfoBox.prototype.getPosition = function () {
    
      return this.position_;
    };
    
    /**
     * Returns the zIndex for the InfoBox.
     * @returns {number}
     */
    InfoBox.prototype.getZIndex = function () {
    
      return this.zIndex_;
    };
    
    /**
     * Returns a flag indicating whether the InfoBox is visible.
     * @returns {boolean}
     */
    InfoBox.prototype.getVisible = function () {
    
      var isVisible;
    
      if ((typeof this.getMap() === "undefined") || (this.getMap() === null)) {
        isVisible = false;
      } else {
        isVisible = !this.isHidden_;
      }
      return isVisible;
    };
    
    /**
     * Shows the InfoBox. [Deprecated; use <tt>setVisible</tt> instead.]
     */
    InfoBox.prototype.show = function () {
    
      this.isHidden_ = false;
      if (this.div_) {
        this.div_.style.visibility = "visible";
      }
    };
    
    /**
     * Hides the InfoBox. [Deprecated; use <tt>setVisible</tt> instead.]
     */
    InfoBox.prototype.hide = function () {
    
      this.isHidden_ = true;
      if (this.div_) {
        this.div_.style.visibility = "hidden";
      }
    };
    
    /**
     * Adds the InfoBox to the specified map or Street View panorama. If <tt>anchor</tt>
     *  (usually a <tt>google.maps.Marker</tt>) is specified, the position
     *  of the InfoBox is set to the position of the <tt>anchor</tt>. If the
     *  anchor is dragged to a new location, the InfoBox moves as well.
     * @param {Map|StreetViewPanorama} map
     * @param {MVCObject} [anchor]
     */
    InfoBox.prototype.open = function (map, anchor) {
    
      var me = this;
    
      if (anchor) {
    
        this.position_ = anchor.getPosition();
        this.moveListener_ = google.maps.event.addListener(anchor, "position_changed", function () {
          me.setPosition(this.getPosition());
        });
    
        this.mapListener_ = google.maps.event.addListener(anchor, "map_changed", function() {
          me.setMap(this.map);
        });    
      }
    
      this.setMap(map);
    
      if (this.div_) {
    
        this.panBox_();
      }
    };
    
    /**
     * Removes the InfoBox from the map.
     */
    InfoBox.prototype.close = function () {
    
      var i;
    
      if (this.closeListener_) {
    
        google.maps.event.removeListener(this.closeListener_);
        this.closeListener_ = null;
      }
    
      if (this.eventListeners_) {
        
        for (i = 0; i < this.eventListeners_.length; i++) {
    
          google.maps.event.removeListener(this.eventListeners_[i]);
        }
        this.eventListeners_ = null;
      }
    
      if (this.moveListener_) {
    
        google.maps.event.removeListener(this.moveListener_);
        this.moveListener_ = null;
      }
    
      if (this.mapListener_) {
        
        google.maps.event.removeListener(this.mapListener_);
        this.mapListener_ = null;    
      }
     
      if (this.contextListener_) {
    
        google.maps.event.removeListener(this.contextListener_);
        this.contextListener_ = null;
      }
    
      this.setMap(null);
    };
    
    
    module.exports = InfoBox;
    },{}],59:[function(require,module,exports){
    (function(root, factory) {
    
        if (root === null) {
            throw new Error('Google-maps package can be used only in browser');
        }
    
        if (typeof define === 'function' && define.amd) {
            define(factory);
        } else if (typeof exports === 'object') {
            module.exports = factory();
        } else {
            root.GoogleMapsLoader = factory();
        }
    
    })(typeof window !== 'undefined' ? window : null, function() {
    
    
        'use strict';
    
    
        var googleVersion = '3.18';
    
        var script = null;
    
        var google = null;
    
        var loading = false;
    
        var callbacks = [];
    
        var onLoadEvents = [];
    
        var originalCreateLoaderMethod = null;
    
    
        var GoogleMapsLoader = {};
    
    
        GoogleMapsLoader.URL = 'https://maps.googleapis.com/maps/api/js';
    
        GoogleMapsLoader.KEY = null;
    
        GoogleMapsLoader.LIBRARIES = [];
    
        GoogleMapsLoader.CLIENT = null;
    
        GoogleMapsLoader.CHANNEL = null;
    
        GoogleMapsLoader.LANGUAGE = null;
    
        GoogleMapsLoader.REGION = null;
    
        GoogleMapsLoader.VERSION = googleVersion;
    
        GoogleMapsLoader.WINDOW_CALLBACK_NAME = '__google_maps_api_provider_initializator__';
    
    
        GoogleMapsLoader._googleMockApiObject = {};
    
    
        GoogleMapsLoader.load = function(fn) {
            if (google === null) {
                if (loading === true) {
                    if (fn) {
                        callbacks.push(fn);
                    }
                } else {
                    loading = true;
    
                    window[GoogleMapsLoader.WINDOW_CALLBACK_NAME] = function() {
                        ready(fn);
                    };
    
                    GoogleMapsLoader.createLoader();
                }
            } else if (fn) {
                fn(google);
            }
        };
    
    
        GoogleMapsLoader.createLoader = function() {
            script = document.createElement('script');
            script.type = 'text/javascript';
            script.src = GoogleMapsLoader.createUrl();
    
            document.body.appendChild(script);
        };
    
    
        GoogleMapsLoader.isLoaded = function() {
            return google !== null;
        };
    
    
        GoogleMapsLoader.createUrl = function() {
            var url = GoogleMapsLoader.URL;
    
            url += '?callback=' + GoogleMapsLoader.WINDOW_CALLBACK_NAME;
    
            if (GoogleMapsLoader.KEY) {
                url += '&key=' + GoogleMapsLoader.KEY;
            }
    
            if (GoogleMapsLoader.LIBRARIES.length > 0) {
                url += '&libraries=' + GoogleMapsLoader.LIBRARIES.join(',');
            }
    
            if (GoogleMapsLoader.CLIENT) {
                url += '&client=' + GoogleMapsLoader.CLIENT + '&v=' + GoogleMapsLoader.VERSION;
            }
    
            if (GoogleMapsLoader.CHANNEL) {
                url += '&channel=' + GoogleMapsLoader.CHANNEL;
            }
    
            if (GoogleMapsLoader.LANGUAGE) {
                url += '&language=' + GoogleMapsLoader.LANGUAGE;
            }
    
            if (GoogleMapsLoader.REGION) {
                url += '&region=' + GoogleMapsLoader.REGION;
            }
    
            return url;
        };
    
    
        GoogleMapsLoader.release = function(fn) {
            var release = function() {
                GoogleMapsLoader.KEY = null;
                GoogleMapsLoader.LIBRARIES = [];
                GoogleMapsLoader.CLIENT = null;
                GoogleMapsLoader.CHANNEL = null;
                GoogleMapsLoader.LANGUAGE = null;
                GoogleMapsLoader.REGION = null;
                GoogleMapsLoader.VERSION = googleVersion;
    
                google = null;
                loading = false;
                callbacks = [];
                onLoadEvents = [];
    
                if (typeof window.google !== 'undefined') {
                    delete window.google;
                }
    
                if (typeof window[GoogleMapsLoader.WINDOW_CALLBACK_NAME] !== 'undefined') {
                    delete window[GoogleMapsLoader.WINDOW_CALLBACK_NAME];
                }
    
                if (originalCreateLoaderMethod !== null) {
                    GoogleMapsLoader.createLoader = originalCreateLoaderMethod;
                    originalCreateLoaderMethod = null;
                }
    
                if (script !== null) {
                    script.parentElement.removeChild(script);
                    script = null;
                }
    
                if (fn) {
                    fn();
                }
            };
    
            if (loading) {
                GoogleMapsLoader.load(function() {
                    release();
                });
            } else {
                release();
            }
        };
    
    
        GoogleMapsLoader.onLoad = function(fn) {
            onLoadEvents.push(fn);
        };
    
    
        GoogleMapsLoader.makeMock = function() {
            originalCreateLoaderMethod = GoogleMapsLoader.createLoader;
    
            GoogleMapsLoader.createLoader = function() {
                window.google = GoogleMapsLoader._googleMockApiObject;
                window[GoogleMapsLoader.WINDOW_CALLBACK_NAME]();
            };
        };
    
    
        var ready = function(fn) {
            var i;
    
            loading = false;
    
            if (google === null) {
                google = window.google;
            }
    
            for (i = 0; i < onLoadEvents.length; i++) {
                onLoadEvents[i](google);
            }
    
            if (fn) {
                fn(google);
            }
    
            for (i = 0; i < callbacks.length; i++) {
                callbacks[i](google);
            }
    
            callbacks = [];
        };
    
    
        return GoogleMapsLoader;
    
    });
    
    },{}],60:[function(require,module,exports){
    /*!
     * jQuery JavaScript Library v2.2.4
     * http://jquery.com/
     *
     * Includes Sizzle.js
     * http://sizzlejs.com/
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license
     * http://jquery.org/license
     *
     * Date: 2016-05-20T17:23Z
     */
    
    (function( global, factory ) {
    
        if ( typeof module === "object" && typeof module.exports === "object" ) {
            // For CommonJS and CommonJS-like environments where a proper `window`
            // is present, execute the factory and get jQuery.
            // For environments that do not have a `window` with a `document`
            // (such as Node.js), expose a factory as module.exports.
            // This accentuates the need for the creation of a real `window`.
            // e.g. var jQuery = require("jquery")(window);
            // See ticket #14549 for more info.
            module.exports = global.document ?
                factory( global, true ) :
                function( w ) {
                    if ( !w.document ) {
                        throw new Error( "jQuery requires a window with a document" );
                    }
                    return factory( w );
                };
        } else {
            factory( global );
        }
    
    // Pass this if window is not defined yet
    }(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {
    
    // Support: Firefox 18+
    // Can't be in strict mode, several libs including ASP.NET trace
    // the stack via arguments.caller.callee and Firefox dies if
    // you try to trace through "use strict" call chains. (#13335)
    //"use strict";
    var arr = [];
    
    var document = window.document;
    
    var slice = arr.slice;
    
    var concat = arr.concat;
    
    var push = arr.push;
    
    var indexOf = arr.indexOf;
    
    var class2type = {};
    
    var toString = class2type.toString;
    
    var hasOwn = class2type.hasOwnProperty;
    
    var support = {};
    
    
    
    var
        version = "2.2.4",
    
        // Define a local copy of jQuery
        jQuery = function( selector, context ) {
    
            // The jQuery object is actually just the init constructor 'enhanced'
            // Need init if jQuery is called (just allow error to be thrown if not included)
            return new jQuery.fn.init( selector, context );
        },
    
        // Support: Android<4.1
        // Make sure we trim BOM and NBSP
        rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
    
        // Matches dashed string for camelizing
        rmsPrefix = /^-ms-/,
        rdashAlpha = /-([\da-z])/gi,
    
        // Used by jQuery.camelCase as callback to replace()
        fcamelCase = function( all, letter ) {
            return letter.toUpperCase();
        };
    
    jQuery.fn = jQuery.prototype = {
    
        // The current version of jQuery being used
        jquery: version,
    
        constructor: jQuery,
    
        // Start with an empty selector
        selector: "",
    
        // The default length of a jQuery object is 0
        length: 0,
    
        toArray: function() {
            return slice.call( this );
        },
    
        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function( num ) {
            return num != null ?
    
                // Return just the one element from the set
                ( num < 0 ? this[ num + this.length ] : this[ num ] ) :
    
                // Return all the elements in a clean array
                slice.call( this );
        },
    
        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function( elems ) {
    
            // Build a new jQuery matched element set
            var ret = jQuery.merge( this.constructor(), elems );
    
            // Add the old object onto the stack (as a reference)
            ret.prevObject = this;
            ret.context = this.context;
    
            // Return the newly-formed element set
            return ret;
        },
    
        // Execute a callback for every element in the matched set.
        each: function( callback ) {
            return jQuery.each( this, callback );
        },
    
        map: function( callback ) {
            return this.pushStack( jQuery.map( this, function( elem, i ) {
                return callback.call( elem, i, elem );
            } ) );
        },
    
        slice: function() {
            return this.pushStack( slice.apply( this, arguments ) );
        },
    
        first: function() {
            return this.eq( 0 );
        },
    
        last: function() {
            return this.eq( -1 );
        },
    
        eq: function( i ) {
            var len = this.length,
                j = +i + ( i < 0 ? len : 0 );
            return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
        },
    
        end: function() {
            return this.prevObject || this.constructor();
        },
    
        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };
    
    jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone,
            target = arguments[ 0 ] || {},
            i = 1,
            length = arguments.length,
            deep = false;
    
        // Handle a deep copy situation
        if ( typeof target === "boolean" ) {
            deep = target;
    
            // Skip the boolean and the target
            target = arguments[ i ] || {};
            i++;
        }
    
        // Handle case when target is a string or something (possible in deep copy)
        if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
            target = {};
        }
    
        // Extend jQuery itself if only one argument is passed
        if ( i === length ) {
            target = this;
            i--;
        }
    
        for ( ; i < length; i++ ) {
    
            // Only deal with non-null/undefined values
            if ( ( options = arguments[ i ] ) != null ) {
    
                // Extend the base object
                for ( name in options ) {
                    src = target[ name ];
                    copy = options[ name ];
    
                    // Prevent never-ending loop
                    if ( target === copy ) {
                        continue;
                    }
    
                    // Recurse if we're merging plain objects or arrays
                    if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
                        ( copyIsArray = jQuery.isArray( copy ) ) ) ) {
    
                        if ( copyIsArray ) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray( src ) ? src : [];
    
                        } else {
                            clone = src && jQuery.isPlainObject( src ) ? src : {};
                        }
    
                        // Never move original objects, clone them
                        target[ name ] = jQuery.extend( deep, clone, copy );
    
                    // Don't bring in undefined values
                    } else if ( copy !== undefined ) {
                        target[ name ] = copy;
                    }
                }
            }
        }
    
        // Return the modified object
        return target;
    };
    
    jQuery.extend( {
    
        // Unique for each copy of jQuery on the page
        expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),
    
        // Assume jQuery is ready without the ready module
        isReady: true,
    
        error: function( msg ) {
            throw new Error( msg );
        },
    
        noop: function() {},
    
        isFunction: function( obj ) {
            return jQuery.type( obj ) === "function";
        },
    
        isArray: Array.isArray,
    
        isWindow: function( obj ) {
            return obj != null && obj === obj.window;
        },
    
        isNumeric: function( obj ) {
    
            // parseFloat NaNs numeric-cast false positives (null|true|false|"")
            // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
            // subtraction forces infinities to NaN
            // adding 1 corrects loss of precision from parseFloat (#15100)
            var realStringObj = obj && obj.toString();
            return !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;
        },
    
        isPlainObject: function( obj ) {
            var key;
    
            // Not plain objects:
            // - Any object or value whose internal [[Class]] property is not "[object Object]"
            // - DOM nodes
            // - window
            if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
                return false;
            }
    
            // Not own constructor property must be Object
            if ( obj.constructor &&
                    !hasOwn.call( obj, "constructor" ) &&
                    !hasOwn.call( obj.constructor.prototype || {}, "isPrototypeOf" ) ) {
                return false;
            }
    
            // Own properties are enumerated firstly, so to speed up,
            // if last one is own, then all properties are own
            for ( key in obj ) {}
    
            return key === undefined || hasOwn.call( obj, key );
        },
    
        isEmptyObject: function( obj ) {
            var name;
            for ( name in obj ) {
                return false;
            }
            return true;
        },
    
        type: function( obj ) {
            if ( obj == null ) {
                return obj + "";
            }
    
            // Support: Android<4.0, iOS<6 (functionish RegExp)
            return typeof obj === "object" || typeof obj === "function" ?
                class2type[ toString.call( obj ) ] || "object" :
                typeof obj;
        },
    
        // Evaluates a script in a global context
        globalEval: function( code ) {
            var script,
                indirect = eval;
    
            code = jQuery.trim( code );
    
            if ( code ) {
    
                // If the code includes a valid, prologue position
                // strict mode pragma, execute code by injecting a
                // script tag into the document.
                if ( code.indexOf( "use strict" ) === 1 ) {
                    script = document.createElement( "script" );
                    script.text = code;
                    document.head.appendChild( script ).parentNode.removeChild( script );
                } else {
    
                    // Otherwise, avoid the DOM node creation, insertion
                    // and removal by using an indirect global eval
    
                    indirect( code );
                }
            }
        },
    
        // Convert dashed to camelCase; used by the css and data modules
        // Support: IE9-11+
        // Microsoft forgot to hump their vendor prefix (#9572)
        camelCase: function( string ) {
            return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
        },
    
        nodeName: function( elem, name ) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },
    
        each: function( obj, callback ) {
            var length, i = 0;
    
            if ( isArrayLike( obj ) ) {
                length = obj.length;
                for ( ; i < length; i++ ) {
                    if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
                        break;
                    }
                }
            } else {
                for ( i in obj ) {
                    if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
                        break;
                    }
                }
            }
    
            return obj;
        },
    
        // Support: Android<4.1
        trim: function( text ) {
            return text == null ?
                "" :
                ( text + "" ).replace( rtrim, "" );
        },
    
        // results is for internal usage only
        makeArray: function( arr, results ) {
            var ret = results || [];
    
            if ( arr != null ) {
                if ( isArrayLike( Object( arr ) ) ) {
                    jQuery.merge( ret,
                        typeof arr === "string" ?
                        [ arr ] : arr
                    );
                } else {
                    push.call( ret, arr );
                }
            }
    
            return ret;
        },
    
        inArray: function( elem, arr, i ) {
            return arr == null ? -1 : indexOf.call( arr, elem, i );
        },
    
        merge: function( first, second ) {
            var len = +second.length,
                j = 0,
                i = first.length;
    
            for ( ; j < len; j++ ) {
                first[ i++ ] = second[ j ];
            }
    
            first.length = i;
    
            return first;
        },
    
        grep: function( elems, callback, invert ) {
            var callbackInverse,
                matches = [],
                i = 0,
                length = elems.length,
                callbackExpect = !invert;
    
            // Go through the array, only saving the items
            // that pass the validator function
            for ( ; i < length; i++ ) {
                callbackInverse = !callback( elems[ i ], i );
                if ( callbackInverse !== callbackExpect ) {
                    matches.push( elems[ i ] );
                }
            }
    
            return matches;
        },
    
        // arg is for internal usage only
        map: function( elems, callback, arg ) {
            var length, value,
                i = 0,
                ret = [];
    
            // Go through the array, translating each of the items to their new values
            if ( isArrayLike( elems ) ) {
                length = elems.length;
                for ( ; i < length; i++ ) {
                    value = callback( elems[ i ], i, arg );
    
                    if ( value != null ) {
                        ret.push( value );
                    }
                }
    
            // Go through every key on the object,
            } else {
                for ( i in elems ) {
                    value = callback( elems[ i ], i, arg );
    
                    if ( value != null ) {
                        ret.push( value );
                    }
                }
            }
    
            // Flatten any nested arrays
            return concat.apply( [], ret );
        },
    
        // A global GUID counter for objects
        guid: 1,
    
        // Bind a function to a context, optionally partially applying any
        // arguments.
        proxy: function( fn, context ) {
            var tmp, args, proxy;
    
            if ( typeof context === "string" ) {
                tmp = fn[ context ];
                context = fn;
                fn = tmp;
            }
    
            // Quick check to determine if target is callable, in the spec
            // this throws a TypeError, but we will just return undefined.
            if ( !jQuery.isFunction( fn ) ) {
                return undefined;
            }
    
            // Simulated bind
            args = slice.call( arguments, 2 );
            proxy = function() {
                return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
            };
    
            // Set the guid of unique handler to the same of original handler, so it can be removed
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;
    
            return proxy;
        },
    
        now: Date.now,
    
        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support: support
    } );
    
    // JSHint would error on this code due to the Symbol not being defined in ES5.
    // Defining this global in .jshintrc would create a danger of using the global
    // unguarded in another place, it seems safer to just disable JSHint for these
    // three lines.
    /* jshint ignore: start */
    if ( typeof Symbol === "function" ) {
        jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
    }
    /* jshint ignore: end */
    
    // Populate the class2type map
    jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
    function( i, name ) {
        class2type[ "[object " + name + "]" ] = name.toLowerCase();
    } );
    
    function isArrayLike( obj ) {
    
        // Support: iOS 8.2 (not reproducible in simulator)
        // `in` check used to prevent JIT error (gh-2145)
        // hasOwn isn't used here due to false negatives
        // regarding Nodelist length in IE
        var length = !!obj && "length" in obj && obj.length,
            type = jQuery.type( obj );
    
        if ( type === "function" || jQuery.isWindow( obj ) ) {
            return false;
        }
    
        return type === "array" || length === 0 ||
            typeof length === "number" && length > 0 && ( length - 1 ) in obj;
    }
    var Sizzle =
    /*!
     * Sizzle CSS Selector Engine v2.2.1
     * http://sizzlejs.com/
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license
     * http://jquery.org/license
     *
     * Date: 2015-10-17
     */
    (function( window ) {
    
    var i,
        support,
        Expr,
        getText,
        isXML,
        tokenize,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,
    
        // Local document vars
        setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,
    
        // Instance-specific data
        expando = "sizzle" + 1 * new Date(),
        preferredDoc = window.document,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        sortOrder = function( a, b ) {
            if ( a === b ) {
                hasDuplicate = true;
            }
            return 0;
        },
    
        // General-purpose constants
        MAX_NEGATIVE = 1 << 31,
    
        // Instance methods
        hasOwn = ({}).hasOwnProperty,
        arr = [],
        pop = arr.pop,
        push_native = arr.push,
        push = arr.push,
        slice = arr.slice,
        // Use a stripped-down indexOf as it's faster than native
        // http://jsperf.com/thor-indexof-vs-for/5
        indexOf = function( list, elem ) {
            var i = 0,
                len = list.length;
            for ( ; i < len; i++ ) {
                if ( list[i] === elem ) {
                    return i;
                }
            }
            return -1;
        },
    
        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
    
        // Regular expressions
    
        // http://www.w3.org/TR/css3-selectors/#whitespace
        whitespace = "[\\x20\\t\\r\\n\\f]",
    
        // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
        identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
    
        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
        attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
            // Operator (capture 2)
            "*([*^$|!~]?=)" + whitespace +
            // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
            "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
            "*\\]",
    
        pseudos = ":(" + identifier + ")(?:\\((" +
            // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
            // 1. quoted (capture 3; capture 4 or capture 5)
            "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
            // 2. simple (capture 6)
            "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
            // 3. anything else (capture 2)
            ".*" +
            ")\\)|)",
    
        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
        rwhitespace = new RegExp( whitespace + "+", "g" ),
        rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),
    
        rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
        rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
    
        rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),
    
        rpseudo = new RegExp( pseudos ),
        ridentifier = new RegExp( "^" + identifier + "$" ),
    
        matchExpr = {
            "ID": new RegExp( "^#(" + identifier + ")" ),
            "CLASS": new RegExp( "^\\.(" + identifier + ")" ),
            "TAG": new RegExp( "^(" + identifier + "|[*])" ),
            "ATTR": new RegExp( "^" + attributes ),
            "PSEUDO": new RegExp( "^" + pseudos ),
            "CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
                "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
                "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
            "bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
            // For use in libraries implementing .is()
            // We use this for POS matching in `select`
            "needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
                whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
        },
    
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
    
        rnative = /^[^{]+\{\s*\[native \w/,
    
        // Easily-parseable/retrievable ID or TAG or CLASS selectors
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
    
        rsibling = /[+~]/,
        rescape = /'|\\/g,
    
        // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
        runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
        funescape = function( _, escaped, escapedWhitespace ) {
            var high = "0x" + escaped - 0x10000;
            // NaN means non-codepoint
            // Support: Firefox<24
            // Workaround erroneous numeric interpretation of +"0x"
            return high !== high || escapedWhitespace ?
                escaped :
                high < 0 ?
                    // BMP codepoint
                    String.fromCharCode( high + 0x10000 ) :
                    // Supplemental Plane codepoint (surrogate pair)
                    String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
        },
    
        // Used for iframes
        // See setDocument()
        // Removing the function wrapper causes a "Permission Denied"
        // error in IE
        unloadHandler = function() {
            setDocument();
        };
    
    // Optimize for push.apply( _, NodeList )
    try {
        push.apply(
            (arr = slice.call( preferredDoc.childNodes )),
            preferredDoc.childNodes
        );
        // Support: Android<4.0
        // Detect silently failing push.apply
        arr[ preferredDoc.childNodes.length ].nodeType;
    } catch ( e ) {
        push = { apply: arr.length ?
    
            // Leverage slice if possible
            function( target, els ) {
                push_native.apply( target, slice.call(els) );
            } :
    
            // Support: IE<9
            // Otherwise append directly
            function( target, els ) {
                var j = target.length,
                    i = 0;
                // Can't trust NodeList.length
                while ( (target[j++] = els[i++]) ) {}
                target.length = j - 1;
            }
        };
    }
    
    function Sizzle( selector, context, results, seed ) {
        var m, i, elem, nid, nidselect, match, groups, newSelector,
            newContext = context && context.ownerDocument,
    
            // nodeType defaults to 9, since context defaults to document
            nodeType = context ? context.nodeType : 9;
    
        results = results || [];
    
        // Return early from calls with invalid selector or context
        if ( typeof selector !== "string" || !selector ||
            nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {
    
            return results;
        }
    
        // Try to shortcut find operations (as opposed to filters) in HTML documents
        if ( !seed ) {
    
            if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
                setDocument( context );
            }
            context = context || document;
    
            if ( documentIsHTML ) {
    
                // If the selector is sufficiently simple, try using a "get*By*" DOM method
                // (excepting DocumentFragment context, where the methods don't exist)
                if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
    
                    // ID selector
                    if ( (m = match[1]) ) {
    
                        // Document context
                        if ( nodeType === 9 ) {
                            if ( (elem = context.getElementById( m )) ) {
    
                                // Support: IE, Opera, Webkit
                                // TODO: identify versions
                                // getElementById can match elements by name instead of ID
                                if ( elem.id === m ) {
                                    results.push( elem );
                                    return results;
                                }
                            } else {
                                return results;
                            }
    
                        // Element context
                        } else {
    
                            // Support: IE, Opera, Webkit
                            // TODO: identify versions
                            // getElementById can match elements by name instead of ID
                            if ( newContext && (elem = newContext.getElementById( m )) &&
                                contains( context, elem ) &&
                                elem.id === m ) {
    
                                results.push( elem );
                                return results;
                            }
                        }
    
                    // Type selector
                    } else if ( match[2] ) {
                        push.apply( results, context.getElementsByTagName( selector ) );
                        return results;
    
                    // Class selector
                    } else if ( (m = match[3]) && support.getElementsByClassName &&
                        context.getElementsByClassName ) {
    
                        push.apply( results, context.getElementsByClassName( m ) );
                        return results;
                    }
                }
    
                // Take advantage of querySelectorAll
                if ( support.qsa &&
                    !compilerCache[ selector + " " ] &&
                    (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
    
                    if ( nodeType !== 1 ) {
                        newContext = context;
                        newSelector = selector;
    
                    // qSA looks outside Element context, which is not what we want
                    // Thanks to Andrew Dupont for this workaround technique
                    // Support: IE <=8
                    // Exclude object elements
                    } else if ( context.nodeName.toLowerCase() !== "object" ) {
    
                        // Capture the context ID, setting it first if necessary
                        if ( (nid = context.getAttribute( "id" )) ) {
                            nid = nid.replace( rescape, "\\$&" );
                        } else {
                            context.setAttribute( "id", (nid = expando) );
                        }
    
                        // Prefix every selector in the list
                        groups = tokenize( selector );
                        i = groups.length;
                        nidselect = ridentifier.test( nid ) ? "#" + nid : "[id='" + nid + "']";
                        while ( i-- ) {
                            groups[i] = nidselect + " " + toSelector( groups[i] );
                        }
                        newSelector = groups.join( "," );
    
                        // Expand context for sibling selectors
                        newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
                            context;
                    }
    
                    if ( newSelector ) {
                        try {
                            push.apply( results,
                                newContext.querySelectorAll( newSelector )
                            );
                            return results;
                        } catch ( qsaError ) {
                        } finally {
                            if ( nid === expando ) {
                                context.removeAttribute( "id" );
                            }
                        }
                    }
                }
            }
        }
    
        // All others
        return select( selector.replace( rtrim, "$1" ), context, results, seed );
    }
    
    /**
     * Create key-value caches of limited size
     * @returns {function(string, object)} Returns the Object data after storing it on itself with
     *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
     *	deleting the oldest entry
     */
    function createCache() {
        var keys = [];
    
        function cache( key, value ) {
            // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
            if ( keys.push( key + " " ) > Expr.cacheLength ) {
                // Only keep the most recent entries
                delete cache[ keys.shift() ];
            }
            return (cache[ key + " " ] = value);
        }
        return cache;
    }
    
    /**
     * Mark a function for special use by Sizzle
     * @param {Function} fn The function to mark
     */
    function markFunction( fn ) {
        fn[ expando ] = true;
        return fn;
    }
    
    /**
     * Support testing using an element
     * @param {Function} fn Passed the created div and expects a boolean result
     */
    function assert( fn ) {
        var div = document.createElement("div");
    
        try {
            return !!fn( div );
        } catch (e) {
            return false;
        } finally {
            // Remove from its parent by default
            if ( div.parentNode ) {
                div.parentNode.removeChild( div );
            }
            // release memory in IE
            div = null;
        }
    }
    
    /**
     * Adds the same handler for all of the specified attrs
     * @param {String} attrs Pipe-separated list of attributes
     * @param {Function} handler The method that will be applied
     */
    function addHandle( attrs, handler ) {
        var arr = attrs.split("|"),
            i = arr.length;
    
        while ( i-- ) {
            Expr.attrHandle[ arr[i] ] = handler;
        }
    }
    
    /**
     * Checks document order of two siblings
     * @param {Element} a
     * @param {Element} b
     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
     */
    function siblingCheck( a, b ) {
        var cur = b && a,
            diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
                ( ~b.sourceIndex || MAX_NEGATIVE ) -
                ( ~a.sourceIndex || MAX_NEGATIVE );
    
        // Use IE sourceIndex if available on both nodes
        if ( diff ) {
            return diff;
        }
    
        // Check if b follows a
        if ( cur ) {
            while ( (cur = cur.nextSibling) ) {
                if ( cur === b ) {
                    return -1;
                }
            }
        }
    
        return a ? 1 : -1;
    }
    
    /**
     * Returns a function to use in pseudos for input types
     * @param {String} type
     */
    function createInputPseudo( type ) {
        return function( elem ) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === type;
        };
    }
    
    /**
     * Returns a function to use in pseudos for buttons
     * @param {String} type
     */
    function createButtonPseudo( type ) {
        return function( elem ) {
            var name = elem.nodeName.toLowerCase();
            return (name === "input" || name === "button") && elem.type === type;
        };
    }
    
    /**
     * Returns a function to use in pseudos for positionals
     * @param {Function} fn
     */
    function createPositionalPseudo( fn ) {
        return markFunction(function( argument ) {
            argument = +argument;
            return markFunction(function( seed, matches ) {
                var j,
                    matchIndexes = fn( [], seed.length, argument ),
                    i = matchIndexes.length;
    
                // Match elements found at the specified indexes
                while ( i-- ) {
                    if ( seed[ (j = matchIndexes[i]) ] ) {
                        seed[j] = !(matches[j] = seed[j]);
                    }
                }
            });
        });
    }
    
    /**
     * Checks a node for validity as a Sizzle context
     * @param {Element|Object=} context
     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
     */
    function testContext( context ) {
        return context && typeof context.getElementsByTagName !== "undefined" && context;
    }
    
    // Expose support vars for convenience
    support = Sizzle.support = {};
    
    /**
     * Detects XML nodes
     * @param {Element|Object} elem An element or a document
     * @returns {Boolean} True iff elem is a non-HTML XML node
     */
    isXML = Sizzle.isXML = function( elem ) {
        // documentElement is verified for cases where it doesn't yet exist
        // (such as loading iframes in IE - #4833)
        var documentElement = elem && (elem.ownerDocument || elem).documentElement;
        return documentElement ? documentElement.nodeName !== "HTML" : false;
    };
    
    /**
     * Sets document-related variables once based on the current document
     * @param {Element|Object} [doc] An element or document object to use to set the document
     * @returns {Object} Returns the current document
     */
    setDocument = Sizzle.setDocument = function( node ) {
        var hasCompare, parent,
            doc = node ? node.ownerDocument || node : preferredDoc;
    
        // Return early if doc is invalid or already selected
        if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
            return document;
        }
    
        // Update global variables
        document = doc;
        docElem = document.documentElement;
        documentIsHTML = !isXML( document );
    
        // Support: IE 9-11, Edge
        // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
        if ( (parent = document.defaultView) && parent.top !== parent ) {
            // Support: IE 11
            if ( parent.addEventListener ) {
                parent.addEventListener( "unload", unloadHandler, false );
    
            // Support: IE 9 - 10 only
            } else if ( parent.attachEvent ) {
                parent.attachEvent( "onunload", unloadHandler );
            }
        }
    
        /* Attributes
        ---------------------------------------------------------------------- */
    
        // Support: IE<8
        // Verify that getAttribute really returns attributes and not properties
        // (excepting IE8 booleans)
        support.attributes = assert(function( div ) {
            div.className = "i";
            return !div.getAttribute("className");
        });
    
        /* getElement(s)By*
        ---------------------------------------------------------------------- */
    
        // Check if getElementsByTagName("*") returns only elements
        support.getElementsByTagName = assert(function( div ) {
            div.appendChild( document.createComment("") );
            return !div.getElementsByTagName("*").length;
        });
    
        // Support: IE<9
        support.getElementsByClassName = rnative.test( document.getElementsByClassName );
    
        // Support: IE<10
        // Check if getElementById returns elements by name
        // The broken getElementById methods don't pick up programatically-set names,
        // so use a roundabout getElementsByName test
        support.getById = assert(function( div ) {
            docElem.appendChild( div ).id = expando;
            return !document.getElementsByName || !document.getElementsByName( expando ).length;
        });
    
        // ID find and filter
        if ( support.getById ) {
            Expr.find["ID"] = function( id, context ) {
                if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
                    var m = context.getElementById( id );
                    return m ? [ m ] : [];
                }
            };
            Expr.filter["ID"] = function( id ) {
                var attrId = id.replace( runescape, funescape );
                return function( elem ) {
                    return elem.getAttribute("id") === attrId;
                };
            };
        } else {
            // Support: IE6/7
            // getElementById is not reliable as a find shortcut
            delete Expr.find["ID"];
    
            Expr.filter["ID"] =  function( id ) {
                var attrId = id.replace( runescape, funescape );
                return function( elem ) {
                    var node = typeof elem.getAttributeNode !== "undefined" &&
                        elem.getAttributeNode("id");
                    return node && node.value === attrId;
                };
            };
        }
    
        // Tag
        Expr.find["TAG"] = support.getElementsByTagName ?
            function( tag, context ) {
                if ( typeof context.getElementsByTagName !== "undefined" ) {
                    return context.getElementsByTagName( tag );
    
                // DocumentFragment nodes don't have gEBTN
                } else if ( support.qsa ) {
                    return context.querySelectorAll( tag );
                }
            } :
    
            function( tag, context ) {
                var elem,
                    tmp = [],
                    i = 0,
                    // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                    results = context.getElementsByTagName( tag );
    
                // Filter out possible comments
                if ( tag === "*" ) {
                    while ( (elem = results[i++]) ) {
                        if ( elem.nodeType === 1 ) {
                            tmp.push( elem );
                        }
                    }
    
                    return tmp;
                }
                return results;
            };
    
        // Class
        Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
            if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
                return context.getElementsByClassName( className );
            }
        };
    
        /* QSA/matchesSelector
        ---------------------------------------------------------------------- */
    
        // QSA and matchesSelector support
    
        // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
        rbuggyMatches = [];
    
        // qSa(:focus) reports false when true (Chrome 21)
        // We allow this because of a bug in IE8/9 that throws an error
        // whenever `document.activeElement` is accessed on an iframe
        // So, we allow :focus to pass through QSA all the time to avoid the IE error
        // See http://bugs.jquery.com/ticket/13378
        rbuggyQSA = [];
    
        if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
            // Build QSA regex
            // Regex strategy adopted from Diego Perini
            assert(function( div ) {
                // Select is set to empty string on purpose
                // This is to test IE's treatment of not explicitly
                // setting a boolean content attribute,
                // since its presence should be enough
                // http://bugs.jquery.com/ticket/12359
                docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
                    "<select id='" + expando + "-\r\\' msallowcapture=''>" +
                    "<option selected=''></option></select>";
    
                // Support: IE8, Opera 11-12.16
                // Nothing should be selected when empty strings follow ^= or $= or *=
                // The test attribute must be unknown in Opera but "safe" for WinRT
                // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                if ( div.querySelectorAll("[msallowcapture^='']").length ) {
                    rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
                }
    
                // Support: IE8
                // Boolean attributes and "value" are not treated correctly
                if ( !div.querySelectorAll("[selected]").length ) {
                    rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
                }
    
                // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
                if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
                    rbuggyQSA.push("~=");
                }
    
                // Webkit/Opera - :checked should return selected option elements
                // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                // IE8 throws error here and will not see later tests
                if ( !div.querySelectorAll(":checked").length ) {
                    rbuggyQSA.push(":checked");
                }
    
                // Support: Safari 8+, iOS 8+
                // https://bugs.webkit.org/show_bug.cgi?id=136851
                // In-page `selector#id sibing-combinator selector` fails
                if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
                    rbuggyQSA.push(".#.+[+~]");
                }
            });
    
            assert(function( div ) {
                // Support: Windows 8 Native Apps
                // The type and name attributes are restricted during .innerHTML assignment
                var input = document.createElement("input");
                input.setAttribute( "type", "hidden" );
                div.appendChild( input ).setAttribute( "name", "D" );
    
                // Support: IE8
                // Enforce case-sensitivity of name attribute
                if ( div.querySelectorAll("[name=d]").length ) {
                    rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
                }
    
                // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                // IE8 throws error here and will not see later tests
                if ( !div.querySelectorAll(":enabled").length ) {
                    rbuggyQSA.push( ":enabled", ":disabled" );
                }
    
                // Opera 10-11 does not throw on post-comma invalid pseudos
                div.querySelectorAll("*,:x");
                rbuggyQSA.push(",.*:");
            });
        }
    
        if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
            docElem.webkitMatchesSelector ||
            docElem.mozMatchesSelector ||
            docElem.oMatchesSelector ||
            docElem.msMatchesSelector) )) ) {
    
            assert(function( div ) {
                // Check to see if it's possible to do matchesSelector
                // on a disconnected node (IE 9)
                support.disconnectedMatch = matches.call( div, "div" );
    
                // This should fail with an exception
                // Gecko does not error, returns false instead
                matches.call( div, "[s!='']:x" );
                rbuggyMatches.push( "!=", pseudos );
            });
        }
    
        rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
        rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );
    
        /* Contains
        ---------------------------------------------------------------------- */
        hasCompare = rnative.test( docElem.compareDocumentPosition );
    
        // Element contains another
        // Purposefully self-exclusive
        // As in, an element does not contain itself
        contains = hasCompare || rnative.test( docElem.contains ) ?
            function( a, b ) {
                var adown = a.nodeType === 9 ? a.documentElement : a,
                    bup = b && b.parentNode;
                return a === bup || !!( bup && bup.nodeType === 1 && (
                    adown.contains ?
                        adown.contains( bup ) :
                        a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
                ));
            } :
            function( a, b ) {
                if ( b ) {
                    while ( (b = b.parentNode) ) {
                        if ( b === a ) {
                            return true;
                        }
                    }
                }
                return false;
            };
    
        /* Sorting
        ---------------------------------------------------------------------- */
    
        // Document order sorting
        sortOrder = hasCompare ?
        function( a, b ) {
    
            // Flag for duplicate removal
            if ( a === b ) {
                hasDuplicate = true;
                return 0;
            }
    
            // Sort on method existence if only one input has compareDocumentPosition
            var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
            if ( compare ) {
                return compare;
            }
    
            // Calculate position if both inputs belong to the same document
            compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
                a.compareDocumentPosition( b ) :
    
                // Otherwise we know they are disconnected
                1;
    
            // Disconnected nodes
            if ( compare & 1 ||
                (!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {
    
                // Choose the first element that is related to our preferred document
                if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
                    return -1;
                }
                if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
                    return 1;
                }
    
                // Maintain original order
                return sortInput ?
                    ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
                    0;
            }
    
            return compare & 4 ? -1 : 1;
        } :
        function( a, b ) {
            // Exit early if the nodes are identical
            if ( a === b ) {
                hasDuplicate = true;
                return 0;
            }
    
            var cur,
                i = 0,
                aup = a.parentNode,
                bup = b.parentNode,
                ap = [ a ],
                bp = [ b ];
    
            // Parentless nodes are either documents or disconnected
            if ( !aup || !bup ) {
                return a === document ? -1 :
                    b === document ? 1 :
                    aup ? -1 :
                    bup ? 1 :
                    sortInput ?
                    ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
                    0;
    
            // If the nodes are siblings, we can do a quick check
            } else if ( aup === bup ) {
                return siblingCheck( a, b );
            }
    
            // Otherwise we need full lists of their ancestors for comparison
            cur = a;
            while ( (cur = cur.parentNode) ) {
                ap.unshift( cur );
            }
            cur = b;
            while ( (cur = cur.parentNode) ) {
                bp.unshift( cur );
            }
    
            // Walk down the tree looking for a discrepancy
            while ( ap[i] === bp[i] ) {
                i++;
            }
    
            return i ?
                // Do a sibling check if the nodes have a common ancestor
                siblingCheck( ap[i], bp[i] ) :
    
                // Otherwise nodes in our document sort first
                ap[i] === preferredDoc ? -1 :
                bp[i] === preferredDoc ? 1 :
                0;
        };
    
        return document;
    };
    
    Sizzle.matches = function( expr, elements ) {
        return Sizzle( expr, null, null, elements );
    };
    
    Sizzle.matchesSelector = function( elem, expr ) {
        // Set document vars if needed
        if ( ( elem.ownerDocument || elem ) !== document ) {
            setDocument( elem );
        }
    
        // Make sure that attribute selectors are quoted
        expr = expr.replace( rattributeQuotes, "='$1']" );
    
        if ( support.matchesSelector && documentIsHTML &&
            !compilerCache[ expr + " " ] &&
            ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
            ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {
    
            try {
                var ret = matches.call( elem, expr );
    
                // IE 9's matchesSelector returns false on disconnected nodes
                if ( ret || support.disconnectedMatch ||
                        // As well, disconnected nodes are said to be in a document
                        // fragment in IE 9
                        elem.document && elem.document.nodeType !== 11 ) {
                    return ret;
                }
            } catch (e) {}
        }
    
        return Sizzle( expr, document, null, [ elem ] ).length > 0;
    };
    
    Sizzle.contains = function( context, elem ) {
        // Set document vars if needed
        if ( ( context.ownerDocument || context ) !== document ) {
            setDocument( context );
        }
        return contains( context, elem );
    };
    
    Sizzle.attr = function( elem, name ) {
        // Set document vars if needed
        if ( ( elem.ownerDocument || elem ) !== document ) {
            setDocument( elem );
        }
    
        var fn = Expr.attrHandle[ name.toLowerCase() ],
            // Don't get fooled by Object.prototype properties (jQuery #13807)
            val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
                fn( elem, name, !documentIsHTML ) :
                undefined;
    
        return val !== undefined ?
            val :
            support.attributes || !documentIsHTML ?
                elem.getAttribute( name ) :
                (val = elem.getAttributeNode(name)) && val.specified ?
                    val.value :
                    null;
    };
    
    Sizzle.error = function( msg ) {
        throw new Error( "Syntax error, unrecognized expression: " + msg );
    };
    
    /**
     * Document sorting and removing duplicates
     * @param {ArrayLike} results
     */
    Sizzle.uniqueSort = function( results ) {
        var elem,
            duplicates = [],
            j = 0,
            i = 0;
    
        // Unless we *know* we can detect duplicates, assume their presence
        hasDuplicate = !support.detectDuplicates;
        sortInput = !support.sortStable && results.slice( 0 );
        results.sort( sortOrder );
    
        if ( hasDuplicate ) {
            while ( (elem = results[i++]) ) {
                if ( elem === results[ i ] ) {
                    j = duplicates.push( i );
                }
            }
            while ( j-- ) {
                results.splice( duplicates[ j ], 1 );
            }
        }
    
        // Clear input after sorting to release objects
        // See https://github.com/jquery/sizzle/pull/225
        sortInput = null;
    
        return results;
    };
    
    /**
     * Utility function for retrieving the text value of an array of DOM nodes
     * @param {Array|Element} elem
     */
    getText = Sizzle.getText = function( elem ) {
        var node,
            ret = "",
            i = 0,
            nodeType = elem.nodeType;
    
        if ( !nodeType ) {
            // If no nodeType, this is expected to be an array
            while ( (node = elem[i++]) ) {
                // Do not traverse comment nodes
                ret += getText( node );
            }
        } else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
            // Use textContent for elements
            // innerText usage removed for consistency of new lines (jQuery #11153)
            if ( typeof elem.textContent === "string" ) {
                return elem.textContent;
            } else {
                // Traverse its children
                for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                    ret += getText( elem );
                }
            }
        } else if ( nodeType === 3 || nodeType === 4 ) {
            return elem.nodeValue;
        }
        // Do not include comment or processing instruction nodes
    
        return ret;
    };
    
    Expr = Sizzle.selectors = {
    
        // Can be adjusted by the user
        cacheLength: 50,
    
        createPseudo: markFunction,
    
        match: matchExpr,
    
        attrHandle: {},
    
        find: {},
    
        relative: {
            ">": { dir: "parentNode", first: true },
            " ": { dir: "parentNode" },
            "+": { dir: "previousSibling", first: true },
            "~": { dir: "previousSibling" }
        },
    
        preFilter: {
            "ATTR": function( match ) {
                match[1] = match[1].replace( runescape, funescape );
    
                // Move the given value to match[3] whether quoted or unquoted
                match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );
    
                if ( match[2] === "~=" ) {
                    match[3] = " " + match[3] + " ";
                }
    
                return match.slice( 0, 4 );
            },
    
            "CHILD": function( match ) {
                /* matches from matchExpr["CHILD"]
                    1 type (only|nth|...)
                    2 what (child|of-type)
                    3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
                    4 xn-component of xn+y argument ([+-]?\d*n|)
                    5 sign of xn-component
                    6 x of xn-component
                    7 sign of y-component
                    8 y of y-component
                */
                match[1] = match[1].toLowerCase();
    
                if ( match[1].slice( 0, 3 ) === "nth" ) {
                    // nth-* requires argument
                    if ( !match[3] ) {
                        Sizzle.error( match[0] );
                    }
    
                    // numeric x and y parameters for Expr.filter.CHILD
                    // remember that false/true cast respectively to 0/1
                    match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
                    match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );
    
                // other types prohibit arguments
                } else if ( match[3] ) {
                    Sizzle.error( match[0] );
                }
    
                return match;
            },
    
            "PSEUDO": function( match ) {
                var excess,
                    unquoted = !match[6] && match[2];
    
                if ( matchExpr["CHILD"].test( match[0] ) ) {
                    return null;
                }
    
                // Accept quoted arguments as-is
                if ( match[3] ) {
                    match[2] = match[4] || match[5] || "";
    
                // Strip excess characters from unquoted arguments
                } else if ( unquoted && rpseudo.test( unquoted ) &&
                    // Get excess from tokenize (recursively)
                    (excess = tokenize( unquoted, true )) &&
                    // advance to the next closing parenthesis
                    (excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {
    
                    // excess is a negative index
                    match[0] = match[0].slice( 0, excess );
                    match[2] = unquoted.slice( 0, excess );
                }
    
                // Return only captures needed by the pseudo filter method (type and argument)
                return match.slice( 0, 3 );
            }
        },
    
        filter: {
    
            "TAG": function( nodeNameSelector ) {
                var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
                return nodeNameSelector === "*" ?
                    function() { return true; } :
                    function( elem ) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
            },
    
            "CLASS": function( className ) {
                var pattern = classCache[ className + " " ];
    
                return pattern ||
                    (pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
                    classCache( className, function( elem ) {
                        return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
                    });
            },
    
            "ATTR": function( name, operator, check ) {
                return function( elem ) {
                    var result = Sizzle.attr( elem, name );
    
                    if ( result == null ) {
                        return operator === "!=";
                    }
                    if ( !operator ) {
                        return true;
                    }
    
                    result += "";
    
                    return operator === "=" ? result === check :
                        operator === "!=" ? result !== check :
                        operator === "^=" ? check && result.indexOf( check ) === 0 :
                        operator === "*=" ? check && result.indexOf( check ) > -1 :
                        operator === "$=" ? check && result.slice( -check.length ) === check :
                        operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
                        operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
                        false;
                };
            },
    
            "CHILD": function( type, what, argument, first, last ) {
                var simple = type.slice( 0, 3 ) !== "nth",
                    forward = type.slice( -4 ) !== "last",
                    ofType = what === "of-type";
    
                return first === 1 && last === 0 ?
    
                    // Shortcut for :nth-*(n)
                    function( elem ) {
                        return !!elem.parentNode;
                    } :
    
                    function( elem, context, xml ) {
                        var cache, uniqueCache, outerCache, node, nodeIndex, start,
                            dir = simple !== forward ? "nextSibling" : "previousSibling",
                            parent = elem.parentNode,
                            name = ofType && elem.nodeName.toLowerCase(),
                            useCache = !xml && !ofType,
                            diff = false;
    
                        if ( parent ) {
    
                            // :(first|last|only)-(child|of-type)
                            if ( simple ) {
                                while ( dir ) {
                                    node = elem;
                                    while ( (node = node[ dir ]) ) {
                                        if ( ofType ?
                                            node.nodeName.toLowerCase() === name :
                                            node.nodeType === 1 ) {
    
                                            return false;
                                        }
                                    }
                                    // Reverse direction for :only-* (if we haven't yet done so)
                                    start = dir = type === "only" && !start && "nextSibling";
                                }
                                return true;
                            }
    
                            start = [ forward ? parent.firstChild : parent.lastChild ];
    
                            // non-xml :nth-child(...) stores cache data on `parent`
                            if ( forward && useCache ) {
    
                                // Seek `elem` from a previously-cached index
    
                                // ...in a gzip-friendly way
                                node = parent;
                                outerCache = node[ expando ] || (node[ expando ] = {});
    
                                // Support: IE <9 only
                                // Defend against cloned attroperties (jQuery gh-1709)
                                uniqueCache = outerCache[ node.uniqueID ] ||
                                    (outerCache[ node.uniqueID ] = {});
    
                                cache = uniqueCache[ type ] || [];
                                nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
                                diff = nodeIndex && cache[ 2 ];
                                node = nodeIndex && parent.childNodes[ nodeIndex ];
    
                                while ( (node = ++nodeIndex && node && node[ dir ] ||
    
                                    // Fallback to seeking `elem` from the start
                                    (diff = nodeIndex = 0) || start.pop()) ) {
    
                                    // When found, cache indexes on `parent` and break
                                    if ( node.nodeType === 1 && ++diff && node === elem ) {
                                        uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
                                        break;
                                    }
                                }
    
                            } else {
                                // Use previously-cached element index if available
                                if ( useCache ) {
                                    // ...in a gzip-friendly way
                                    node = elem;
                                    outerCache = node[ expando ] || (node[ expando ] = {});
    
                                    // Support: IE <9 only
                                    // Defend against cloned attroperties (jQuery gh-1709)
                                    uniqueCache = outerCache[ node.uniqueID ] ||
                                        (outerCache[ node.uniqueID ] = {});
    
                                    cache = uniqueCache[ type ] || [];
                                    nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
                                    diff = nodeIndex;
                                }
    
                                // xml :nth-child(...)
                                // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                if ( diff === false ) {
                                    // Use the same loop as above to seek `elem` from the start
                                    while ( (node = ++nodeIndex && node && node[ dir ] ||
                                        (diff = nodeIndex = 0) || start.pop()) ) {
    
                                        if ( ( ofType ?
                                            node.nodeName.toLowerCase() === name :
                                            node.nodeType === 1 ) &&
                                            ++diff ) {
    
                                            // Cache the index of each encountered element
                                            if ( useCache ) {
                                                outerCache = node[ expando ] || (node[ expando ] = {});
    
                                                // Support: IE <9 only
                                                // Defend against cloned attroperties (jQuery gh-1709)
                                                uniqueCache = outerCache[ node.uniqueID ] ||
                                                    (outerCache[ node.uniqueID ] = {});
    
                                                uniqueCache[ type ] = [ dirruns, diff ];
                                            }
    
                                            if ( node === elem ) {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
    
                            // Incorporate the offset, then check against cycle size
                            diff -= last;
                            return diff === first || ( diff % first === 0 && diff / first >= 0 );
                        }
                    };
            },
    
            "PSEUDO": function( pseudo, argument ) {
                // pseudo-class names are case-insensitive
                // http://www.w3.org/TR/selectors/#pseudo-classes
                // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                // Remember that setFilters inherits from pseudos
                var args,
                    fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
                        Sizzle.error( "unsupported pseudo: " + pseudo );
    
                // The user may use createPseudo to indicate that
                // arguments are needed to create the filter function
                // just as Sizzle does
                if ( fn[ expando ] ) {
                    return fn( argument );
                }
    
                // But maintain support for old signatures
                if ( fn.length > 1 ) {
                    args = [ pseudo, pseudo, "", argument ];
                    return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
                        markFunction(function( seed, matches ) {
                            var idx,
                                matched = fn( seed, argument ),
                                i = matched.length;
                            while ( i-- ) {
                                idx = indexOf( seed, matched[i] );
                                seed[ idx ] = !( matches[ idx ] = matched[i] );
                            }
                        }) :
                        function( elem ) {
                            return fn( elem, 0, args );
                        };
                }
    
                return fn;
            }
        },
    
        pseudos: {
            // Potentially complex pseudos
            "not": markFunction(function( selector ) {
                // Trim the selector passed to compile
                // to avoid treating leading and trailing
                // spaces as combinators
                var input = [],
                    results = [],
                    matcher = compile( selector.replace( rtrim, "$1" ) );
    
                return matcher[ expando ] ?
                    markFunction(function( seed, matches, context, xml ) {
                        var elem,
                            unmatched = matcher( seed, null, xml, [] ),
                            i = seed.length;
    
                        // Match elements unmatched by `matcher`
                        while ( i-- ) {
                            if ( (elem = unmatched[i]) ) {
                                seed[i] = !(matches[i] = elem);
                            }
                        }
                    }) :
                    function( elem, context, xml ) {
                        input[0] = elem;
                        matcher( input, null, xml, results );
                        // Don't keep the element (issue #299)
                        input[0] = null;
                        return !results.pop();
                    };
            }),
    
            "has": markFunction(function( selector ) {
                return function( elem ) {
                    return Sizzle( selector, elem ).length > 0;
                };
            }),
    
            "contains": markFunction(function( text ) {
                text = text.replace( runescape, funescape );
                return function( elem ) {
                    return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
                };
            }),
    
            // "Whether an element is represented by a :lang() selector
            // is based solely on the element's language value
            // being equal to the identifier C,
            // or beginning with the identifier C immediately followed by "-".
            // The matching of C against the element's language value is performed case-insensitively.
            // The identifier C does not have to be a valid language name."
            // http://www.w3.org/TR/selectors/#lang-pseudo
            "lang": markFunction( function( lang ) {
                // lang value must be a valid identifier
                if ( !ridentifier.test(lang || "") ) {
                    Sizzle.error( "unsupported lang: " + lang );
                }
                lang = lang.replace( runescape, funescape ).toLowerCase();
                return function( elem ) {
                    var elemLang;
                    do {
                        if ( (elemLang = documentIsHTML ?
                            elem.lang :
                            elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {
    
                            elemLang = elemLang.toLowerCase();
                            return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
                        }
                    } while ( (elem = elem.parentNode) && elem.nodeType === 1 );
                    return false;
                };
            }),
    
            // Miscellaneous
            "target": function( elem ) {
                var hash = window.location && window.location.hash;
                return hash && hash.slice( 1 ) === elem.id;
            },
    
            "root": function( elem ) {
                return elem === docElem;
            },
    
            "focus": function( elem ) {
                return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
            },
    
            // Boolean properties
            "enabled": function( elem ) {
                return elem.disabled === false;
            },
    
            "disabled": function( elem ) {
                return elem.disabled === true;
            },
    
            "checked": function( elem ) {
                // In CSS3, :checked should return both checked and selected elements
                // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                var nodeName = elem.nodeName.toLowerCase();
                return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
            },
    
            "selected": function( elem ) {
                // Accessing this property makes selected-by-default
                // options in Safari work properly
                if ( elem.parentNode ) {
                    elem.parentNode.selectedIndex;
                }
    
                return elem.selected === true;
            },
    
            // Contents
            "empty": function( elem ) {
                // http://www.w3.org/TR/selectors/#empty-pseudo
                // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                //   but not by others (comment: 8; processing instruction: 7; etc.)
                // nodeType < 6 works because attributes (2) do not appear as children
                for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                    if ( elem.nodeType < 6 ) {
                        return false;
                    }
                }
                return true;
            },
    
            "parent": function( elem ) {
                return !Expr.pseudos["empty"]( elem );
            },
    
            // Element/input types
            "header": function( elem ) {
                return rheader.test( elem.nodeName );
            },
    
            "input": function( elem ) {
                return rinputs.test( elem.nodeName );
            },
    
            "button": function( elem ) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === "button" || name === "button";
            },
    
            "text": function( elem ) {
                var attr;
                return elem.nodeName.toLowerCase() === "input" &&
                    elem.type === "text" &&
    
                    // Support: IE<8
                    // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                    ( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
            },
    
            // Position-in-collection
            "first": createPositionalPseudo(function() {
                return [ 0 ];
            }),
    
            "last": createPositionalPseudo(function( matchIndexes, length ) {
                return [ length - 1 ];
            }),
    
            "eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
                return [ argument < 0 ? argument + length : argument ];
            }),
    
            "even": createPositionalPseudo(function( matchIndexes, length ) {
                var i = 0;
                for ( ; i < length; i += 2 ) {
                    matchIndexes.push( i );
                }
                return matchIndexes;
            }),
    
            "odd": createPositionalPseudo(function( matchIndexes, length ) {
                var i = 1;
                for ( ; i < length; i += 2 ) {
                    matchIndexes.push( i );
                }
                return matchIndexes;
            }),
    
            "lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
                var i = argument < 0 ? argument + length : argument;
                for ( ; --i >= 0; ) {
                    matchIndexes.push( i );
                }
                return matchIndexes;
            }),
    
            "gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
                var i = argument < 0 ? argument + length : argument;
                for ( ; ++i < length; ) {
                    matchIndexes.push( i );
                }
                return matchIndexes;
            })
        }
    };
    
    Expr.pseudos["nth"] = Expr.pseudos["eq"];
    
    // Add button/input type pseudos
    for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
        Expr.pseudos[ i ] = createInputPseudo( i );
    }
    for ( i in { submit: true, reset: true } ) {
        Expr.pseudos[ i ] = createButtonPseudo( i );
    }
    
    // Easy API for creating new setFilters
    function setFilters() {}
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();
    
    tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
        var matched, match, tokens, type,
            soFar, groups, preFilters,
            cached = tokenCache[ selector + " " ];
    
        if ( cached ) {
            return parseOnly ? 0 : cached.slice( 0 );
        }
    
        soFar = selector;
        groups = [];
        preFilters = Expr.preFilter;
    
        while ( soFar ) {
    
            // Comma and first run
            if ( !matched || (match = rcomma.exec( soFar )) ) {
                if ( match ) {
                    // Don't consume trailing commas as valid
                    soFar = soFar.slice( match[0].length ) || soFar;
                }
                groups.push( (tokens = []) );
            }
    
            matched = false;
    
            // Combinators
            if ( (match = rcombinators.exec( soFar )) ) {
                matched = match.shift();
                tokens.push({
                    value: matched,
                    // Cast descendant combinators to space
                    type: match[0].replace( rtrim, " " )
                });
                soFar = soFar.slice( matched.length );
            }
    
            // Filters
            for ( type in Expr.filter ) {
                if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
                    (match = preFilters[ type ]( match ))) ) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        type: type,
                        matches: match
                    });
                    soFar = soFar.slice( matched.length );
                }
            }
    
            if ( !matched ) {
                break;
            }
        }
    
        // Return the length of the invalid excess
        // if we're just parsing
        // Otherwise, throw an error or return tokens
        return parseOnly ?
            soFar.length :
            soFar ?
                Sizzle.error( selector ) :
                // Cache the tokens
                tokenCache( selector, groups ).slice( 0 );
    };
    
    function toSelector( tokens ) {
        var i = 0,
            len = tokens.length,
            selector = "";
        for ( ; i < len; i++ ) {
            selector += tokens[i].value;
        }
        return selector;
    }
    
    function addCombinator( matcher, combinator, base ) {
        var dir = combinator.dir,
            checkNonElements = base && dir === "parentNode",
            doneName = done++;
    
        return combinator.first ?
            // Check against closest ancestor/preceding element
            function( elem, context, xml ) {
                while ( (elem = elem[ dir ]) ) {
                    if ( elem.nodeType === 1 || checkNonElements ) {
                        return matcher( elem, context, xml );
                    }
                }
            } :
    
            // Check against all ancestor/preceding elements
            function( elem, context, xml ) {
                var oldCache, uniqueCache, outerCache,
                    newCache = [ dirruns, doneName ];
    
                // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
                if ( xml ) {
                    while ( (elem = elem[ dir ]) ) {
                        if ( elem.nodeType === 1 || checkNonElements ) {
                            if ( matcher( elem, context, xml ) ) {
                                return true;
                            }
                        }
                    }
                } else {
                    while ( (elem = elem[ dir ]) ) {
                        if ( elem.nodeType === 1 || checkNonElements ) {
                            outerCache = elem[ expando ] || (elem[ expando ] = {});
    
                            // Support: IE <9 only
                            // Defend against cloned attroperties (jQuery gh-1709)
                            uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});
    
                            if ( (oldCache = uniqueCache[ dir ]) &&
                                oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {
    
                                // Assign to newCache so results back-propagate to previous elements
                                return (newCache[ 2 ] = oldCache[ 2 ]);
                            } else {
                                // Reuse newcache so results back-propagate to previous elements
                                uniqueCache[ dir ] = newCache;
    
                                // A match means we're done; a fail means we have to keep checking
                                if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            };
    }
    
    function elementMatcher( matchers ) {
        return matchers.length > 1 ?
            function( elem, context, xml ) {
                var i = matchers.length;
                while ( i-- ) {
                    if ( !matchers[i]( elem, context, xml ) ) {
                        return false;
                    }
                }
                return true;
            } :
            matchers[0];
    }
    
    function multipleContexts( selector, contexts, results ) {
        var i = 0,
            len = contexts.length;
        for ( ; i < len; i++ ) {
            Sizzle( selector, contexts[i], results );
        }
        return results;
    }
    
    function condense( unmatched, map, filter, context, xml ) {
        var elem,
            newUnmatched = [],
            i = 0,
            len = unmatched.length,
            mapped = map != null;
    
        for ( ; i < len; i++ ) {
            if ( (elem = unmatched[i]) ) {
                if ( !filter || filter( elem, context, xml ) ) {
                    newUnmatched.push( elem );
                    if ( mapped ) {
                        map.push( i );
                    }
                }
            }
        }
    
        return newUnmatched;
    }
    
    function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
        if ( postFilter && !postFilter[ expando ] ) {
            postFilter = setMatcher( postFilter );
        }
        if ( postFinder && !postFinder[ expando ] ) {
            postFinder = setMatcher( postFinder, postSelector );
        }
        return markFunction(function( seed, results, context, xml ) {
            var temp, i, elem,
                preMap = [],
                postMap = [],
                preexisting = results.length,
    
                // Get initial elements from seed or context
                elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),
    
                // Prefilter to get matcher input, preserving a map for seed-results synchronization
                matcherIn = preFilter && ( seed || !selector ) ?
                    condense( elems, preMap, preFilter, context, xml ) :
                    elems,
    
                matcherOut = matcher ?
                    // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                    postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
    
                        // ...intermediate processing is necessary
                        [] :
    
                        // ...otherwise use results directly
                        results :
                    matcherIn;
    
            // Find primary matches
            if ( matcher ) {
                matcher( matcherIn, matcherOut, context, xml );
            }
    
            // Apply postFilter
            if ( postFilter ) {
                temp = condense( matcherOut, postMap );
                postFilter( temp, [], context, xml );
    
                // Un-match failing elements by moving them back to matcherIn
                i = temp.length;
                while ( i-- ) {
                    if ( (elem = temp[i]) ) {
                        matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
                    }
                }
            }
    
            if ( seed ) {
                if ( postFinder || preFilter ) {
                    if ( postFinder ) {
                        // Get the final matcherOut by condensing this intermediate into postFinder contexts
                        temp = [];
                        i = matcherOut.length;
                        while ( i-- ) {
                            if ( (elem = matcherOut[i]) ) {
                                // Restore matcherIn since elem is not yet a final match
                                temp.push( (matcherIn[i] = elem) );
                            }
                        }
                        postFinder( null, (matcherOut = []), temp, xml );
                    }
    
                    // Move matched elements from seed to results to keep them synchronized
                    i = matcherOut.length;
                    while ( i-- ) {
                        if ( (elem = matcherOut[i]) &&
                            (temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {
    
                            seed[temp] = !(results[temp] = elem);
                        }
                    }
                }
    
            // Add elements to results, through postFinder if defined
            } else {
                matcherOut = condense(
                    matcherOut === results ?
                        matcherOut.splice( preexisting, matcherOut.length ) :
                        matcherOut
                );
                if ( postFinder ) {
                    postFinder( null, results, matcherOut, xml );
                } else {
                    push.apply( results, matcherOut );
                }
            }
        });
    }
    
    function matcherFromTokens( tokens ) {
        var checkContext, matcher, j,
            len = tokens.length,
            leadingRelative = Expr.relative[ tokens[0].type ],
            implicitRelative = leadingRelative || Expr.relative[" "],
            i = leadingRelative ? 1 : 0,
    
            // The foundational matcher ensures that elements are reachable from top-level context(s)
            matchContext = addCombinator( function( elem ) {
                return elem === checkContext;
            }, implicitRelative, true ),
            matchAnyContext = addCombinator( function( elem ) {
                return indexOf( checkContext, elem ) > -1;
            }, implicitRelative, true ),
            matchers = [ function( elem, context, xml ) {
                var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
                    (checkContext = context).nodeType ?
                        matchContext( elem, context, xml ) :
                        matchAnyContext( elem, context, xml ) );
                // Avoid hanging onto element (issue #299)
                checkContext = null;
                return ret;
            } ];
    
        for ( ; i < len; i++ ) {
            if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
                matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
            } else {
                matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
    
                // Return special upon seeing a positional matcher
                if ( matcher[ expando ] ) {
                    // Find the next relative operator (if any) for proper handling
                    j = ++i;
                    for ( ; j < len; j++ ) {
                        if ( Expr.relative[ tokens[j].type ] ) {
                            break;
                        }
                    }
                    return setMatcher(
                        i > 1 && elementMatcher( matchers ),
                        i > 1 && toSelector(
                            // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                            tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
                        ).replace( rtrim, "$1" ),
                        matcher,
                        i < j && matcherFromTokens( tokens.slice( i, j ) ),
                        j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
                        j < len && toSelector( tokens )
                    );
                }
                matchers.push( matcher );
            }
        }
    
        return elementMatcher( matchers );
    }
    
    function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
        var bySet = setMatchers.length > 0,
            byElement = elementMatchers.length > 0,
            superMatcher = function( seed, context, xml, results, outermost ) {
                var elem, j, matcher,
                    matchedCount = 0,
                    i = "0",
                    unmatched = seed && [],
                    setMatched = [],
                    contextBackup = outermostContext,
                    // We must always have either seed elements or outermost context
                    elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
                    // Use integer dirruns iff this is the outermost matcher
                    dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                    len = elems.length;
    
                if ( outermost ) {
                    outermostContext = context === document || context || outermost;
                }
    
                // Add elements passing elementMatchers directly to results
                // Support: IE<9, Safari
                // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
                    if ( byElement && elem ) {
                        j = 0;
                        if ( !context && elem.ownerDocument !== document ) {
                            setDocument( elem );
                            xml = !documentIsHTML;
                        }
                        while ( (matcher = elementMatchers[j++]) ) {
                            if ( matcher( elem, context || document, xml) ) {
                                results.push( elem );
                                break;
                            }
                        }
                        if ( outermost ) {
                            dirruns = dirrunsUnique;
                        }
                    }
    
                    // Track unmatched elements for set filters
                    if ( bySet ) {
                        // They will have gone through all possible matchers
                        if ( (elem = !matcher && elem) ) {
                            matchedCount--;
                        }
    
                        // Lengthen the array for every element, matched or not
                        if ( seed ) {
                            unmatched.push( elem );
                        }
                    }
                }
    
                // `i` is now the count of elements visited above, and adding it to `matchedCount`
                // makes the latter nonnegative.
                matchedCount += i;
    
                // Apply set filters to unmatched elements
                // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
                // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
                // no element matchers and no seed.
                // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
                // case, which will result in a "00" `matchedCount` that differs from `i` but is also
                // numerically zero.
                if ( bySet && i !== matchedCount ) {
                    j = 0;
                    while ( (matcher = setMatchers[j++]) ) {
                        matcher( unmatched, setMatched, context, xml );
                    }
    
                    if ( seed ) {
                        // Reintegrate element matches to eliminate the need for sorting
                        if ( matchedCount > 0 ) {
                            while ( i-- ) {
                                if ( !(unmatched[i] || setMatched[i]) ) {
                                    setMatched[i] = pop.call( results );
                                }
                            }
                        }
    
                        // Discard index placeholder values to get only actual matches
                        setMatched = condense( setMatched );
                    }
    
                    // Add matches to results
                    push.apply( results, setMatched );
    
                    // Seedless set matches succeeding multiple successful matchers stipulate sorting
                    if ( outermost && !seed && setMatched.length > 0 &&
                        ( matchedCount + setMatchers.length ) > 1 ) {
    
                        Sizzle.uniqueSort( results );
                    }
                }
    
                // Override manipulation of globals by nested matchers
                if ( outermost ) {
                    dirruns = dirrunsUnique;
                    outermostContext = contextBackup;
                }
    
                return unmatched;
            };
    
        return bySet ?
            markFunction( superMatcher ) :
            superMatcher;
    }
    
    compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
        var i,
            setMatchers = [],
            elementMatchers = [],
            cached = compilerCache[ selector + " " ];
    
        if ( !cached ) {
            // Generate a function of recursive functions that can be used to check each element
            if ( !match ) {
                match = tokenize( selector );
            }
            i = match.length;
            while ( i-- ) {
                cached = matcherFromTokens( match[i] );
                if ( cached[ expando ] ) {
                    setMatchers.push( cached );
                } else {
                    elementMatchers.push( cached );
                }
            }
    
            // Cache the compiled function
            cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
    
            // Save selector and tokenization
            cached.selector = selector;
        }
        return cached;
    };
    
    /**
     * A low-level selection function that works with Sizzle's compiled
     *  selector functions
     * @param {String|Function} selector A selector or a pre-compiled
     *  selector function built with Sizzle.compile
     * @param {Element} context
     * @param {Array} [results]
     * @param {Array} [seed] A set of elements to match against
     */
    select = Sizzle.select = function( selector, context, results, seed ) {
        var i, tokens, token, type, find,
            compiled = typeof selector === "function" && selector,
            match = !seed && tokenize( (selector = compiled.selector || selector) );
    
        results = results || [];
    
        // Try to minimize operations if there is only one selector in the list and no seed
        // (the latter of which guarantees us context)
        if ( match.length === 1 ) {
    
            // Reduce context if the leading compound selector is an ID
            tokens = match[0] = match[0].slice( 0 );
            if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
                    support.getById && context.nodeType === 9 && documentIsHTML &&
                    Expr.relative[ tokens[1].type ] ) {
    
                context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
                if ( !context ) {
                    return results;
    
                // Precompiled matchers will still verify ancestry, so step up a level
                } else if ( compiled ) {
                    context = context.parentNode;
                }
    
                selector = selector.slice( tokens.shift().value.length );
            }
    
            // Fetch a seed set for right-to-left matching
            i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
            while ( i-- ) {
                token = tokens[i];
    
                // Abort if we hit a combinator
                if ( Expr.relative[ (type = token.type) ] ) {
                    break;
                }
                if ( (find = Expr.find[ type ]) ) {
                    // Search, expanding context for leading sibling combinators
                    if ( (seed = find(
                        token.matches[0].replace( runescape, funescape ),
                        rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
                    )) ) {
    
                        // If seed is empty or no tokens remain, we can return early
                        tokens.splice( i, 1 );
                        selector = seed.length && toSelector( tokens );
                        if ( !selector ) {
                            push.apply( results, seed );
                            return results;
                        }
    
                        break;
                    }
                }
            }
        }
    
        // Compile and execute a filtering function if one is not provided
        // Provide `match` to avoid retokenization if we modified the selector above
        ( compiled || compile( selector, match ) )(
            seed,
            context,
            !documentIsHTML,
            results,
            !context || rsibling.test( selector ) && testContext( context.parentNode ) || context
        );
        return results;
    };
    
    // One-time assignments
    
    // Sort stability
    support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;
    
    // Support: Chrome 14-35+
    // Always assume duplicates if they aren't passed to the comparison function
    support.detectDuplicates = !!hasDuplicate;
    
    // Initialize against the default document
    setDocument();
    
    // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
    // Detached nodes confoundingly follow *each other*
    support.sortDetached = assert(function( div1 ) {
        // Should return 1, but returns 4 (following)
        return div1.compareDocumentPosition( document.createElement("div") ) & 1;
    });
    
    // Support: IE<8
    // Prevent attribute/property "interpolation"
    // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
    if ( !assert(function( div ) {
        div.innerHTML = "<a href='#'></a>";
        return div.firstChild.getAttribute("href") === "#" ;
    }) ) {
        addHandle( "type|href|height|width", function( elem, name, isXML ) {
            if ( !isXML ) {
                return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
            }
        });
    }
    
    // Support: IE<9
    // Use defaultValue in place of getAttribute("value")
    if ( !support.attributes || !assert(function( div ) {
        div.innerHTML = "<input/>";
        div.firstChild.setAttribute( "value", "" );
        return div.firstChild.getAttribute( "value" ) === "";
    }) ) {
        addHandle( "value", function( elem, name, isXML ) {
            if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
                return elem.defaultValue;
            }
        });
    }
    
    // Support: IE<9
    // Use getAttributeNode to fetch booleans when getAttribute lies
    if ( !assert(function( div ) {
        return div.getAttribute("disabled") == null;
    }) ) {
        addHandle( booleans, function( elem, name, isXML ) {
            var val;
            if ( !isXML ) {
                return elem[ name ] === true ? name.toLowerCase() :
                        (val = elem.getAttributeNode( name )) && val.specified ?
                        val.value :
                    null;
            }
        });
    }
    
    return Sizzle;
    
    })( window );
    
    
    
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[ ":" ] = jQuery.expr.pseudos;
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    
    
    
    var dir = function( elem, dir, until ) {
        var matched = [],
            truncate = until !== undefined;
    
        while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
            if ( elem.nodeType === 1 ) {
                if ( truncate && jQuery( elem ).is( until ) ) {
                    break;
                }
                matched.push( elem );
            }
        }
        return matched;
    };
    
    
    var siblings = function( n, elem ) {
        var matched = [];
    
        for ( ; n; n = n.nextSibling ) {
            if ( n.nodeType === 1 && n !== elem ) {
                matched.push( n );
            }
        }
    
        return matched;
    };
    
    
    var rneedsContext = jQuery.expr.match.needsContext;
    
    var rsingleTag = ( /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/ );
    
    
    
    var risSimple = /^.[^:#\[\.,]*$/;
    
    // Implement the identical functionality for filter and not
    function winnow( elements, qualifier, not ) {
        if ( jQuery.isFunction( qualifier ) ) {
            return jQuery.grep( elements, function( elem, i ) {
                /* jshint -W018 */
                return !!qualifier.call( elem, i, elem ) !== not;
            } );
    
        }
    
        if ( qualifier.nodeType ) {
            return jQuery.grep( elements, function( elem ) {
                return ( elem === qualifier ) !== not;
            } );
    
        }
    
        if ( typeof qualifier === "string" ) {
            if ( risSimple.test( qualifier ) ) {
                return jQuery.filter( qualifier, elements, not );
            }
    
            qualifier = jQuery.filter( qualifier, elements );
        }
    
        return jQuery.grep( elements, function( elem ) {
            return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
        } );
    }
    
    jQuery.filter = function( expr, elems, not ) {
        var elem = elems[ 0 ];
    
        if ( not ) {
            expr = ":not(" + expr + ")";
        }
    
        return elems.length === 1 && elem.nodeType === 1 ?
            jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
            jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
                return elem.nodeType === 1;
            } ) );
    };
    
    jQuery.fn.extend( {
        find: function( selector ) {
            var i,
                len = this.length,
                ret = [],
                self = this;
    
            if ( typeof selector !== "string" ) {
                return this.pushStack( jQuery( selector ).filter( function() {
                    for ( i = 0; i < len; i++ ) {
                        if ( jQuery.contains( self[ i ], this ) ) {
                            return true;
                        }
                    }
                } ) );
            }
    
            for ( i = 0; i < len; i++ ) {
                jQuery.find( selector, self[ i ], ret );
            }
    
            // Needed because $( selector, context ) becomes $( context ).find( selector )
            ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
            ret.selector = this.selector ? this.selector + " " + selector : selector;
            return ret;
        },
        filter: function( selector ) {
            return this.pushStack( winnow( this, selector || [], false ) );
        },
        not: function( selector ) {
            return this.pushStack( winnow( this, selector || [], true ) );
        },
        is: function( selector ) {
            return !!winnow(
                this,
    
                // If this is a positional/relative selector, check membership in the returned set
                // so $("p:first").is("p:last") won't return true for a doc with two "p".
                typeof selector === "string" && rneedsContext.test( selector ) ?
                    jQuery( selector ) :
                    selector || [],
                false
            ).length;
        }
    } );
    
    
    // Initialize a jQuery object
    
    
    // A central reference to the root jQuery(document)
    var rootjQuery,
    
        // A simple way to check for HTML strings
        // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
        // Strict HTML recognition (#11290: must start with <)
        rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
    
        init = jQuery.fn.init = function( selector, context, root ) {
            var match, elem;
    
            // HANDLE: $(""), $(null), $(undefined), $(false)
            if ( !selector ) {
                return this;
            }
    
            // Method init() accepts an alternate rootjQuery
            // so migrate can support jQuery.sub (gh-2101)
            root = root || rootjQuery;
    
            // Handle HTML strings
            if ( typeof selector === "string" ) {
                if ( selector[ 0 ] === "<" &&
                    selector[ selector.length - 1 ] === ">" &&
                    selector.length >= 3 ) {
    
                    // Assume that strings that start and end with <> are HTML and skip the regex check
                    match = [ null, selector, null ];
    
                } else {
                    match = rquickExpr.exec( selector );
                }
    
                // Match html or make sure no context is specified for #id
                if ( match && ( match[ 1 ] || !context ) ) {
    
                    // HANDLE: $(html) -> $(array)
                    if ( match[ 1 ] ) {
                        context = context instanceof jQuery ? context[ 0 ] : context;
    
                        // Option to run scripts is true for back-compat
                        // Intentionally let the error be thrown if parseHTML is not present
                        jQuery.merge( this, jQuery.parseHTML(
                            match[ 1 ],
                            context && context.nodeType ? context.ownerDocument || context : document,
                            true
                        ) );
    
                        // HANDLE: $(html, props)
                        if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
                            for ( match in context ) {
    
                                // Properties of context are called as methods if possible
                                if ( jQuery.isFunction( this[ match ] ) ) {
                                    this[ match ]( context[ match ] );
    
                                // ...and otherwise set as attributes
                                } else {
                                    this.attr( match, context[ match ] );
                                }
                            }
                        }
    
                        return this;
    
                    // HANDLE: $(#id)
                    } else {
                        elem = document.getElementById( match[ 2 ] );
    
                        // Support: Blackberry 4.6
                        // gEBID returns nodes no longer in the document (#6963)
                        if ( elem && elem.parentNode ) {
    
                            // Inject the element directly into the jQuery object
                            this.length = 1;
                            this[ 0 ] = elem;
                        }
    
                        this.context = document;
                        this.selector = selector;
                        return this;
                    }
    
                // HANDLE: $(expr, $(...))
                } else if ( !context || context.jquery ) {
                    return ( context || root ).find( selector );
    
                // HANDLE: $(expr, context)
                // (which is just equivalent to: $(context).find(expr)
                } else {
                    return this.constructor( context ).find( selector );
                }
    
            // HANDLE: $(DOMElement)
            } else if ( selector.nodeType ) {
                this.context = this[ 0 ] = selector;
                this.length = 1;
                return this;
    
            // HANDLE: $(function)
            // Shortcut for document ready
            } else if ( jQuery.isFunction( selector ) ) {
                return root.ready !== undefined ?
                    root.ready( selector ) :
    
                    // Execute immediately if ready is not present
                    selector( jQuery );
            }
    
            if ( selector.selector !== undefined ) {
                this.selector = selector.selector;
                this.context = selector.context;
            }
    
            return jQuery.makeArray( selector, this );
        };
    
    // Give the init function the jQuery prototype for later instantiation
    init.prototype = jQuery.fn;
    
    // Initialize central reference
    rootjQuery = jQuery( document );
    
    
    var rparentsprev = /^(?:parents|prev(?:Until|All))/,
    
        // Methods guaranteed to produce a unique set when starting from a unique set
        guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
        };
    
    jQuery.fn.extend( {
        has: function( target ) {
            var targets = jQuery( target, this ),
                l = targets.length;
    
            return this.filter( function() {
                var i = 0;
                for ( ; i < l; i++ ) {
                    if ( jQuery.contains( this, targets[ i ] ) ) {
                        return true;
                    }
                }
            } );
        },
    
        closest: function( selectors, context ) {
            var cur,
                i = 0,
                l = this.length,
                matched = [],
                pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
                    jQuery( selectors, context || this.context ) :
                    0;
    
            for ( ; i < l; i++ ) {
                for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {
    
                    // Always skip document fragments
                    if ( cur.nodeType < 11 && ( pos ?
                        pos.index( cur ) > -1 :
    
                        // Don't pass non-elements to Sizzle
                        cur.nodeType === 1 &&
                            jQuery.find.matchesSelector( cur, selectors ) ) ) {
    
                        matched.push( cur );
                        break;
                    }
                }
            }
    
            return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
        },
    
        // Determine the position of an element within the set
        index: function( elem ) {
    
            // No argument, return index in parent
            if ( !elem ) {
                return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
            }
    
            // Index in selector
            if ( typeof elem === "string" ) {
                return indexOf.call( jQuery( elem ), this[ 0 ] );
            }
    
            // Locate the position of the desired element
            return indexOf.call( this,
    
                // If it receives a jQuery object, the first element is used
                elem.jquery ? elem[ 0 ] : elem
            );
        },
    
        add: function( selector, context ) {
            return this.pushStack(
                jQuery.uniqueSort(
                    jQuery.merge( this.get(), jQuery( selector, context ) )
                )
            );
        },
    
        addBack: function( selector ) {
            return this.add( selector == null ?
                this.prevObject : this.prevObject.filter( selector )
            );
        }
    } );
    
    function sibling( cur, dir ) {
        while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
        return cur;
    }
    
    jQuery.each( {
        parent: function( elem ) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function( elem ) {
            return dir( elem, "parentNode" );
        },
        parentsUntil: function( elem, i, until ) {
            return dir( elem, "parentNode", until );
        },
        next: function( elem ) {
            return sibling( elem, "nextSibling" );
        },
        prev: function( elem ) {
            return sibling( elem, "previousSibling" );
        },
        nextAll: function( elem ) {
            return dir( elem, "nextSibling" );
        },
        prevAll: function( elem ) {
            return dir( elem, "previousSibling" );
        },
        nextUntil: function( elem, i, until ) {
            return dir( elem, "nextSibling", until );
        },
        prevUntil: function( elem, i, until ) {
            return dir( elem, "previousSibling", until );
        },
        siblings: function( elem ) {
            return siblings( ( elem.parentNode || {} ).firstChild, elem );
        },
        children: function( elem ) {
            return siblings( elem.firstChild );
        },
        contents: function( elem ) {
            return elem.contentDocument || jQuery.merge( [], elem.childNodes );
        }
    }, function( name, fn ) {
        jQuery.fn[ name ] = function( until, selector ) {
            var matched = jQuery.map( this, fn, until );
    
            if ( name.slice( -5 ) !== "Until" ) {
                selector = until;
            }
    
            if ( selector && typeof selector === "string" ) {
                matched = jQuery.filter( selector, matched );
            }
    
            if ( this.length > 1 ) {
    
                // Remove duplicates
                if ( !guaranteedUnique[ name ] ) {
                    jQuery.uniqueSort( matched );
                }
    
                // Reverse order for parents* and prev-derivatives
                if ( rparentsprev.test( name ) ) {
                    matched.reverse();
                }
            }
    
            return this.pushStack( matched );
        };
    } );
    var rnotwhite = ( /\S+/g );
    
    
    
    // Convert String-formatted options into Object-formatted ones
    function createOptions( options ) {
        var object = {};
        jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
            object[ flag ] = true;
        } );
        return object;
    }
    
    /*
     * Create a callback list using the following parameters:
     *
     *	options: an optional list of space-separated options that will change how
     *			the callback list behaves or a more traditional option object
     *
     * By default a callback list will act like an event callback list and can be
     * "fired" multiple times.
     *
     * Possible options:
     *
     *	once:			will ensure the callback list can only be fired once (like a Deferred)
     *
     *	memory:			will keep track of previous values and will call any callback added
     *					after the list has been fired right away with the latest "memorized"
     *					values (like a Deferred)
     *
     *	unique:			will ensure a callback can only be added once (no duplicate in the list)
     *
     *	stopOnFalse:	interrupt callings when a callback returns false
     *
     */
    jQuery.Callbacks = function( options ) {
    
        // Convert options from String-formatted to Object-formatted if needed
        // (we check in cache first)
        options = typeof options === "string" ?
            createOptions( options ) :
            jQuery.extend( {}, options );
    
        var // Flag to know if list is currently firing
            firing,
    
            // Last fire value for non-forgettable lists
            memory,
    
            // Flag to know if list was already fired
            fired,
    
            // Flag to prevent firing
            locked,
    
            // Actual callback list
            list = [],
    
            // Queue of execution data for repeatable lists
            queue = [],
    
            // Index of currently firing callback (modified by add/remove as needed)
            firingIndex = -1,
    
            // Fire callbacks
            fire = function() {
    
                // Enforce single-firing
                locked = options.once;
    
                // Execute callbacks for all pending executions,
                // respecting firingIndex overrides and runtime changes
                fired = firing = true;
                for ( ; queue.length; firingIndex = -1 ) {
                    memory = queue.shift();
                    while ( ++firingIndex < list.length ) {
    
                        // Run callback and check for early termination
                        if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
                            options.stopOnFalse ) {
    
                            // Jump to end and forget the data so .add doesn't re-fire
                            firingIndex = list.length;
                            memory = false;
                        }
                    }
                }
    
                // Forget the data if we're done with it
                if ( !options.memory ) {
                    memory = false;
                }
    
                firing = false;
    
                // Clean up if we're done firing for good
                if ( locked ) {
    
                    // Keep an empty list if we have data for future add calls
                    if ( memory ) {
                        list = [];
    
                    // Otherwise, this object is spent
                    } else {
                        list = "";
                    }
                }
            },
    
            // Actual Callbacks object
            self = {
    
                // Add a callback or a collection of callbacks to the list
                add: function() {
                    if ( list ) {
    
                        // If we have memory from a past run, we should fire after adding
                        if ( memory && !firing ) {
                            firingIndex = list.length - 1;
                            queue.push( memory );
                        }
    
                        ( function add( args ) {
                            jQuery.each( args, function( _, arg ) {
                                if ( jQuery.isFunction( arg ) ) {
                                    if ( !options.unique || !self.has( arg ) ) {
                                        list.push( arg );
                                    }
                                } else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {
    
                                    // Inspect recursively
                                    add( arg );
                                }
                            } );
                        } )( arguments );
    
                        if ( memory && !firing ) {
                            fire();
                        }
                    }
                    return this;
                },
    
                // Remove a callback from the list
                remove: function() {
                    jQuery.each( arguments, function( _, arg ) {
                        var index;
                        while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
                            list.splice( index, 1 );
    
                            // Handle firing indexes
                            if ( index <= firingIndex ) {
                                firingIndex--;
                            }
                        }
                    } );
                    return this;
                },
    
                // Check if a given callback is in the list.
                // If no argument is given, return whether or not list has callbacks attached.
                has: function( fn ) {
                    return fn ?
                        jQuery.inArray( fn, list ) > -1 :
                        list.length > 0;
                },
    
                // Remove all callbacks from the list
                empty: function() {
                    if ( list ) {
                        list = [];
                    }
                    return this;
                },
    
                // Disable .fire and .add
                // Abort any current/pending executions
                // Clear all callbacks and values
                disable: function() {
                    locked = queue = [];
                    list = memory = "";
                    return this;
                },
                disabled: function() {
                    return !list;
                },
    
                // Disable .fire
                // Also disable .add unless we have memory (since it would have no effect)
                // Abort any pending executions
                lock: function() {
                    locked = queue = [];
                    if ( !memory ) {
                        list = memory = "";
                    }
                    return this;
                },
                locked: function() {
                    return !!locked;
                },
    
                // Call all callbacks with the given context and arguments
                fireWith: function( context, args ) {
                    if ( !locked ) {
                        args = args || [];
                        args = [ context, args.slice ? args.slice() : args ];
                        queue.push( args );
                        if ( !firing ) {
                            fire();
                        }
                    }
                    return this;
                },
    
                // Call all the callbacks with the given arguments
                fire: function() {
                    self.fireWith( this, arguments );
                    return this;
                },
    
                // To know if the callbacks have already been called at least once
                fired: function() {
                    return !!fired;
                }
            };
    
        return self;
    };
    
    
    jQuery.extend( {
    
        Deferred: function( func ) {
            var tuples = [
    
                    // action, add listener, listener list, final state
                    [ "resolve", "done", jQuery.Callbacks( "once memory" ), "resolved" ],
                    [ "reject", "fail", jQuery.Callbacks( "once memory" ), "rejected" ],
                    [ "notify", "progress", jQuery.Callbacks( "memory" ) ]
                ],
                state = "pending",
                promise = {
                    state: function() {
                        return state;
                    },
                    always: function() {
                        deferred.done( arguments ).fail( arguments );
                        return this;
                    },
                    then: function( /* fnDone, fnFail, fnProgress */ ) {
                        var fns = arguments;
                        return jQuery.Deferred( function( newDefer ) {
                            jQuery.each( tuples, function( i, tuple ) {
                                var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
    
                                // deferred[ done | fail | progress ] for forwarding actions to newDefer
                                deferred[ tuple[ 1 ] ]( function() {
                                    var returned = fn && fn.apply( this, arguments );
                                    if ( returned && jQuery.isFunction( returned.promise ) ) {
                                        returned.promise()
                                            .progress( newDefer.notify )
                                            .done( newDefer.resolve )
                                            .fail( newDefer.reject );
                                    } else {
                                        newDefer[ tuple[ 0 ] + "With" ](
                                            this === promise ? newDefer.promise() : this,
                                            fn ? [ returned ] : arguments
                                        );
                                    }
                                } );
                            } );
                            fns = null;
                        } ).promise();
                    },
    
                    // Get a promise for this deferred
                    // If obj is provided, the promise aspect is added to the object
                    promise: function( obj ) {
                        return obj != null ? jQuery.extend( obj, promise ) : promise;
                    }
                },
                deferred = {};
    
            // Keep pipe for back-compat
            promise.pipe = promise.then;
    
            // Add list-specific methods
            jQuery.each( tuples, function( i, tuple ) {
                var list = tuple[ 2 ],
                    stateString = tuple[ 3 ];
    
                // promise[ done | fail | progress ] = list.add
                promise[ tuple[ 1 ] ] = list.add;
    
                // Handle state
                if ( stateString ) {
                    list.add( function() {
    
                        // state = [ resolved | rejected ]
                        state = stateString;
    
                    // [ reject_list | resolve_list ].disable; progress_list.lock
                    }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
                }
    
                // deferred[ resolve | reject | notify ]
                deferred[ tuple[ 0 ] ] = function() {
                    deferred[ tuple[ 0 ] + "With" ]( this === deferred ? promise : this, arguments );
                    return this;
                };
                deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
            } );
    
            // Make the deferred a promise
            promise.promise( deferred );
    
            // Call given func if any
            if ( func ) {
                func.call( deferred, deferred );
            }
    
            // All done!
            return deferred;
        },
    
        // Deferred helper
        when: function( subordinate /* , ..., subordinateN */ ) {
            var i = 0,
                resolveValues = slice.call( arguments ),
                length = resolveValues.length,
    
                // the count of uncompleted subordinates
                remaining = length !== 1 ||
                    ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,
    
                // the master Deferred.
                // If resolveValues consist of only a single Deferred, just use that.
                deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
    
                // Update function for both resolve and progress values
                updateFunc = function( i, contexts, values ) {
                    return function( value ) {
                        contexts[ i ] = this;
                        values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
                        if ( values === progressValues ) {
                            deferred.notifyWith( contexts, values );
                        } else if ( !( --remaining ) ) {
                            deferred.resolveWith( contexts, values );
                        }
                    };
                },
    
                progressValues, progressContexts, resolveContexts;
    
            // Add listeners to Deferred subordinates; treat others as resolved
            if ( length > 1 ) {
                progressValues = new Array( length );
                progressContexts = new Array( length );
                resolveContexts = new Array( length );
                for ( ; i < length; i++ ) {
                    if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
                        resolveValues[ i ].promise()
                            .progress( updateFunc( i, progressContexts, progressValues ) )
                            .done( updateFunc( i, resolveContexts, resolveValues ) )
                            .fail( deferred.reject );
                    } else {
                        --remaining;
                    }
                }
            }
    
            // If we're not waiting on anything, resolve the master
            if ( !remaining ) {
                deferred.resolveWith( resolveContexts, resolveValues );
            }
    
            return deferred.promise();
        }
    } );
    
    
    // The deferred used on DOM ready
    var readyList;
    
    jQuery.fn.ready = function( fn ) {
    
        // Add the callback
        jQuery.ready.promise().done( fn );
    
        return this;
    };
    
    jQuery.extend( {
    
        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,
    
        // A counter to track how many items to wait for before
        // the ready event fires. See #6781
        readyWait: 1,
    
        // Hold (or release) the ready event
        holdReady: function( hold ) {
            if ( hold ) {
                jQuery.readyWait++;
            } else {
                jQuery.ready( true );
            }
        },
    
        // Handle when the DOM is ready
        ready: function( wait ) {
    
            // Abort if there are pending holds or we're already ready
            if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
                return;
            }
    
            // Remember that the DOM is ready
            jQuery.isReady = true;
    
            // If a normal DOM Ready event fired, decrement, and wait if need be
            if ( wait !== true && --jQuery.readyWait > 0 ) {
                return;
            }
    
            // If there are functions bound, to execute
            readyList.resolveWith( document, [ jQuery ] );
    
            // Trigger any bound ready events
            if ( jQuery.fn.triggerHandler ) {
                jQuery( document ).triggerHandler( "ready" );
                jQuery( document ).off( "ready" );
            }
        }
    } );
    
    /**
     * The ready event handler and self cleanup method
     */
    function completed() {
        document.removeEventListener( "DOMContentLoaded", completed );
        window.removeEventListener( "load", completed );
        jQuery.ready();
    }
    
    jQuery.ready.promise = function( obj ) {
        if ( !readyList ) {
    
            readyList = jQuery.Deferred();
    
            // Catch cases where $(document).ready() is called
            // after the browser event has already occurred.
            // Support: IE9-10 only
            // Older IE sometimes signals "interactive" too soon
            if ( document.readyState === "complete" ||
                ( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {
    
                // Handle it asynchronously to allow scripts the opportunity to delay ready
                window.setTimeout( jQuery.ready );
    
            } else {
    
                // Use the handy event callback
                document.addEventListener( "DOMContentLoaded", completed );
    
                // A fallback to window.onload, that will always work
                window.addEventListener( "load", completed );
            }
        }
        return readyList.promise( obj );
    };
    
    // Kick off the DOM ready check even if the user does not
    jQuery.ready.promise();
    
    
    
    
    // Multifunctional method to get and set values of a collection
    // The value/s can optionally be executed if it's a function
    var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
        var i = 0,
            len = elems.length,
            bulk = key == null;
    
        // Sets many values
        if ( jQuery.type( key ) === "object" ) {
            chainable = true;
            for ( i in key ) {
                access( elems, fn, i, key[ i ], true, emptyGet, raw );
            }
    
        // Sets one value
        } else if ( value !== undefined ) {
            chainable = true;
    
            if ( !jQuery.isFunction( value ) ) {
                raw = true;
            }
    
            if ( bulk ) {
    
                // Bulk operations run against the entire set
                if ( raw ) {
                    fn.call( elems, value );
                    fn = null;
    
                // ...except when executing function values
                } else {
                    bulk = fn;
                    fn = function( elem, key, value ) {
                        return bulk.call( jQuery( elem ), value );
                    };
                }
            }
    
            if ( fn ) {
                for ( ; i < len; i++ ) {
                    fn(
                        elems[ i ], key, raw ?
                        value :
                        value.call( elems[ i ], i, fn( elems[ i ], key ) )
                    );
                }
            }
        }
    
        return chainable ?
            elems :
    
            // Gets
            bulk ?
                fn.call( elems ) :
                len ? fn( elems[ 0 ], key ) : emptyGet;
    };
    var acceptData = function( owner ) {
    
        // Accepts only:
        //  - Node
        //    - Node.ELEMENT_NODE
        //    - Node.DOCUMENT_NODE
        //  - Object
        //    - Any
        /* jshint -W018 */
        return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
    };
    
    
    
    
    function Data() {
        this.expando = jQuery.expando + Data.uid++;
    }
    
    Data.uid = 1;
    
    Data.prototype = {
    
        register: function( owner, initial ) {
            var value = initial || {};
    
            // If it is a node unlikely to be stringify-ed or looped over
            // use plain assignment
            if ( owner.nodeType ) {
                owner[ this.expando ] = value;
    
            // Otherwise secure it in a non-enumerable, non-writable property
            // configurability must be true to allow the property to be
            // deleted with the delete operator
            } else {
                Object.defineProperty( owner, this.expando, {
                    value: value,
                    writable: true,
                    configurable: true
                } );
            }
            return owner[ this.expando ];
        },
        cache: function( owner ) {
    
            // We can accept data for non-element nodes in modern browsers,
            // but we should not, see #8335.
            // Always return an empty object.
            if ( !acceptData( owner ) ) {
                return {};
            }
    
            // Check if the owner object already has a cache
            var value = owner[ this.expando ];
    
            // If not, create one
            if ( !value ) {
                value = {};
    
                // We can accept data for non-element nodes in modern browsers,
                // but we should not, see #8335.
                // Always return an empty object.
                if ( acceptData( owner ) ) {
    
                    // If it is a node unlikely to be stringify-ed or looped over
                    // use plain assignment
                    if ( owner.nodeType ) {
                        owner[ this.expando ] = value;
    
                    // Otherwise secure it in a non-enumerable property
                    // configurable must be true to allow the property to be
                    // deleted when data is removed
                    } else {
                        Object.defineProperty( owner, this.expando, {
                            value: value,
                            configurable: true
                        } );
                    }
                }
            }
    
            return value;
        },
        set: function( owner, data, value ) {
            var prop,
                cache = this.cache( owner );
    
            // Handle: [ owner, key, value ] args
            if ( typeof data === "string" ) {
                cache[ data ] = value;
    
            // Handle: [ owner, { properties } ] args
            } else {
    
                // Copy the properties one-by-one to the cache object
                for ( prop in data ) {
                    cache[ prop ] = data[ prop ];
                }
            }
            return cache;
        },
        get: function( owner, key ) {
            return key === undefined ?
                this.cache( owner ) :
                owner[ this.expando ] && owner[ this.expando ][ key ];
        },
        access: function( owner, key, value ) {
            var stored;
    
            // In cases where either:
            //
            //   1. No key was specified
            //   2. A string key was specified, but no value provided
            //
            // Take the "read" path and allow the get method to determine
            // which value to return, respectively either:
            //
            //   1. The entire cache object
            //   2. The data stored at the key
            //
            if ( key === undefined ||
                    ( ( key && typeof key === "string" ) && value === undefined ) ) {
    
                stored = this.get( owner, key );
    
                return stored !== undefined ?
                    stored : this.get( owner, jQuery.camelCase( key ) );
            }
    
            // When the key is not a string, or both a key and value
            // are specified, set or extend (existing objects) with either:
            //
            //   1. An object of properties
            //   2. A key and value
            //
            this.set( owner, key, value );
    
            // Since the "set" path can have two possible entry points
            // return the expected data based on which path was taken[*]
            return value !== undefined ? value : key;
        },
        remove: function( owner, key ) {
            var i, name, camel,
                cache = owner[ this.expando ];
    
            if ( cache === undefined ) {
                return;
            }
    
            if ( key === undefined ) {
                this.register( owner );
    
            } else {
    
                // Support array or space separated string of keys
                if ( jQuery.isArray( key ) ) {
    
                    // If "name" is an array of keys...
                    // When data is initially created, via ("key", "val") signature,
                    // keys will be converted to camelCase.
                    // Since there is no way to tell _how_ a key was added, remove
                    // both plain key and camelCase key. #12786
                    // This will only penalize the array argument path.
                    name = key.concat( key.map( jQuery.camelCase ) );
                } else {
                    camel = jQuery.camelCase( key );
    
                    // Try the string as a key before any manipulation
                    if ( key in cache ) {
                        name = [ key, camel ];
                    } else {
    
                        // If a key with the spaces exists, use it.
                        // Otherwise, create an array by matching non-whitespace
                        name = camel;
                        name = name in cache ?
                            [ name ] : ( name.match( rnotwhite ) || [] );
                    }
                }
    
                i = name.length;
    
                while ( i-- ) {
                    delete cache[ name[ i ] ];
                }
            }
    
            // Remove the expando if there's no more data
            if ( key === undefined || jQuery.isEmptyObject( cache ) ) {
    
                // Support: Chrome <= 35-45+
                // Webkit & Blink performance suffers when deleting properties
                // from DOM nodes, so set to undefined instead
                // https://code.google.com/p/chromium/issues/detail?id=378607
                if ( owner.nodeType ) {
                    owner[ this.expando ] = undefined;
                } else {
                    delete owner[ this.expando ];
                }
            }
        },
        hasData: function( owner ) {
            var cache = owner[ this.expando ];
            return cache !== undefined && !jQuery.isEmptyObject( cache );
        }
    };
    var dataPriv = new Data();
    
    var dataUser = new Data();
    
    
    
    //	Implementation Summary
    //
    //	1. Enforce API surface and semantic compatibility with 1.9.x branch
    //	2. Improve the module's maintainability by reducing the storage
    //		paths to a single mechanism.
    //	3. Use the same single mechanism to support "private" and "user" data.
    //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
    //	5. Avoid exposing implementation details on user objects (eg. expando properties)
    //	6. Provide a clear path for implementation upgrade to WeakMap in 2014
    
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        rmultiDash = /[A-Z]/g;
    
    function dataAttr( elem, key, data ) {
        var name;
    
        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if ( data === undefined && elem.nodeType === 1 ) {
            name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
            data = elem.getAttribute( name );
    
            if ( typeof data === "string" ) {
                try {
                    data = data === "true" ? true :
                        data === "false" ? false :
                        data === "null" ? null :
    
                        // Only convert to a number if it doesn't change the string
                        +data + "" === data ? +data :
                        rbrace.test( data ) ? jQuery.parseJSON( data ) :
                        data;
                } catch ( e ) {}
    
                // Make sure we set the data so it isn't changed later
                dataUser.set( elem, key, data );
            } else {
                data = undefined;
            }
        }
        return data;
    }
    
    jQuery.extend( {
        hasData: function( elem ) {
            return dataUser.hasData( elem ) || dataPriv.hasData( elem );
        },
    
        data: function( elem, name, data ) {
            return dataUser.access( elem, name, data );
        },
    
        removeData: function( elem, name ) {
            dataUser.remove( elem, name );
        },
    
        // TODO: Now that all calls to _data and _removeData have been replaced
        // with direct calls to dataPriv methods, these can be deprecated.
        _data: function( elem, name, data ) {
            return dataPriv.access( elem, name, data );
        },
    
        _removeData: function( elem, name ) {
            dataPriv.remove( elem, name );
        }
    } );
    
    jQuery.fn.extend( {
        data: function( key, value ) {
            var i, name, data,
                elem = this[ 0 ],
                attrs = elem && elem.attributes;
    
            // Gets all values
            if ( key === undefined ) {
                if ( this.length ) {
                    data = dataUser.get( elem );
    
                    if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
                        i = attrs.length;
                        while ( i-- ) {
    
                            // Support: IE11+
                            // The attrs elements can be null (#14894)
                            if ( attrs[ i ] ) {
                                name = attrs[ i ].name;
                                if ( name.indexOf( "data-" ) === 0 ) {
                                    name = jQuery.camelCase( name.slice( 5 ) );
                                    dataAttr( elem, name, data[ name ] );
                                }
                            }
                        }
                        dataPriv.set( elem, "hasDataAttrs", true );
                    }
                }
    
                return data;
            }
    
            // Sets multiple values
            if ( typeof key === "object" ) {
                return this.each( function() {
                    dataUser.set( this, key );
                } );
            }
    
            return access( this, function( value ) {
                var data, camelKey;
    
                // The calling jQuery object (element matches) is not empty
                // (and therefore has an element appears at this[ 0 ]) and the
                // `value` parameter was not undefined. An empty jQuery object
                // will result in `undefined` for elem = this[ 0 ] which will
                // throw an exception if an attempt to read a data cache is made.
                if ( elem && value === undefined ) {
    
                    // Attempt to get data from the cache
                    // with the key as-is
                    data = dataUser.get( elem, key ) ||
    
                        // Try to find dashed key if it exists (gh-2779)
                        // This is for 2.2.x only
                        dataUser.get( elem, key.replace( rmultiDash, "-$&" ).toLowerCase() );
    
                    if ( data !== undefined ) {
                        return data;
                    }
    
                    camelKey = jQuery.camelCase( key );
    
                    // Attempt to get data from the cache
                    // with the key camelized
                    data = dataUser.get( elem, camelKey );
                    if ( data !== undefined ) {
                        return data;
                    }
    
                    // Attempt to "discover" the data in
                    // HTML5 custom data-* attrs
                    data = dataAttr( elem, camelKey, undefined );
                    if ( data !== undefined ) {
                        return data;
                    }
    
                    // We tried really hard, but the data doesn't exist.
                    return;
                }
    
                // Set the data...
                camelKey = jQuery.camelCase( key );
                this.each( function() {
    
                    // First, attempt to store a copy or reference of any
                    // data that might've been store with a camelCased key.
                    var data = dataUser.get( this, camelKey );
    
                    // For HTML5 data-* attribute interop, we have to
                    // store property names with dashes in a camelCase form.
                    // This might not apply to all properties...*
                    dataUser.set( this, camelKey, value );
    
                    // *... In the case of properties that might _actually_
                    // have dashes, we need to also store a copy of that
                    // unchanged property.
                    if ( key.indexOf( "-" ) > -1 && data !== undefined ) {
                        dataUser.set( this, key, value );
                    }
                } );
            }, null, value, arguments.length > 1, null, true );
        },
    
        removeData: function( key ) {
            return this.each( function() {
                dataUser.remove( this, key );
            } );
        }
    } );
    
    
    jQuery.extend( {
        queue: function( elem, type, data ) {
            var queue;
    
            if ( elem ) {
                type = ( type || "fx" ) + "queue";
                queue = dataPriv.get( elem, type );
    
                // Speed up dequeue by getting out quickly if this is just a lookup
                if ( data ) {
                    if ( !queue || jQuery.isArray( data ) ) {
                        queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
                    } else {
                        queue.push( data );
                    }
                }
                return queue || [];
            }
        },
    
        dequeue: function( elem, type ) {
            type = type || "fx";
    
            var queue = jQuery.queue( elem, type ),
                startLength = queue.length,
                fn = queue.shift(),
                hooks = jQuery._queueHooks( elem, type ),
                next = function() {
                    jQuery.dequeue( elem, type );
                };
    
            // If the fx queue is dequeued, always remove the progress sentinel
            if ( fn === "inprogress" ) {
                fn = queue.shift();
                startLength--;
            }
    
            if ( fn ) {
    
                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if ( type === "fx" ) {
                    queue.unshift( "inprogress" );
                }
    
                // Clear up the last queue stop function
                delete hooks.stop;
                fn.call( elem, next, hooks );
            }
    
            if ( !startLength && hooks ) {
                hooks.empty.fire();
            }
        },
    
        // Not public - generate a queueHooks object, or return the current one
        _queueHooks: function( elem, type ) {
            var key = type + "queueHooks";
            return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
                empty: jQuery.Callbacks( "once memory" ).add( function() {
                    dataPriv.remove( elem, [ type + "queue", key ] );
                } )
            } );
        }
    } );
    
    jQuery.fn.extend( {
        queue: function( type, data ) {
            var setter = 2;
    
            if ( typeof type !== "string" ) {
                data = type;
                type = "fx";
                setter--;
            }
    
            if ( arguments.length < setter ) {
                return jQuery.queue( this[ 0 ], type );
            }
    
            return data === undefined ?
                this :
                this.each( function() {
                    var queue = jQuery.queue( this, type, data );
    
                    // Ensure a hooks for this queue
                    jQuery._queueHooks( this, type );
    
                    if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
                        jQuery.dequeue( this, type );
                    }
                } );
        },
        dequeue: function( type ) {
            return this.each( function() {
                jQuery.dequeue( this, type );
            } );
        },
        clearQueue: function( type ) {
            return this.queue( type || "fx", [] );
        },
    
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function( type, obj ) {
            var tmp,
                count = 1,
                defer = jQuery.Deferred(),
                elements = this,
                i = this.length,
                resolve = function() {
                    if ( !( --count ) ) {
                        defer.resolveWith( elements, [ elements ] );
                    }
                };
    
            if ( typeof type !== "string" ) {
                obj = type;
                type = undefined;
            }
            type = type || "fx";
    
            while ( i-- ) {
                tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
                if ( tmp && tmp.empty ) {
                    count++;
                    tmp.empty.add( resolve );
                }
            }
            resolve();
            return defer.promise( obj );
        }
    } );
    var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;
    
    var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );
    
    
    var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
    
    var isHidden = function( elem, el ) {
    
            // isHidden might be called from jQuery#filter function;
            // in that case, element will be second argument
            elem = el || elem;
            return jQuery.css( elem, "display" ) === "none" ||
                !jQuery.contains( elem.ownerDocument, elem );
        };
    
    
    
    function adjustCSS( elem, prop, valueParts, tween ) {
        var adjusted,
            scale = 1,
            maxIterations = 20,
            currentValue = tween ?
                function() { return tween.cur(); } :
                function() { return jQuery.css( elem, prop, "" ); },
            initial = currentValue(),
            unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),
    
            // Starting value computation is required for potential unit mismatches
            initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
                rcssNum.exec( jQuery.css( elem, prop ) );
    
        if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {
    
            // Trust units reported by jQuery.css
            unit = unit || initialInUnit[ 3 ];
    
            // Make sure we update the tween properties later on
            valueParts = valueParts || [];
    
            // Iteratively approximate from a nonzero starting point
            initialInUnit = +initial || 1;
    
            do {
    
                // If previous iteration zeroed out, double until we get *something*.
                // Use string for doubling so we don't accidentally see scale as unchanged below
                scale = scale || ".5";
    
                // Adjust and apply
                initialInUnit = initialInUnit / scale;
                jQuery.style( elem, prop, initialInUnit + unit );
    
            // Update scale, tolerating zero or NaN from tween.cur()
            // Break the loop if scale is unchanged or perfect, or if we've just had enough.
            } while (
                scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
            );
        }
    
        if ( valueParts ) {
            initialInUnit = +initialInUnit || +initial || 0;
    
            // Apply relative offset (+=/-=) if specified
            adjusted = valueParts[ 1 ] ?
                initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
                +valueParts[ 2 ];
            if ( tween ) {
                tween.unit = unit;
                tween.start = initialInUnit;
                tween.end = adjusted;
            }
        }
        return adjusted;
    }
    var rcheckableType = ( /^(?:checkbox|radio)$/i );
    
    var rtagName = ( /<([\w:-]+)/ );
    
    var rscriptType = ( /^$|\/(?:java|ecma)script/i );
    
    
    
    // We have to close these tags to support XHTML (#13200)
    var wrapMap = {
    
        // Support: IE9
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
    
        // XHTML parsers do not magically insert elements in the
        // same way that tag soup parsers do. So we cannot shorten
        // this by omitting <tbody> or other required elements.
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
    
        _default: [ 0, "", "" ]
    };
    
    // Support: IE9
    wrapMap.optgroup = wrapMap.option;
    
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    
    
    function getAll( context, tag ) {
    
        // Support: IE9-11+
        // Use typeof to avoid zero-argument method invocation on host objects (#15151)
        var ret = typeof context.getElementsByTagName !== "undefined" ?
                context.getElementsByTagName( tag || "*" ) :
                typeof context.querySelectorAll !== "undefined" ?
                    context.querySelectorAll( tag || "*" ) :
                [];
    
        return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
            jQuery.merge( [ context ], ret ) :
            ret;
    }
    
    
    // Mark scripts as having already been evaluated
    function setGlobalEval( elems, refElements ) {
        var i = 0,
            l = elems.length;
    
        for ( ; i < l; i++ ) {
            dataPriv.set(
                elems[ i ],
                "globalEval",
                !refElements || dataPriv.get( refElements[ i ], "globalEval" )
            );
        }
    }
    
    
    var rhtml = /<|&#?\w+;/;
    
    function buildFragment( elems, context, scripts, selection, ignored ) {
        var elem, tmp, tag, wrap, contains, j,
            fragment = context.createDocumentFragment(),
            nodes = [],
            i = 0,
            l = elems.length;
    
        for ( ; i < l; i++ ) {
            elem = elems[ i ];
    
            if ( elem || elem === 0 ) {
    
                // Add nodes directly
                if ( jQuery.type( elem ) === "object" ) {
    
                    // Support: Android<4.1, PhantomJS<2
                    // push.apply(_, arraylike) throws on ancient WebKit
                    jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
    
                // Convert non-html into a text node
                } else if ( !rhtml.test( elem ) ) {
                    nodes.push( context.createTextNode( elem ) );
    
                // Convert html into DOM nodes
                } else {
                    tmp = tmp || fragment.appendChild( context.createElement( "div" ) );
    
                    // Deserialize a standard representation
                    tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
                    wrap = wrapMap[ tag ] || wrapMap._default;
                    tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];
    
                    // Descend through wrappers to the right content
                    j = wrap[ 0 ];
                    while ( j-- ) {
                        tmp = tmp.lastChild;
                    }
    
                    // Support: Android<4.1, PhantomJS<2
                    // push.apply(_, arraylike) throws on ancient WebKit
                    jQuery.merge( nodes, tmp.childNodes );
    
                    // Remember the top-level container
                    tmp = fragment.firstChild;
    
                    // Ensure the created nodes are orphaned (#12392)
                    tmp.textContent = "";
                }
            }
        }
    
        // Remove wrapper from fragment
        fragment.textContent = "";
    
        i = 0;
        while ( ( elem = nodes[ i++ ] ) ) {
    
            // Skip elements already in the context collection (trac-4087)
            if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
                if ( ignored ) {
                    ignored.push( elem );
                }
                continue;
            }
    
            contains = jQuery.contains( elem.ownerDocument, elem );
    
            // Append to fragment
            tmp = getAll( fragment.appendChild( elem ), "script" );
    
            // Preserve script evaluation history
            if ( contains ) {
                setGlobalEval( tmp );
            }
    
            // Capture executables
            if ( scripts ) {
                j = 0;
                while ( ( elem = tmp[ j++ ] ) ) {
                    if ( rscriptType.test( elem.type || "" ) ) {
                        scripts.push( elem );
                    }
                }
            }
        }
    
        return fragment;
    }
    
    
    ( function() {
        var fragment = document.createDocumentFragment(),
            div = fragment.appendChild( document.createElement( "div" ) ),
            input = document.createElement( "input" );
    
        // Support: Android 4.0-4.3, Safari<=5.1
        // Check state lost if the name is set (#11217)
        // Support: Windows Web Apps (WWA)
        // `name` and `type` must use .setAttribute for WWA (#14901)
        input.setAttribute( "type", "radio" );
        input.setAttribute( "checked", "checked" );
        input.setAttribute( "name", "t" );
    
        div.appendChild( input );
    
        // Support: Safari<=5.1, Android<4.2
        // Older WebKit doesn't clone checked state correctly in fragments
        support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;
    
        // Support: IE<=11+
        // Make sure textarea (and checkbox) defaultValue is properly cloned
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
    } )();
    
    
    var
        rkeyEvent = /^key/,
        rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
        rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
    
    function returnTrue() {
        return true;
    }
    
    function returnFalse() {
        return false;
    }
    
    // Support: IE9
    // See #13393 for more info
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch ( err ) { }
    }
    
    function on( elem, types, selector, data, fn, one ) {
        var origFn, type;
    
        // Types can be a map of types/handlers
        if ( typeof types === "object" ) {
    
            // ( types-Object, selector, data )
            if ( typeof selector !== "string" ) {
    
                // ( types-Object, data )
                data = data || selector;
                selector = undefined;
            }
            for ( type in types ) {
                on( elem, type, selector, data, types[ type ], one );
            }
            return elem;
        }
    
        if ( data == null && fn == null ) {
    
            // ( types, fn )
            fn = selector;
            data = selector = undefined;
        } else if ( fn == null ) {
            if ( typeof selector === "string" ) {
    
                // ( types, selector, fn )
                fn = data;
                data = undefined;
            } else {
    
                // ( types, data, fn )
                fn = data;
                data = selector;
                selector = undefined;
            }
        }
        if ( fn === false ) {
            fn = returnFalse;
        } else if ( !fn ) {
            return elem;
        }
    
        if ( one === 1 ) {
            origFn = fn;
            fn = function( event ) {
    
                // Can use an empty set, since event contains the info
                jQuery().off( event );
                return origFn.apply( this, arguments );
            };
    
            // Use same guid so caller can remove using origFn
            fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
        }
        return elem.each( function() {
            jQuery.event.add( this, types, fn, data, selector );
        } );
    }
    
    /*
     * Helper functions for managing events -- not part of the public interface.
     * Props to Dean Edwards' addEvent library for many of the ideas.
     */
    jQuery.event = {
    
        global: {},
    
        add: function( elem, types, handler, data, selector ) {
    
            var handleObjIn, eventHandle, tmp,
                events, t, handleObj,
                special, handlers, type, namespaces, origType,
                elemData = dataPriv.get( elem );
    
            // Don't attach events to noData or text/comment nodes (but allow plain objects)
            if ( !elemData ) {
                return;
            }
    
            // Caller can pass in an object of custom data in lieu of the handler
            if ( handler.handler ) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }
    
            // Make sure that the handler has a unique ID, used to find/remove it later
            if ( !handler.guid ) {
                handler.guid = jQuery.guid++;
            }
    
            // Init the element's event structure and main handler, if this is the first
            if ( !( events = elemData.events ) ) {
                events = elemData.events = {};
            }
            if ( !( eventHandle = elemData.handle ) ) {
                eventHandle = elemData.handle = function( e ) {
    
                    // Discard the second event of a jQuery.event.trigger() and
                    // when an event is called after a page has unloaded
                    return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
                        jQuery.event.dispatch.apply( elem, arguments ) : undefined;
                };
            }
    
            // Handle multiple events separated by a space
            types = ( types || "" ).match( rnotwhite ) || [ "" ];
            t = types.length;
            while ( t-- ) {
                tmp = rtypenamespace.exec( types[ t ] ) || [];
                type = origType = tmp[ 1 ];
                namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
    
                // There *must* be a type, no attaching namespace-only handlers
                if ( !type ) {
                    continue;
                }
    
                // If event changes its type, use the special event handlers for the changed type
                special = jQuery.event.special[ type ] || {};
    
                // If selector defined, determine special event api type, otherwise given type
                type = ( selector ? special.delegateType : special.bindType ) || type;
    
                // Update special based on newly reset type
                special = jQuery.event.special[ type ] || {};
    
                // handleObj is passed to all event handlers
                handleObj = jQuery.extend( {
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
                    namespace: namespaces.join( "." )
                }, handleObjIn );
    
                // Init the event handler queue if we're the first
                if ( !( handlers = events[ type ] ) ) {
                    handlers = events[ type ] = [];
                    handlers.delegateCount = 0;
    
                    // Only use addEventListener if the special events handler returns false
                    if ( !special.setup ||
                        special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
    
                        if ( elem.addEventListener ) {
                            elem.addEventListener( type, eventHandle );
                        }
                    }
                }
    
                if ( special.add ) {
                    special.add.call( elem, handleObj );
    
                    if ( !handleObj.handler.guid ) {
                        handleObj.handler.guid = handler.guid;
                    }
                }
    
                // Add to the element's handler list, delegates in front
                if ( selector ) {
                    handlers.splice( handlers.delegateCount++, 0, handleObj );
                } else {
                    handlers.push( handleObj );
                }
    
                // Keep track of which events have ever been used, for event optimization
                jQuery.event.global[ type ] = true;
            }
    
        },
    
        // Detach an event or set of events from an element
        remove: function( elem, types, handler, selector, mappedTypes ) {
    
            var j, origCount, tmp,
                events, t, handleObj,
                special, handlers, type, namespaces, origType,
                elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );
    
            if ( !elemData || !( events = elemData.events ) ) {
                return;
            }
    
            // Once for each type.namespace in types; type may be omitted
            types = ( types || "" ).match( rnotwhite ) || [ "" ];
            t = types.length;
            while ( t-- ) {
                tmp = rtypenamespace.exec( types[ t ] ) || [];
                type = origType = tmp[ 1 ];
                namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
    
                // Unbind all events (on this namespace, if provided) for the element
                if ( !type ) {
                    for ( type in events ) {
                        jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
                    }
                    continue;
                }
    
                special = jQuery.event.special[ type ] || {};
                type = ( selector ? special.delegateType : special.bindType ) || type;
                handlers = events[ type ] || [];
                tmp = tmp[ 2 ] &&
                    new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );
    
                // Remove matching events
                origCount = j = handlers.length;
                while ( j-- ) {
                    handleObj = handlers[ j ];
    
                    if ( ( mappedTypes || origType === handleObj.origType ) &&
                        ( !handler || handler.guid === handleObj.guid ) &&
                        ( !tmp || tmp.test( handleObj.namespace ) ) &&
                        ( !selector || selector === handleObj.selector ||
                            selector === "**" && handleObj.selector ) ) {
                        handlers.splice( j, 1 );
    
                        if ( handleObj.selector ) {
                            handlers.delegateCount--;
                        }
                        if ( special.remove ) {
                            special.remove.call( elem, handleObj );
                        }
                    }
                }
    
                // Remove generic event handler if we removed something and no more handlers exist
                // (avoids potential for endless recursion during removal of special event handlers)
                if ( origCount && !handlers.length ) {
                    if ( !special.teardown ||
                        special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
    
                        jQuery.removeEvent( elem, type, elemData.handle );
                    }
    
                    delete events[ type ];
                }
            }
    
            // Remove data and the expando if it's no longer used
            if ( jQuery.isEmptyObject( events ) ) {
                dataPriv.remove( elem, "handle events" );
            }
        },
    
        dispatch: function( event ) {
    
            // Make a writable jQuery.Event from the native event object
            event = jQuery.event.fix( event );
    
            var i, j, ret, matched, handleObj,
                handlerQueue = [],
                args = slice.call( arguments ),
                handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
                special = jQuery.event.special[ event.type ] || {};
    
            // Use the fix-ed jQuery.Event rather than the (read-only) native event
            args[ 0 ] = event;
            event.delegateTarget = this;
    
            // Call the preDispatch hook for the mapped type, and let it bail if desired
            if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
                return;
            }
    
            // Determine handlers
            handlerQueue = jQuery.event.handlers.call( this, event, handlers );
    
            // Run delegates first; they may want to stop propagation beneath us
            i = 0;
            while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
                event.currentTarget = matched.elem;
    
                j = 0;
                while ( ( handleObj = matched.handlers[ j++ ] ) &&
                    !event.isImmediatePropagationStopped() ) {
    
                    // Triggered event must either 1) have no namespace, or 2) have namespace(s)
                    // a subset or equal to those in the bound event (both can have no namespace).
                    if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {
    
                        event.handleObj = handleObj;
                        event.data = handleObj.data;
    
                        ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
                            handleObj.handler ).apply( matched.elem, args );
    
                        if ( ret !== undefined ) {
                            if ( ( event.result = ret ) === false ) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }
    
            // Call the postDispatch hook for the mapped type
            if ( special.postDispatch ) {
                special.postDispatch.call( this, event );
            }
    
            return event.result;
        },
    
        handlers: function( event, handlers ) {
            var i, matches, sel, handleObj,
                handlerQueue = [],
                delegateCount = handlers.delegateCount,
                cur = event.target;
    
            // Support (at least): Chrome, IE9
            // Find delegate handlers
            // Black-hole SVG <use> instance trees (#13180)
            //
            // Support: Firefox<=42+
            // Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
            if ( delegateCount && cur.nodeType &&
                ( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {
    
                for ( ; cur !== this; cur = cur.parentNode || this ) {
    
                    // Don't check non-elements (#13208)
                    // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                    if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
                        matches = [];
                        for ( i = 0; i < delegateCount; i++ ) {
                            handleObj = handlers[ i ];
    
                            // Don't conflict with Object.prototype properties (#13203)
                            sel = handleObj.selector + " ";
    
                            if ( matches[ sel ] === undefined ) {
                                matches[ sel ] = handleObj.needsContext ?
                                    jQuery( sel, this ).index( cur ) > -1 :
                                    jQuery.find( sel, this, null, [ cur ] ).length;
                            }
                            if ( matches[ sel ] ) {
                                matches.push( handleObj );
                            }
                        }
                        if ( matches.length ) {
                            handlerQueue.push( { elem: cur, handlers: matches } );
                        }
                    }
                }
            }
    
            // Add the remaining (directly-bound) handlers
            if ( delegateCount < handlers.length ) {
                handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
            }
    
            return handlerQueue;
        },
    
        // Includes some event props shared by KeyEvent and MouseEvent
        props: ( "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
            "metaKey relatedTarget shiftKey target timeStamp view which" ).split( " " ),
    
        fixHooks: {},
    
        keyHooks: {
            props: "char charCode key keyCode".split( " " ),
            filter: function( event, original ) {
    
                // Add which for key events
                if ( event.which == null ) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                }
    
                return event;
            }
        },
    
        mouseHooks: {
            props: ( "button buttons clientX clientY offsetX offsetY pageX pageY " +
                "screenX screenY toElement" ).split( " " ),
            filter: function( event, original ) {
                var eventDoc, doc, body,
                    button = original.button;
    
                // Calculate pageX/Y if missing and clientX/Y available
                if ( event.pageX == null && original.clientX != null ) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;
    
                    event.pageX = original.clientX +
                        ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -
                        ( doc && doc.clientLeft || body && body.clientLeft || 0 );
                    event.pageY = original.clientY +
                        ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -
                        ( doc && doc.clientTop  || body && body.clientTop  || 0 );
                }
    
                // Add which for click: 1 === left; 2 === middle; 3 === right
                // Note: button is not normalized, so don't use it
                if ( !event.which && button !== undefined ) {
                    event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
                }
    
                return event;
            }
        },
    
        fix: function( event ) {
            if ( event[ jQuery.expando ] ) {
                return event;
            }
    
            // Create a writable copy of the event object and normalize some properties
            var i, prop, copy,
                type = event.type,
                originalEvent = event,
                fixHook = this.fixHooks[ type ];
    
            if ( !fixHook ) {
                this.fixHooks[ type ] = fixHook =
                    rmouseEvent.test( type ) ? this.mouseHooks :
                    rkeyEvent.test( type ) ? this.keyHooks :
                    {};
            }
            copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;
    
            event = new jQuery.Event( originalEvent );
    
            i = copy.length;
            while ( i-- ) {
                prop = copy[ i ];
                event[ prop ] = originalEvent[ prop ];
            }
    
            // Support: Cordova 2.5 (WebKit) (#13255)
            // All events should have a target; Cordova deviceready doesn't
            if ( !event.target ) {
                event.target = document;
            }
    
            // Support: Safari 6.0+, Chrome<28
            // Target should not be a text node (#504, #13143)
            if ( event.target.nodeType === 3 ) {
                event.target = event.target.parentNode;
            }
    
            return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
        },
    
        special: {
            load: {
    
                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
            },
            focus: {
    
                // Fire native event if possible so blur/focus sequence is correct
                trigger: function() {
                    if ( this !== safeActiveElement() && this.focus ) {
                        this.focus();
                        return false;
                    }
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    if ( this === safeActiveElement() && this.blur ) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: "focusout"
            },
            click: {
    
                // For checkbox, fire native event so checked state will be right
                trigger: function() {
                    if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
                        this.click();
                        return false;
                    }
                },
    
                // For cross-browser consistency, don't fire native .click() on links
                _default: function( event ) {
                    return jQuery.nodeName( event.target, "a" );
                }
            },
    
            beforeunload: {
                postDispatch: function( event ) {
    
                    // Support: Firefox 20+
                    // Firefox doesn't alert if the returnValue field is not set.
                    if ( event.result !== undefined && event.originalEvent ) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        }
    };
    
    jQuery.removeEvent = function( elem, type, handle ) {
    
        // This "if" is needed for plain objects
        if ( elem.removeEventListener ) {
            elem.removeEventListener( type, handle );
        }
    };
    
    jQuery.Event = function( src, props ) {
    
        // Allow instantiation without the 'new' keyword
        if ( !( this instanceof jQuery.Event ) ) {
            return new jQuery.Event( src, props );
        }
    
        // Event object
        if ( src && src.type ) {
            this.originalEvent = src;
            this.type = src.type;
    
            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = src.defaultPrevented ||
                    src.defaultPrevented === undefined &&
    
                    // Support: Android<4.0
                    src.returnValue === false ?
                returnTrue :
                returnFalse;
    
        // Event type
        } else {
            this.type = src;
        }
    
        // Put explicitly provided properties onto the event object
        if ( props ) {
            jQuery.extend( this, props );
        }
    
        // Create a timestamp if incoming event doesn't have one
        this.timeStamp = src && src.timeStamp || jQuery.now();
    
        // Mark it as fixed
        this[ jQuery.expando ] = true;
    };
    
    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,
    
        preventDefault: function() {
            var e = this.originalEvent;
    
            this.isDefaultPrevented = returnTrue;
    
            if ( e && !this.isSimulated ) {
                e.preventDefault();
            }
        },
        stopPropagation: function() {
            var e = this.originalEvent;
    
            this.isPropagationStopped = returnTrue;
    
            if ( e && !this.isSimulated ) {
                e.stopPropagation();
            }
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;
    
            this.isImmediatePropagationStopped = returnTrue;
    
            if ( e && !this.isSimulated ) {
                e.stopImmediatePropagation();
            }
    
            this.stopPropagation();
        }
    };
    
    // Create mouseenter/leave events using mouseover/out and event-time checks
    // so that event delegation works in jQuery.
    // Do the same for pointerenter/pointerleave and pointerover/pointerout
    //
    // Support: Safari 7 only
    // Safari sends mouseenter too often; see:
    // https://code.google.com/p/chromium/issues/detail?id=470258
    // for the description of the bug (it existed in older Chrome versions as well).
    jQuery.each( {
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function( orig, fix ) {
        jQuery.event.special[ orig ] = {
            delegateType: fix,
            bindType: fix,
    
            handle: function( event ) {
                var ret,
                    target = this,
                    related = event.relatedTarget,
                    handleObj = event.handleObj;
    
                // For mouseenter/leave call the handler if related is outside the target.
                // NB: No relatedTarget if the mouse left/entered the browser window
                if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply( this, arguments );
                    event.type = fix;
                }
                return ret;
            }
        };
    } );
    
    jQuery.fn.extend( {
        on: function( types, selector, data, fn ) {
            return on( this, types, selector, data, fn );
        },
        one: function( types, selector, data, fn ) {
            return on( this, types, selector, data, fn, 1 );
        },
        off: function( types, selector, fn ) {
            var handleObj, type;
            if ( types && types.preventDefault && types.handleObj ) {
    
                // ( event )  dispatched jQuery.Event
                handleObj = types.handleObj;
                jQuery( types.delegateTarget ).off(
                    handleObj.namespace ?
                        handleObj.origType + "." + handleObj.namespace :
                        handleObj.origType,
                    handleObj.selector,
                    handleObj.handler
                );
                return this;
            }
            if ( typeof types === "object" ) {
    
                // ( types-object [, selector] )
                for ( type in types ) {
                    this.off( type, selector, types[ type ] );
                }
                return this;
            }
            if ( selector === false || typeof selector === "function" ) {
    
                // ( types [, fn] )
                fn = selector;
                selector = undefined;
            }
            if ( fn === false ) {
                fn = returnFalse;
            }
            return this.each( function() {
                jQuery.event.remove( this, types, fn, selector );
            } );
        }
    } );
    
    
    var
        rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,
    
        // Support: IE 10-11, Edge 10240+
        // In IE/Edge using regex groups here causes severe slowdowns.
        // See https://connect.microsoft.com/IE/feedback/details/1736512/
        rnoInnerhtml = /<script|<style|<link/i,
    
        // checked="checked" or checked
        rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
        rscriptTypeMasked = /^true\/(.*)/,
        rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
    
    // Manipulating tables requires a tbody
    function manipulationTarget( elem, content ) {
        return jQuery.nodeName( elem, "table" ) &&
            jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?
    
            elem.getElementsByTagName( "tbody" )[ 0 ] ||
                elem.appendChild( elem.ownerDocument.createElement( "tbody" ) ) :
            elem;
    }
    
    // Replace/restore the type attribute of script elements for safe DOM manipulation
    function disableScript( elem ) {
        elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
        return elem;
    }
    function restoreScript( elem ) {
        var match = rscriptTypeMasked.exec( elem.type );
    
        if ( match ) {
            elem.type = match[ 1 ];
        } else {
            elem.removeAttribute( "type" );
        }
    
        return elem;
    }
    
    function cloneCopyEvent( src, dest ) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
    
        if ( dest.nodeType !== 1 ) {
            return;
        }
    
        // 1. Copy private data: events, handlers, etc.
        if ( dataPriv.hasData( src ) ) {
            pdataOld = dataPriv.access( src );
            pdataCur = dataPriv.set( dest, pdataOld );
            events = pdataOld.events;
    
            if ( events ) {
                delete pdataCur.handle;
                pdataCur.events = {};
    
                for ( type in events ) {
                    for ( i = 0, l = events[ type ].length; i < l; i++ ) {
                        jQuery.event.add( dest, type, events[ type ][ i ] );
                    }
                }
            }
        }
    
        // 2. Copy user data
        if ( dataUser.hasData( src ) ) {
            udataOld = dataUser.access( src );
            udataCur = jQuery.extend( {}, udataOld );
    
            dataUser.set( dest, udataCur );
        }
    }
    
    // Fix IE bugs, see support tests
    function fixInput( src, dest ) {
        var nodeName = dest.nodeName.toLowerCase();
    
        // Fails to persist the checked state of a cloned checkbox or radio button.
        if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
            dest.checked = src.checked;
    
        // Fails to return the selected option to the default selected state when cloning options
        } else if ( nodeName === "input" || nodeName === "textarea" ) {
            dest.defaultValue = src.defaultValue;
        }
    }
    
    function domManip( collection, args, callback, ignored ) {
    
        // Flatten any nested arrays
        args = concat.apply( [], args );
    
        var fragment, first, scripts, hasScripts, node, doc,
            i = 0,
            l = collection.length,
            iNoClone = l - 1,
            value = args[ 0 ],
            isFunction = jQuery.isFunction( value );
    
        // We can't cloneNode fragments that contain checked, in WebKit
        if ( isFunction ||
                ( l > 1 && typeof value === "string" &&
                    !support.checkClone && rchecked.test( value ) ) ) {
            return collection.each( function( index ) {
                var self = collection.eq( index );
                if ( isFunction ) {
                    args[ 0 ] = value.call( this, index, self.html() );
                }
                domManip( self, args, callback, ignored );
            } );
        }
    
        if ( l ) {
            fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
            first = fragment.firstChild;
    
            if ( fragment.childNodes.length === 1 ) {
                fragment = first;
            }
    
            // Require either new content or an interest in ignored elements to invoke the callback
            if ( first || ignored ) {
                scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
                hasScripts = scripts.length;
    
                // Use the original fragment for the last item
                // instead of the first because it can end up
                // being emptied incorrectly in certain situations (#8070).
                for ( ; i < l; i++ ) {
                    node = fragment;
    
                    if ( i !== iNoClone ) {
                        node = jQuery.clone( node, true, true );
    
                        // Keep references to cloned scripts for later restoration
                        if ( hasScripts ) {
    
                            // Support: Android<4.1, PhantomJS<2
                            // push.apply(_, arraylike) throws on ancient WebKit
                            jQuery.merge( scripts, getAll( node, "script" ) );
                        }
                    }
    
                    callback.call( collection[ i ], node, i );
                }
    
                if ( hasScripts ) {
                    doc = scripts[ scripts.length - 1 ].ownerDocument;
    
                    // Reenable scripts
                    jQuery.map( scripts, restoreScript );
    
                    // Evaluate executable scripts on first document insertion
                    for ( i = 0; i < hasScripts; i++ ) {
                        node = scripts[ i ];
                        if ( rscriptType.test( node.type || "" ) &&
                            !dataPriv.access( node, "globalEval" ) &&
                            jQuery.contains( doc, node ) ) {
    
                            if ( node.src ) {
    
                                // Optional AJAX dependency, but won't run scripts if not present
                                if ( jQuery._evalUrl ) {
                                    jQuery._evalUrl( node.src );
                                }
                            } else {
                                jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
                            }
                        }
                    }
                }
            }
        }
    
        return collection;
    }
    
    function remove( elem, selector, keepData ) {
        var node,
            nodes = selector ? jQuery.filter( selector, elem ) : elem,
            i = 0;
    
        for ( ; ( node = nodes[ i ] ) != null; i++ ) {
            if ( !keepData && node.nodeType === 1 ) {
                jQuery.cleanData( getAll( node ) );
            }
    
            if ( node.parentNode ) {
                if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
                    setGlobalEval( getAll( node, "script" ) );
                }
                node.parentNode.removeChild( node );
            }
        }
    
        return elem;
    }
    
    jQuery.extend( {
        htmlPrefilter: function( html ) {
            return html.replace( rxhtmlTag, "<$1></$2>" );
        },
    
        clone: function( elem, dataAndEvents, deepDataAndEvents ) {
            var i, l, srcElements, destElements,
                clone = elem.cloneNode( true ),
                inPage = jQuery.contains( elem.ownerDocument, elem );
    
            // Fix IE cloning issues
            if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
                    !jQuery.isXMLDoc( elem ) ) {
    
                // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
                destElements = getAll( clone );
                srcElements = getAll( elem );
    
                for ( i = 0, l = srcElements.length; i < l; i++ ) {
                    fixInput( srcElements[ i ], destElements[ i ] );
                }
            }
    
            // Copy the events from the original to the clone
            if ( dataAndEvents ) {
                if ( deepDataAndEvents ) {
                    srcElements = srcElements || getAll( elem );
                    destElements = destElements || getAll( clone );
    
                    for ( i = 0, l = srcElements.length; i < l; i++ ) {
                        cloneCopyEvent( srcElements[ i ], destElements[ i ] );
                    }
                } else {
                    cloneCopyEvent( elem, clone );
                }
            }
    
            // Preserve script evaluation history
            destElements = getAll( clone, "script" );
            if ( destElements.length > 0 ) {
                setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
            }
    
            // Return the cloned set
            return clone;
        },
    
        cleanData: function( elems ) {
            var data, elem, type,
                special = jQuery.event.special,
                i = 0;
    
            for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
                if ( acceptData( elem ) ) {
                    if ( ( data = elem[ dataPriv.expando ] ) ) {
                        if ( data.events ) {
                            for ( type in data.events ) {
                                if ( special[ type ] ) {
                                    jQuery.event.remove( elem, type );
    
                                // This is a shortcut to avoid jQuery.event.remove's overhead
                                } else {
                                    jQuery.removeEvent( elem, type, data.handle );
                                }
                            }
                        }
    
                        // Support: Chrome <= 35-45+
                        // Assign undefined instead of using delete, see Data#remove
                        elem[ dataPriv.expando ] = undefined;
                    }
                    if ( elem[ dataUser.expando ] ) {
    
                        // Support: Chrome <= 35-45+
                        // Assign undefined instead of using delete, see Data#remove
                        elem[ dataUser.expando ] = undefined;
                    }
                }
            }
        }
    } );
    
    jQuery.fn.extend( {
    
        // Keep domManip exposed until 3.0 (gh-2225)
        domManip: domManip,
    
        detach: function( selector ) {
            return remove( this, selector, true );
        },
    
        remove: function( selector ) {
            return remove( this, selector );
        },
    
        text: function( value ) {
            return access( this, function( value ) {
                return value === undefined ?
                    jQuery.text( this ) :
                    this.empty().each( function() {
                        if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                            this.textContent = value;
                        }
                    } );
            }, null, value, arguments.length );
        },
    
        append: function() {
            return domManip( this, arguments, function( elem ) {
                if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                    var target = manipulationTarget( this, elem );
                    target.appendChild( elem );
                }
            } );
        },
    
        prepend: function() {
            return domManip( this, arguments, function( elem ) {
                if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                    var target = manipulationTarget( this, elem );
                    target.insertBefore( elem, target.firstChild );
                }
            } );
        },
    
        before: function() {
            return domManip( this, arguments, function( elem ) {
                if ( this.parentNode ) {
                    this.parentNode.insertBefore( elem, this );
                }
            } );
        },
    
        after: function() {
            return domManip( this, arguments, function( elem ) {
                if ( this.parentNode ) {
                    this.parentNode.insertBefore( elem, this.nextSibling );
                }
            } );
        },
    
        empty: function() {
            var elem,
                i = 0;
    
            for ( ; ( elem = this[ i ] ) != null; i++ ) {
                if ( elem.nodeType === 1 ) {
    
                    // Prevent memory leaks
                    jQuery.cleanData( getAll( elem, false ) );
    
                    // Remove any remaining nodes
                    elem.textContent = "";
                }
            }
    
            return this;
        },
    
        clone: function( dataAndEvents, deepDataAndEvents ) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
    
            return this.map( function() {
                return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
            } );
        },
    
        html: function( value ) {
            return access( this, function( value ) {
                var elem = this[ 0 ] || {},
                    i = 0,
                    l = this.length;
    
                if ( value === undefined && elem.nodeType === 1 ) {
                    return elem.innerHTML;
                }
    
                // See if we can take a shortcut and just use innerHTML
                if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
                    !wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {
    
                    value = jQuery.htmlPrefilter( value );
    
                    try {
                        for ( ; i < l; i++ ) {
                            elem = this[ i ] || {};
    
                            // Remove element nodes and prevent memory leaks
                            if ( elem.nodeType === 1 ) {
                                jQuery.cleanData( getAll( elem, false ) );
                                elem.innerHTML = value;
                            }
                        }
    
                        elem = 0;
    
                    // If using innerHTML throws an exception, use the fallback method
                    } catch ( e ) {}
                }
    
                if ( elem ) {
                    this.empty().append( value );
                }
            }, null, value, arguments.length );
        },
    
        replaceWith: function() {
            var ignored = [];
    
            // Make the changes, replacing each non-ignored context element with the new content
            return domManip( this, arguments, function( elem ) {
                var parent = this.parentNode;
    
                if ( jQuery.inArray( this, ignored ) < 0 ) {
                    jQuery.cleanData( getAll( this ) );
                    if ( parent ) {
                        parent.replaceChild( elem, this );
                    }
                }
    
            // Force callback invocation
            }, ignored );
        }
    } );
    
    jQuery.each( {
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function( name, original ) {
        jQuery.fn[ name ] = function( selector ) {
            var elems,
                ret = [],
                insert = jQuery( selector ),
                last = insert.length - 1,
                i = 0;
    
            for ( ; i <= last; i++ ) {
                elems = i === last ? this : this.clone( true );
                jQuery( insert[ i ] )[ original ]( elems );
    
                // Support: QtWebKit
                // .get() because push.apply(_, arraylike) throws
                push.apply( ret, elems.get() );
            }
    
            return this.pushStack( ret );
        };
    } );
    
    
    var iframe,
        elemdisplay = {
    
            // Support: Firefox
            // We have to pre-define these values for FF (#10227)
            HTML: "block",
            BODY: "block"
        };
    
    /**
     * Retrieve the actual display of a element
     * @param {String} name nodeName of the element
     * @param {Object} doc Document object
     */
    
    // Called only from within defaultDisplay
    function actualDisplay( name, doc ) {
        var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),
    
            display = jQuery.css( elem[ 0 ], "display" );
    
        // We don't have any data stored on the element,
        // so use "detach" method as fast way to get rid of the element
        elem.detach();
    
        return display;
    }
    
    /**
     * Try to determine the default display value of an element
     * @param {String} nodeName
     */
    function defaultDisplay( nodeName ) {
        var doc = document,
            display = elemdisplay[ nodeName ];
    
        if ( !display ) {
            display = actualDisplay( nodeName, doc );
    
            // If the simple way fails, read from inside an iframe
            if ( display === "none" || !display ) {
    
                // Use the already-created iframe if possible
                iframe = ( iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" ) )
                    .appendTo( doc.documentElement );
    
                // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
                doc = iframe[ 0 ].contentDocument;
    
                // Support: IE
                doc.write();
                doc.close();
    
                display = actualDisplay( nodeName, doc );
                iframe.detach();
            }
    
            // Store the correct default display
            elemdisplay[ nodeName ] = display;
        }
    
        return display;
    }
    var rmargin = ( /^margin/ );
    
    var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );
    
    var getStyles = function( elem ) {
    
            // Support: IE<=11+, Firefox<=30+ (#15098, #14150)
            // IE throws on elements created in popups
            // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
            var view = elem.ownerDocument.defaultView;
    
            if ( !view || !view.opener ) {
                view = window;
            }
    
            return view.getComputedStyle( elem );
        };
    
    var swap = function( elem, options, callback, args ) {
        var ret, name,
            old = {};
    
        // Remember the old values, and insert the new ones
        for ( name in options ) {
            old[ name ] = elem.style[ name ];
            elem.style[ name ] = options[ name ];
        }
    
        ret = callback.apply( elem, args || [] );
    
        // Revert the old values
        for ( name in options ) {
            elem.style[ name ] = old[ name ];
        }
    
        return ret;
    };
    
    
    var documentElement = document.documentElement;
    
    
    
    ( function() {
        var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
            container = document.createElement( "div" ),
            div = document.createElement( "div" );
    
        // Finish early in limited (non-browser) environments
        if ( !div.style ) {
            return;
        }
    
        // Support: IE9-11+
        // Style of cloned element affects source element cloned (#8908)
        div.style.backgroundClip = "content-box";
        div.cloneNode( true ).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";
    
        container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
            "padding:0;margin-top:1px;position:absolute";
        container.appendChild( div );
    
        // Executing both pixelPosition & boxSizingReliable tests require only one layout
        // so they're executed at the same time to save the second computation.
        function computeStyleTests() {
            div.style.cssText =
    
                // Support: Firefox<29, Android 2.3
                // Vendor-prefix box-sizing
                "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +
                "position:relative;display:block;" +
                "margin:auto;border:1px;padding:1px;" +
                "top:1%;width:50%";
            div.innerHTML = "";
            documentElement.appendChild( container );
    
            var divStyle = window.getComputedStyle( div );
            pixelPositionVal = divStyle.top !== "1%";
            reliableMarginLeftVal = divStyle.marginLeft === "2px";
            boxSizingReliableVal = divStyle.width === "4px";
    
            // Support: Android 4.0 - 4.3 only
            // Some styles come back with percentage values, even though they shouldn't
            div.style.marginRight = "50%";
            pixelMarginRightVal = divStyle.marginRight === "4px";
    
            documentElement.removeChild( container );
        }
    
        jQuery.extend( support, {
            pixelPosition: function() {
    
                // This test is executed only once but we still do memoizing
                // since we can use the boxSizingReliable pre-computing.
                // No need to check if the test was already performed, though.
                computeStyleTests();
                return pixelPositionVal;
            },
            boxSizingReliable: function() {
                if ( boxSizingReliableVal == null ) {
                    computeStyleTests();
                }
                return boxSizingReliableVal;
            },
            pixelMarginRight: function() {
    
                // Support: Android 4.0-4.3
                // We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
                // since that compresses better and they're computed together anyway.
                if ( boxSizingReliableVal == null ) {
                    computeStyleTests();
                }
                return pixelMarginRightVal;
            },
            reliableMarginLeft: function() {
    
                // Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
                if ( boxSizingReliableVal == null ) {
                    computeStyleTests();
                }
                return reliableMarginLeftVal;
            },
            reliableMarginRight: function() {
    
                // Support: Android 2.3
                // Check if div with explicit width and no margin-right incorrectly
                // gets computed margin-right based on width of container. (#3333)
                // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                // This support function is only executed once so no memoizing is needed.
                var ret,
                    marginDiv = div.appendChild( document.createElement( "div" ) );
    
                // Reset CSS: box-sizing; display; margin; border; padding
                marginDiv.style.cssText = div.style.cssText =
    
                    // Support: Android 2.3
                    // Vendor-prefix box-sizing
                    "-webkit-box-sizing:content-box;box-sizing:content-box;" +
                    "display:block;margin:0;border:0;padding:0";
                marginDiv.style.marginRight = marginDiv.style.width = "0";
                div.style.width = "1px";
                documentElement.appendChild( container );
    
                ret = !parseFloat( window.getComputedStyle( marginDiv ).marginRight );
    
                documentElement.removeChild( container );
                div.removeChild( marginDiv );
    
                return ret;
            }
        } );
    } )();
    
    
    function curCSS( elem, name, computed ) {
        var width, minWidth, maxWidth, ret,
            style = elem.style;
    
        computed = computed || getStyles( elem );
        ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;
    
        // Support: Opera 12.1x only
        // Fall back to style even without computed
        // computed is undefined for elems on document fragments
        if ( ( ret === "" || ret === undefined ) && !jQuery.contains( elem.ownerDocument, elem ) ) {
            ret = jQuery.style( elem, name );
        }
    
        // Support: IE9
        // getPropertyValue is only needed for .css('filter') (#12537)
        if ( computed ) {
    
            // A tribute to the "awesome hack by Dean Edwards"
            // Android Browser returns percentage for some values,
            // but width seems to be reliably pixels.
            // This is against the CSSOM draft spec:
            // http://dev.w3.org/csswg/cssom/#resolved-values
            if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {
    
                // Remember the original values
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;
    
                // Put in the new values to get a computed value out
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;
    
                // Revert the changed values
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }
    
        return ret !== undefined ?
    
            // Support: IE9-11+
            // IE returns zIndex value as an integer.
            ret + "" :
            ret;
    }
    
    
    function addGetHookIf( conditionFn, hookFn ) {
    
        // Define the hook, we'll check on the first run if it's really needed.
        return {
            get: function() {
                if ( conditionFn() ) {
    
                    // Hook not needed (or it's not possible to use it due
                    // to missing dependency), remove it.
                    delete this.get;
                    return;
                }
    
                // Hook needed; redefine it so that the support test is not executed again.
                return ( this.get = hookFn ).apply( this, arguments );
            }
        };
    }
    
    
    var
    
        // Swappable if display is none or starts with table
        // except "table", "table-cell", or "table-caption"
        // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
        rdisplayswap = /^(none|table(?!-c[ea]).+)/,
    
        cssShow = { position: "absolute", visibility: "hidden", display: "block" },
        cssNormalTransform = {
            letterSpacing: "0",
            fontWeight: "400"
        },
    
        cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],
        emptyStyle = document.createElement( "div" ).style;
    
    // Return a css property mapped to a potentially vendor prefixed property
    function vendorPropName( name ) {
    
        // Shortcut for names that are not vendor prefixed
        if ( name in emptyStyle ) {
            return name;
        }
    
        // Check for vendor prefixed names
        var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
            i = cssPrefixes.length;
    
        while ( i-- ) {
            name = cssPrefixes[ i ] + capName;
            if ( name in emptyStyle ) {
                return name;
            }
        }
    }
    
    function setPositiveNumber( elem, value, subtract ) {
    
        // Any relative (+/-) values have already been
        // normalized at this point
        var matches = rcssNum.exec( value );
        return matches ?
    
            // Guard against undefined "subtract", e.g., when used as in cssHooks
            Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
            value;
    }
    
    function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
        var i = extra === ( isBorderBox ? "border" : "content" ) ?
    
            // If we already have the right measurement, avoid augmentation
            4 :
    
            // Otherwise initialize for horizontal or vertical properties
            name === "width" ? 1 : 0,
    
            val = 0;
    
        for ( ; i < 4; i += 2 ) {
    
            // Both box models exclude margin, so add it if we want it
            if ( extra === "margin" ) {
                val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
            }
    
            if ( isBorderBox ) {
    
                // border-box includes padding, so remove it if we want content
                if ( extra === "content" ) {
                    val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
                }
    
                // At this point, extra isn't border nor margin, so remove border
                if ( extra !== "margin" ) {
                    val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
                }
            } else {
    
                // At this point, extra isn't content, so add padding
                val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
    
                // At this point, extra isn't content nor padding, so add border
                if ( extra !== "padding" ) {
                    val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
                }
            }
        }
    
        return val;
    }
    
    function getWidthOrHeight( elem, name, extra ) {
    
        // Start with offset property, which is equivalent to the border-box value
        var valueIsBorderBox = true,
            val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
            styles = getStyles( elem ),
            isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";
    
        // Some non-html elements return undefined for offsetWidth, so check for null/undefined
        // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
        // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
        if ( val <= 0 || val == null ) {
    
            // Fall back to computed then uncomputed css if necessary
            val = curCSS( elem, name, styles );
            if ( val < 0 || val == null ) {
                val = elem.style[ name ];
            }
    
            // Computed unit is not pixels. Stop here and return.
            if ( rnumnonpx.test( val ) ) {
                return val;
            }
    
            // Check for style in case a browser which returns unreliable values
            // for getComputedStyle silently falls back to the reliable elem.style
            valueIsBorderBox = isBorderBox &&
                ( support.boxSizingReliable() || val === elem.style[ name ] );
    
            // Normalize "", auto, and prepare for extra
            val = parseFloat( val ) || 0;
        }
    
        // Use the active box-sizing model to add/subtract irrelevant styles
        return ( val +
            augmentWidthOrHeight(
                elem,
                name,
                extra || ( isBorderBox ? "border" : "content" ),
                valueIsBorderBox,
                styles
            )
        ) + "px";
    }
    
    function showHide( elements, show ) {
        var display, elem, hidden,
            values = [],
            index = 0,
            length = elements.length;
    
        for ( ; index < length; index++ ) {
            elem = elements[ index ];
            if ( !elem.style ) {
                continue;
            }
    
            values[ index ] = dataPriv.get( elem, "olddisplay" );
            display = elem.style.display;
            if ( show ) {
    
                // Reset the inline display of this element to learn if it is
                // being hidden by cascaded rules or not
                if ( !values[ index ] && display === "none" ) {
                    elem.style.display = "";
                }
    
                // Set elements which have been overridden with display: none
                // in a stylesheet to whatever the default browser style is
                // for such an element
                if ( elem.style.display === "" && isHidden( elem ) ) {
                    values[ index ] = dataPriv.access(
                        elem,
                        "olddisplay",
                        defaultDisplay( elem.nodeName )
                    );
                }
            } else {
                hidden = isHidden( elem );
    
                if ( display !== "none" || !hidden ) {
                    dataPriv.set(
                        elem,
                        "olddisplay",
                        hidden ? display : jQuery.css( elem, "display" )
                    );
                }
            }
        }
    
        // Set the display of most of the elements in a second loop
        // to avoid the constant reflow
        for ( index = 0; index < length; index++ ) {
            elem = elements[ index ];
            if ( !elem.style ) {
                continue;
            }
            if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
                elem.style.display = show ? values[ index ] || "" : "none";
            }
        }
    
        return elements;
    }
    
    jQuery.extend( {
    
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function( elem, computed ) {
                    if ( computed ) {
    
                        // We should always get a number back from opacity
                        var ret = curCSS( elem, "opacity" );
                        return ret === "" ? "1" : ret;
                    }
                }
            }
        },
    
        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
            "animationIterationCount": true,
            "columnCount": true,
            "fillOpacity": true,
            "flexGrow": true,
            "flexShrink": true,
            "fontWeight": true,
            "lineHeight": true,
            "opacity": true,
            "order": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
        },
    
        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {
            "float": "cssFloat"
        },
    
        // Get and set the style property on a DOM Node
        style: function( elem, name, value, extra ) {
    
            // Don't set styles on text and comment nodes
            if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
                return;
            }
    
            // Make sure that we're working with the right name
            var ret, type, hooks,
                origName = jQuery.camelCase( name ),
                style = elem.style;
    
            name = jQuery.cssProps[ origName ] ||
                ( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );
    
            // Gets hook for the prefixed version, then unprefixed version
            hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
    
            // Check if we're setting a value
            if ( value !== undefined ) {
                type = typeof value;
    
                // Convert "+=" or "-=" to relative numbers (#7345)
                if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
                    value = adjustCSS( elem, name, ret );
    
                    // Fixes bug #9237
                    type = "number";
                }
    
                // Make sure that null and NaN values aren't set (#7116)
                if ( value == null || value !== value ) {
                    return;
                }
    
                // If a number was passed in, add the unit (except for certain CSS properties)
                if ( type === "number" ) {
                    value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
                }
    
                // Support: IE9-11+
                // background-* props affect original clone's values
                if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
                    style[ name ] = "inherit";
                }
    
                // If a hook was provided, use that value, otherwise just set the specified value
                if ( !hooks || !( "set" in hooks ) ||
                    ( value = hooks.set( elem, value, extra ) ) !== undefined ) {
    
                    style[ name ] = value;
                }
    
            } else {
    
                // If a hook was provided get the non-computed value from there
                if ( hooks && "get" in hooks &&
                    ( ret = hooks.get( elem, false, extra ) ) !== undefined ) {
    
                    return ret;
                }
    
                // Otherwise just get the value from the style object
                return style[ name ];
            }
        },
    
        css: function( elem, name, extra, styles ) {
            var val, num, hooks,
                origName = jQuery.camelCase( name );
    
            // Make sure that we're working with the right name
            name = jQuery.cssProps[ origName ] ||
                ( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );
    
            // Try prefixed name followed by the unprefixed name
            hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
    
            // If a hook was provided get the computed value from there
            if ( hooks && "get" in hooks ) {
                val = hooks.get( elem, true, extra );
            }
    
            // Otherwise, if a way to get the computed value exists, use that
            if ( val === undefined ) {
                val = curCSS( elem, name, styles );
            }
    
            // Convert "normal" to computed value
            if ( val === "normal" && name in cssNormalTransform ) {
                val = cssNormalTransform[ name ];
            }
    
            // Make numeric if forced or a qualifier was provided and val looks numeric
            if ( extra === "" || extra ) {
                num = parseFloat( val );
                return extra === true || isFinite( num ) ? num || 0 : val;
            }
            return val;
        }
    } );
    
    jQuery.each( [ "height", "width" ], function( i, name ) {
        jQuery.cssHooks[ name ] = {
            get: function( elem, computed, extra ) {
                if ( computed ) {
    
                    // Certain elements can have dimension info if we invisibly show them
                    // but it must have a current display style that would benefit
                    return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
                        elem.offsetWidth === 0 ?
                            swap( elem, cssShow, function() {
                                return getWidthOrHeight( elem, name, extra );
                            } ) :
                            getWidthOrHeight( elem, name, extra );
                }
            },
    
            set: function( elem, value, extra ) {
                var matches,
                    styles = extra && getStyles( elem ),
                    subtract = extra && augmentWidthOrHeight(
                        elem,
                        name,
                        extra,
                        jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
                        styles
                    );
    
                // Convert to pixels if value adjustment is needed
                if ( subtract && ( matches = rcssNum.exec( value ) ) &&
                    ( matches[ 3 ] || "px" ) !== "px" ) {
    
                    elem.style[ name ] = value;
                    value = jQuery.css( elem, name );
                }
    
                return setPositiveNumber( elem, value, subtract );
            }
        };
    } );
    
    jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
        function( elem, computed ) {
            if ( computed ) {
                return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
                    elem.getBoundingClientRect().left -
                        swap( elem, { marginLeft: 0 }, function() {
                            return elem.getBoundingClientRect().left;
                        } )
                    ) + "px";
            }
        }
    );
    
    // Support: Android 2.3
    jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
        function( elem, computed ) {
            if ( computed ) {
                return swap( elem, { "display": "inline-block" },
                    curCSS, [ elem, "marginRight" ] );
            }
        }
    );
    
    // These hooks are used by animate to expand properties
    jQuery.each( {
        margin: "",
        padding: "",
        border: "Width"
    }, function( prefix, suffix ) {
        jQuery.cssHooks[ prefix + suffix ] = {
            expand: function( value ) {
                var i = 0,
                    expanded = {},
    
                    // Assumes a single number if not a string
                    parts = typeof value === "string" ? value.split( " " ) : [ value ];
    
                for ( ; i < 4; i++ ) {
                    expanded[ prefix + cssExpand[ i ] + suffix ] =
                        parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
                }
    
                return expanded;
            }
        };
    
        if ( !rmargin.test( prefix ) ) {
            jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
        }
    } );
    
    jQuery.fn.extend( {
        css: function( name, value ) {
            return access( this, function( elem, name, value ) {
                var styles, len,
                    map = {},
                    i = 0;
    
                if ( jQuery.isArray( name ) ) {
                    styles = getStyles( elem );
                    len = name.length;
    
                    for ( ; i < len; i++ ) {
                        map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
                    }
    
                    return map;
                }
    
                return value !== undefined ?
                    jQuery.style( elem, name, value ) :
                    jQuery.css( elem, name );
            }, name, value, arguments.length > 1 );
        },
        show: function() {
            return showHide( this, true );
        },
        hide: function() {
            return showHide( this );
        },
        toggle: function( state ) {
            if ( typeof state === "boolean" ) {
                return state ? this.show() : this.hide();
            }
    
            return this.each( function() {
                if ( isHidden( this ) ) {
                    jQuery( this ).show();
                } else {
                    jQuery( this ).hide();
                }
            } );
        }
    } );
    
    
    function Tween( elem, options, prop, end, easing ) {
        return new Tween.prototype.init( elem, options, prop, end, easing );
    }
    jQuery.Tween = Tween;
    
    Tween.prototype = {
        constructor: Tween,
        init: function( elem, options, prop, end, easing, unit ) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery.easing._default;
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
        },
        cur: function() {
            var hooks = Tween.propHooks[ this.prop ];
    
            return hooks && hooks.get ?
                hooks.get( this ) :
                Tween.propHooks._default.get( this );
        },
        run: function( percent ) {
            var eased,
                hooks = Tween.propHooks[ this.prop ];
    
            if ( this.options.duration ) {
                this.pos = eased = jQuery.easing[ this.easing ](
                    percent, this.options.duration * percent, 0, 1, this.options.duration
                );
            } else {
                this.pos = eased = percent;
            }
            this.now = ( this.end - this.start ) * eased + this.start;
    
            if ( this.options.step ) {
                this.options.step.call( this.elem, this.now, this );
            }
    
            if ( hooks && hooks.set ) {
                hooks.set( this );
            } else {
                Tween.propHooks._default.set( this );
            }
            return this;
        }
    };
    
    Tween.prototype.init.prototype = Tween.prototype;
    
    Tween.propHooks = {
        _default: {
            get: function( tween ) {
                var result;
    
                // Use a property on the element directly when it is not a DOM element,
                // or when there is no matching style property that exists.
                if ( tween.elem.nodeType !== 1 ||
                    tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
                    return tween.elem[ tween.prop ];
                }
    
                // Passing an empty string as a 3rd parameter to .css will automatically
                // attempt a parseFloat and fallback to a string if the parse fails.
                // Simple values such as "10px" are parsed to Float;
                // complex values such as "rotate(1rad)" are returned as-is.
                result = jQuery.css( tween.elem, tween.prop, "" );
    
                // Empty strings, null, undefined and "auto" are converted to 0.
                return !result || result === "auto" ? 0 : result;
            },
            set: function( tween ) {
    
                // Use step hook for back compat.
                // Use cssHook if its there.
                // Use .style if available and use plain properties where available.
                if ( jQuery.fx.step[ tween.prop ] ) {
                    jQuery.fx.step[ tween.prop ]( tween );
                } else if ( tween.elem.nodeType === 1 &&
                    ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
                        jQuery.cssHooks[ tween.prop ] ) ) {
                    jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
                } else {
                    tween.elem[ tween.prop ] = tween.now;
                }
            }
        }
    };
    
    // Support: IE9
    // Panic based approach to setting things on disconnected nodes
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function( tween ) {
            if ( tween.elem.nodeType && tween.elem.parentNode ) {
                tween.elem[ tween.prop ] = tween.now;
            }
        }
    };
    
    jQuery.easing = {
        linear: function( p ) {
            return p;
        },
        swing: function( p ) {
            return 0.5 - Math.cos( p * Math.PI ) / 2;
        },
        _default: "swing"
    };
    
    jQuery.fx = Tween.prototype.init;
    
    // Back Compat <1.8 extension point
    jQuery.fx.step = {};
    
    
    
    
    var
        fxNow, timerId,
        rfxtypes = /^(?:toggle|show|hide)$/,
        rrun = /queueHooks$/;
    
    // Animations created synchronously will run synchronously
    function createFxNow() {
        window.setTimeout( function() {
            fxNow = undefined;
        } );
        return ( fxNow = jQuery.now() );
    }
    
    // Generate parameters to create a standard animation
    function genFx( type, includeWidth ) {
        var which,
            i = 0,
            attrs = { height: type };
    
        // If we include width, step value is 1 to do all cssExpand values,
        // otherwise step value is 2 to skip over Left and Right
        includeWidth = includeWidth ? 1 : 0;
        for ( ; i < 4 ; i += 2 - includeWidth ) {
            which = cssExpand[ i ];
            attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
        }
    
        if ( includeWidth ) {
            attrs.opacity = attrs.width = type;
        }
    
        return attrs;
    }
    
    function createTween( value, prop, animation ) {
        var tween,
            collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
            index = 0,
            length = collection.length;
        for ( ; index < length; index++ ) {
            if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {
    
                // We're done with this property
                return tween;
            }
        }
    }
    
    function defaultPrefilter( elem, props, opts ) {
        /* jshint validthis: true */
        var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
            anim = this,
            orig = {},
            style = elem.style,
            hidden = elem.nodeType && isHidden( elem ),
            dataShow = dataPriv.get( elem, "fxshow" );
    
        // Handle queue: false promises
        if ( !opts.queue ) {
            hooks = jQuery._queueHooks( elem, "fx" );
            if ( hooks.unqueued == null ) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function() {
                    if ( !hooks.unqueued ) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;
    
            anim.always( function() {
    
                // Ensure the complete handler is called before this completes
                anim.always( function() {
                    hooks.unqueued--;
                    if ( !jQuery.queue( elem, "fx" ).length ) {
                        hooks.empty.fire();
                    }
                } );
            } );
        }
    
        // Height/width overflow pass
        if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
    
            // Make sure that nothing sneaks out
            // Record all 3 overflow attributes because IE9-10 do not
            // change the overflow attribute when overflowX and
            // overflowY are set to the same value
            opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
    
            // Set display property to inline-block for height/width
            // animations on inline elements that are having width/height animated
            display = jQuery.css( elem, "display" );
    
            // Test default display if display is currently "none"
            checkDisplay = display === "none" ?
                dataPriv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;
    
            if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
                style.display = "inline-block";
            }
        }
    
        if ( opts.overflow ) {
            style.overflow = "hidden";
            anim.always( function() {
                style.overflow = opts.overflow[ 0 ];
                style.overflowX = opts.overflow[ 1 ];
                style.overflowY = opts.overflow[ 2 ];
            } );
        }
    
        // show/hide pass
        for ( prop in props ) {
            value = props[ prop ];
            if ( rfxtypes.exec( value ) ) {
                delete props[ prop ];
                toggle = toggle || value === "toggle";
                if ( value === ( hidden ? "hide" : "show" ) ) {
    
                    // If there is dataShow left over from a stopped hide or show
                    // and we are going to proceed with show, we should pretend to be hidden
                    if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
                        hidden = true;
                    } else {
                        continue;
                    }
                }
                orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
    
            // Any non-fx value stops us from restoring the original display value
            } else {
                display = undefined;
            }
        }
    
        if ( !jQuery.isEmptyObject( orig ) ) {
            if ( dataShow ) {
                if ( "hidden" in dataShow ) {
                    hidden = dataShow.hidden;
                }
            } else {
                dataShow = dataPriv.access( elem, "fxshow", {} );
            }
    
            // Store state if its toggle - enables .stop().toggle() to "reverse"
            if ( toggle ) {
                dataShow.hidden = !hidden;
            }
            if ( hidden ) {
                jQuery( elem ).show();
            } else {
                anim.done( function() {
                    jQuery( elem ).hide();
                } );
            }
            anim.done( function() {
                var prop;
    
                dataPriv.remove( elem, "fxshow" );
                for ( prop in orig ) {
                    jQuery.style( elem, prop, orig[ prop ] );
                }
            } );
            for ( prop in orig ) {
                tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
    
                if ( !( prop in dataShow ) ) {
                    dataShow[ prop ] = tween.start;
                    if ( hidden ) {
                        tween.end = tween.start;
                        tween.start = prop === "width" || prop === "height" ? 1 : 0;
                    }
                }
            }
    
        // If this is a noop like .hide().hide(), restore an overwritten display value
        } else if ( ( display === "none" ? defaultDisplay( elem.nodeName ) : display ) === "inline" ) {
            style.display = display;
        }
    }
    
    function propFilter( props, specialEasing ) {
        var index, name, easing, value, hooks;
    
        // camelCase, specialEasing and expand cssHook pass
        for ( index in props ) {
            name = jQuery.camelCase( index );
            easing = specialEasing[ name ];
            value = props[ index ];
            if ( jQuery.isArray( value ) ) {
                easing = value[ 1 ];
                value = props[ index ] = value[ 0 ];
            }
    
            if ( index !== name ) {
                props[ name ] = value;
                delete props[ index ];
            }
    
            hooks = jQuery.cssHooks[ name ];
            if ( hooks && "expand" in hooks ) {
                value = hooks.expand( value );
                delete props[ name ];
    
                // Not quite $.extend, this won't overwrite existing keys.
                // Reusing 'index' because we have the correct "name"
                for ( index in value ) {
                    if ( !( index in props ) ) {
                        props[ index ] = value[ index ];
                        specialEasing[ index ] = easing;
                    }
                }
            } else {
                specialEasing[ name ] = easing;
            }
        }
    }
    
    function Animation( elem, properties, options ) {
        var result,
            stopped,
            index = 0,
            length = Animation.prefilters.length,
            deferred = jQuery.Deferred().always( function() {
    
                // Don't match elem in the :animated selector
                delete tick.elem;
            } ),
            tick = function() {
                if ( stopped ) {
                    return false;
                }
                var currentTime = fxNow || createFxNow(),
                    remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
    
                    // Support: Android 2.3
                    // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
                    temp = remaining / animation.duration || 0,
                    percent = 1 - temp,
                    index = 0,
                    length = animation.tweens.length;
    
                for ( ; index < length ; index++ ) {
                    animation.tweens[ index ].run( percent );
                }
    
                deferred.notifyWith( elem, [ animation, percent, remaining ] );
    
                if ( percent < 1 && length ) {
                    return remaining;
                } else {
                    deferred.resolveWith( elem, [ animation ] );
                    return false;
                }
            },
            animation = deferred.promise( {
                elem: elem,
                props: jQuery.extend( {}, properties ),
                opts: jQuery.extend( true, {
                    specialEasing: {},
                    easing: jQuery.easing._default
                }, options ),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function( prop, end ) {
                    var tween = jQuery.Tween( elem, animation.opts, prop, end,
                            animation.opts.specialEasing[ prop ] || animation.opts.easing );
                    animation.tweens.push( tween );
                    return tween;
                },
                stop: function( gotoEnd ) {
                    var index = 0,
    
                        // If we are going to the end, we want to run all the tweens
                        // otherwise we skip this part
                        length = gotoEnd ? animation.tweens.length : 0;
                    if ( stopped ) {
                        return this;
                    }
                    stopped = true;
                    for ( ; index < length ; index++ ) {
                        animation.tweens[ index ].run( 1 );
                    }
    
                    // Resolve when we played the last frame; otherwise, reject
                    if ( gotoEnd ) {
                        deferred.notifyWith( elem, [ animation, 1, 0 ] );
                        deferred.resolveWith( elem, [ animation, gotoEnd ] );
                    } else {
                        deferred.rejectWith( elem, [ animation, gotoEnd ] );
                    }
                    return this;
                }
            } ),
            props = animation.props;
    
        propFilter( props, animation.opts.specialEasing );
    
        for ( ; index < length ; index++ ) {
            result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
            if ( result ) {
                if ( jQuery.isFunction( result.stop ) ) {
                    jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
                        jQuery.proxy( result.stop, result );
                }
                return result;
            }
        }
    
        jQuery.map( props, createTween, animation );
    
        if ( jQuery.isFunction( animation.opts.start ) ) {
            animation.opts.start.call( elem, animation );
        }
    
        jQuery.fx.timer(
            jQuery.extend( tick, {
                elem: elem,
                anim: animation,
                queue: animation.opts.queue
            } )
        );
    
        // attach callbacks from options
        return animation.progress( animation.opts.progress )
            .done( animation.opts.done, animation.opts.complete )
            .fail( animation.opts.fail )
            .always( animation.opts.always );
    }
    
    jQuery.Animation = jQuery.extend( Animation, {
        tweeners: {
            "*": [ function( prop, value ) {
                var tween = this.createTween( prop, value );
                adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
                return tween;
            } ]
        },
    
        tweener: function( props, callback ) {
            if ( jQuery.isFunction( props ) ) {
                callback = props;
                props = [ "*" ];
            } else {
                props = props.match( rnotwhite );
            }
    
            var prop,
                index = 0,
                length = props.length;
    
            for ( ; index < length ; index++ ) {
                prop = props[ index ];
                Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
                Animation.tweeners[ prop ].unshift( callback );
            }
        },
    
        prefilters: [ defaultPrefilter ],
    
        prefilter: function( callback, prepend ) {
            if ( prepend ) {
                Animation.prefilters.unshift( callback );
            } else {
                Animation.prefilters.push( callback );
            }
        }
    } );
    
    jQuery.speed = function( speed, easing, fn ) {
        var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
            complete: fn || !fn && easing ||
                jQuery.isFunction( speed ) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
        };
    
        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ?
            opt.duration : opt.duration in jQuery.fx.speeds ?
                jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
    
        // Normalize opt.queue - true/undefined/null -> "fx"
        if ( opt.queue == null || opt.queue === true ) {
            opt.queue = "fx";
        }
    
        // Queueing
        opt.old = opt.complete;
    
        opt.complete = function() {
            if ( jQuery.isFunction( opt.old ) ) {
                opt.old.call( this );
            }
    
            if ( opt.queue ) {
                jQuery.dequeue( this, opt.queue );
            }
        };
    
        return opt;
    };
    
    jQuery.fn.extend( {
        fadeTo: function( speed, to, easing, callback ) {
    
            // Show any hidden elements after setting opacity to 0
            return this.filter( isHidden ).css( "opacity", 0 ).show()
    
                // Animate to the value specified
                .end().animate( { opacity: to }, speed, easing, callback );
        },
        animate: function( prop, speed, easing, callback ) {
            var empty = jQuery.isEmptyObject( prop ),
                optall = jQuery.speed( speed, easing, callback ),
                doAnimation = function() {
    
                    // Operate on a copy of prop so per-property easing won't be lost
                    var anim = Animation( this, jQuery.extend( {}, prop ), optall );
    
                    // Empty animations, or finishing resolves immediately
                    if ( empty || dataPriv.get( this, "finish" ) ) {
                        anim.stop( true );
                    }
                };
                doAnimation.finish = doAnimation;
    
            return empty || optall.queue === false ?
                this.each( doAnimation ) :
                this.queue( optall.queue, doAnimation );
        },
        stop: function( type, clearQueue, gotoEnd ) {
            var stopQueue = function( hooks ) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop( gotoEnd );
            };
    
            if ( typeof type !== "string" ) {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if ( clearQueue && type !== false ) {
                this.queue( type || "fx", [] );
            }
    
            return this.each( function() {
                var dequeue = true,
                    index = type != null && type + "queueHooks",
                    timers = jQuery.timers,
                    data = dataPriv.get( this );
    
                if ( index ) {
                    if ( data[ index ] && data[ index ].stop ) {
                        stopQueue( data[ index ] );
                    }
                } else {
                    for ( index in data ) {
                        if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
                            stopQueue( data[ index ] );
                        }
                    }
                }
    
                for ( index = timers.length; index--; ) {
                    if ( timers[ index ].elem === this &&
                        ( type == null || timers[ index ].queue === type ) ) {
    
                        timers[ index ].anim.stop( gotoEnd );
                        dequeue = false;
                        timers.splice( index, 1 );
                    }
                }
    
                // Start the next in the queue if the last step wasn't forced.
                // Timers currently will call their complete callbacks, which
                // will dequeue but only if they were gotoEnd.
                if ( dequeue || !gotoEnd ) {
                    jQuery.dequeue( this, type );
                }
            } );
        },
        finish: function( type ) {
            if ( type !== false ) {
                type = type || "fx";
            }
            return this.each( function() {
                var index,
                    data = dataPriv.get( this ),
                    queue = data[ type + "queue" ],
                    hooks = data[ type + "queueHooks" ],
                    timers = jQuery.timers,
                    length = queue ? queue.length : 0;
    
                // Enable finishing flag on private data
                data.finish = true;
    
                // Empty the queue first
                jQuery.queue( this, type, [] );
    
                if ( hooks && hooks.stop ) {
                    hooks.stop.call( this, true );
                }
    
                // Look for any active animations, and finish them
                for ( index = timers.length; index--; ) {
                    if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
                        timers[ index ].anim.stop( true );
                        timers.splice( index, 1 );
                    }
                }
    
                // Look for any animations in the old queue and finish them
                for ( index = 0; index < length; index++ ) {
                    if ( queue[ index ] && queue[ index ].finish ) {
                        queue[ index ].finish.call( this );
                    }
                }
    
                // Turn off finishing flag
                delete data.finish;
            } );
        }
    } );
    
    jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
        var cssFn = jQuery.fn[ name ];
        jQuery.fn[ name ] = function( speed, easing, callback ) {
            return speed == null || typeof speed === "boolean" ?
                cssFn.apply( this, arguments ) :
                this.animate( genFx( name, true ), speed, easing, callback );
        };
    } );
    
    // Generate shortcuts for custom animations
    jQuery.each( {
        slideDown: genFx( "show" ),
        slideUp: genFx( "hide" ),
        slideToggle: genFx( "toggle" ),
        fadeIn: { opacity: "show" },
        fadeOut: { opacity: "hide" },
        fadeToggle: { opacity: "toggle" }
    }, function( name, props ) {
        jQuery.fn[ name ] = function( speed, easing, callback ) {
            return this.animate( props, speed, easing, callback );
        };
    } );
    
    jQuery.timers = [];
    jQuery.fx.tick = function() {
        var timer,
            i = 0,
            timers = jQuery.timers;
    
        fxNow = jQuery.now();
    
        for ( ; i < timers.length; i++ ) {
            timer = timers[ i ];
    
            // Checks the timer has not already been removed
            if ( !timer() && timers[ i ] === timer ) {
                timers.splice( i--, 1 );
            }
        }
    
        if ( !timers.length ) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };
    
    jQuery.fx.timer = function( timer ) {
        jQuery.timers.push( timer );
        if ( timer() ) {
            jQuery.fx.start();
        } else {
            jQuery.timers.pop();
        }
    };
    
    jQuery.fx.interval = 13;
    jQuery.fx.start = function() {
        if ( !timerId ) {
            timerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
        }
    };
    
    jQuery.fx.stop = function() {
        window.clearInterval( timerId );
    
        timerId = null;
    };
    
    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
    
        // Default speed
        _default: 400
    };
    
    
    // Based off of the plugin by Clint Helfers, with permission.
    // http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
    jQuery.fn.delay = function( time, type ) {
        time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
        type = type || "fx";
    
        return this.queue( type, function( next, hooks ) {
            var timeout = window.setTimeout( next, time );
            hooks.stop = function() {
                window.clearTimeout( timeout );
            };
        } );
    };
    
    
    ( function() {
        var input = document.createElement( "input" ),
            select = document.createElement( "select" ),
            opt = select.appendChild( document.createElement( "option" ) );
    
        input.type = "checkbox";
    
        // Support: iOS<=5.1, Android<=4.2+
        // Default value for a checkbox should be "on"
        support.checkOn = input.value !== "";
    
        // Support: IE<=11+
        // Must access selectedIndex to make default options select
        support.optSelected = opt.selected;
    
        // Support: Android<=2.3
        // Options inside disabled selects are incorrectly marked as disabled
        select.disabled = true;
        support.optDisabled = !opt.disabled;
    
        // Support: IE<=11+
        // An input loses its value after becoming a radio
        input = document.createElement( "input" );
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
    } )();
    
    
    var boolHook,
        attrHandle = jQuery.expr.attrHandle;
    
    jQuery.fn.extend( {
        attr: function( name, value ) {
            return access( this, jQuery.attr, name, value, arguments.length > 1 );
        },
    
        removeAttr: function( name ) {
            return this.each( function() {
                jQuery.removeAttr( this, name );
            } );
        }
    } );
    
    jQuery.extend( {
        attr: function( elem, name, value ) {
            var ret, hooks,
                nType = elem.nodeType;
    
            // Don't get/set attributes on text, comment and attribute nodes
            if ( nType === 3 || nType === 8 || nType === 2 ) {
                return;
            }
    
            // Fallback to prop when attributes are not supported
            if ( typeof elem.getAttribute === "undefined" ) {
                return jQuery.prop( elem, name, value );
            }
    
            // All attributes are lowercase
            // Grab necessary hook if one is defined
            if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[ name ] ||
                    ( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
            }
    
            if ( value !== undefined ) {
                if ( value === null ) {
                    jQuery.removeAttr( elem, name );
                    return;
                }
    
                if ( hooks && "set" in hooks &&
                    ( ret = hooks.set( elem, value, name ) ) !== undefined ) {
                    return ret;
                }
    
                elem.setAttribute( name, value + "" );
                return value;
            }
    
            if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
                return ret;
            }
    
            ret = jQuery.find.attr( elem, name );
    
            // Non-existent attributes return null, we normalize to undefined
            return ret == null ? undefined : ret;
        },
    
        attrHooks: {
            type: {
                set: function( elem, value ) {
                    if ( !support.radioValue && value === "radio" &&
                        jQuery.nodeName( elem, "input" ) ) {
                        var val = elem.value;
                        elem.setAttribute( "type", value );
                        if ( val ) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        },
    
        removeAttr: function( elem, value ) {
            var name, propName,
                i = 0,
                attrNames = value && value.match( rnotwhite );
    
            if ( attrNames && elem.nodeType === 1 ) {
                while ( ( name = attrNames[ i++ ] ) ) {
                    propName = jQuery.propFix[ name ] || name;
    
                    // Boolean attributes get special treatment (#10870)
                    if ( jQuery.expr.match.bool.test( name ) ) {
    
                        // Set corresponding property to false
                        elem[ propName ] = false;
                    }
    
                    elem.removeAttribute( name );
                }
            }
        }
    } );
    
    // Hooks for boolean attributes
    boolHook = {
        set: function( elem, value, name ) {
            if ( value === false ) {
    
                // Remove boolean attributes when set to false
                jQuery.removeAttr( elem, name );
            } else {
                elem.setAttribute( name, name );
            }
            return name;
        }
    };
    jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
        var getter = attrHandle[ name ] || jQuery.find.attr;
    
        attrHandle[ name ] = function( elem, name, isXML ) {
            var ret, handle;
            if ( !isXML ) {
    
                // Avoid an infinite loop by temporarily removing this function from the getter
                handle = attrHandle[ name ];
                attrHandle[ name ] = ret;
                ret = getter( elem, name, isXML ) != null ?
                    name.toLowerCase() :
                    null;
                attrHandle[ name ] = handle;
            }
            return ret;
        };
    } );
    
    
    
    
    var rfocusable = /^(?:input|select|textarea|button)$/i,
        rclickable = /^(?:a|area)$/i;
    
    jQuery.fn.extend( {
        prop: function( name, value ) {
            return access( this, jQuery.prop, name, value, arguments.length > 1 );
        },
    
        removeProp: function( name ) {
            return this.each( function() {
                delete this[ jQuery.propFix[ name ] || name ];
            } );
        }
    } );
    
    jQuery.extend( {
        prop: function( elem, name, value ) {
            var ret, hooks,
                nType = elem.nodeType;
    
            // Don't get/set properties on text, comment and attribute nodes
            if ( nType === 3 || nType === 8 || nType === 2 ) {
                return;
            }
    
            if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
    
                // Fix name and attach hooks
                name = jQuery.propFix[ name ] || name;
                hooks = jQuery.propHooks[ name ];
            }
    
            if ( value !== undefined ) {
                if ( hooks && "set" in hooks &&
                    ( ret = hooks.set( elem, value, name ) ) !== undefined ) {
                    return ret;
                }
    
                return ( elem[ name ] = value );
            }
    
            if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
                return ret;
            }
    
            return elem[ name ];
        },
    
        propHooks: {
            tabIndex: {
                get: function( elem ) {
    
                    // elem.tabIndex doesn't always return the
                    // correct value when it hasn't been explicitly set
                    // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                    // Use proper attribute retrieval(#12072)
                    var tabindex = jQuery.find.attr( elem, "tabindex" );
    
                    return tabindex ?
                        parseInt( tabindex, 10 ) :
                        rfocusable.test( elem.nodeName ) ||
                            rclickable.test( elem.nodeName ) && elem.href ?
                                0 :
                                -1;
                }
            }
        },
    
        propFix: {
            "for": "htmlFor",
            "class": "className"
        }
    } );
    
    // Support: IE <=11 only
    // Accessing the selectedIndex property
    // forces the browser to respect setting selected
    // on the option
    // The getter ensures a default option is selected
    // when in an optgroup
    if ( !support.optSelected ) {
        jQuery.propHooks.selected = {
            get: function( elem ) {
                var parent = elem.parentNode;
                if ( parent && parent.parentNode ) {
                    parent.parentNode.selectedIndex;
                }
                return null;
            },
            set: function( elem ) {
                var parent = elem.parentNode;
                if ( parent ) {
                    parent.selectedIndex;
    
                    if ( parent.parentNode ) {
                        parent.parentNode.selectedIndex;
                    }
                }
            }
        };
    }
    
    jQuery.each( [
        "tabIndex",
        "readOnly",
        "maxLength",
        "cellSpacing",
        "cellPadding",
        "rowSpan",
        "colSpan",
        "useMap",
        "frameBorder",
        "contentEditable"
    ], function() {
        jQuery.propFix[ this.toLowerCase() ] = this;
    } );
    
    
    
    
    var rclass = /[\t\r\n\f]/g;
    
    function getClass( elem ) {
        return elem.getAttribute && elem.getAttribute( "class" ) || "";
    }
    
    jQuery.fn.extend( {
        addClass: function( value ) {
            var classes, elem, cur, curValue, clazz, j, finalValue,
                i = 0;
    
            if ( jQuery.isFunction( value ) ) {
                return this.each( function( j ) {
                    jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
                } );
            }
    
            if ( typeof value === "string" && value ) {
                classes = value.match( rnotwhite ) || [];
    
                while ( ( elem = this[ i++ ] ) ) {
                    curValue = getClass( elem );
                    cur = elem.nodeType === 1 &&
                        ( " " + curValue + " " ).replace( rclass, " " );
    
                    if ( cur ) {
                        j = 0;
                        while ( ( clazz = classes[ j++ ] ) ) {
                            if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
                                cur += clazz + " ";
                            }
                        }
    
                        // Only assign if different to avoid unneeded rendering.
                        finalValue = jQuery.trim( cur );
                        if ( curValue !== finalValue ) {
                            elem.setAttribute( "class", finalValue );
                        }
                    }
                }
            }
    
            return this;
        },
    
        removeClass: function( value ) {
            var classes, elem, cur, curValue, clazz, j, finalValue,
                i = 0;
    
            if ( jQuery.isFunction( value ) ) {
                return this.each( function( j ) {
                    jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
                } );
            }
    
            if ( !arguments.length ) {
                return this.attr( "class", "" );
            }
    
            if ( typeof value === "string" && value ) {
                classes = value.match( rnotwhite ) || [];
    
                while ( ( elem = this[ i++ ] ) ) {
                    curValue = getClass( elem );
    
                    // This expression is here for better compressibility (see addClass)
                    cur = elem.nodeType === 1 &&
                        ( " " + curValue + " " ).replace( rclass, " " );
    
                    if ( cur ) {
                        j = 0;
                        while ( ( clazz = classes[ j++ ] ) ) {
    
                            // Remove *all* instances
                            while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
                                cur = cur.replace( " " + clazz + " ", " " );
                            }
                        }
    
                        // Only assign if different to avoid unneeded rendering.
                        finalValue = jQuery.trim( cur );
                        if ( curValue !== finalValue ) {
                            elem.setAttribute( "class", finalValue );
                        }
                    }
                }
            }
    
            return this;
        },
    
        toggleClass: function( value, stateVal ) {
            var type = typeof value;
    
            if ( typeof stateVal === "boolean" && type === "string" ) {
                return stateVal ? this.addClass( value ) : this.removeClass( value );
            }
    
            if ( jQuery.isFunction( value ) ) {
                return this.each( function( i ) {
                    jQuery( this ).toggleClass(
                        value.call( this, i, getClass( this ), stateVal ),
                        stateVal
                    );
                } );
            }
    
            return this.each( function() {
                var className, i, self, classNames;
    
                if ( type === "string" ) {
    
                    // Toggle individual class names
                    i = 0;
                    self = jQuery( this );
                    classNames = value.match( rnotwhite ) || [];
    
                    while ( ( className = classNames[ i++ ] ) ) {
    
                        // Check each className given, space separated list
                        if ( self.hasClass( className ) ) {
                            self.removeClass( className );
                        } else {
                            self.addClass( className );
                        }
                    }
    
                // Toggle whole class name
                } else if ( value === undefined || type === "boolean" ) {
                    className = getClass( this );
                    if ( className ) {
    
                        // Store className if set
                        dataPriv.set( this, "__className__", className );
                    }
    
                    // If the element has a class name or if we're passed `false`,
                    // then remove the whole classname (if there was one, the above saved it).
                    // Otherwise bring back whatever was previously saved (if anything),
                    // falling back to the empty string if nothing was stored.
                    if ( this.setAttribute ) {
                        this.setAttribute( "class",
                            className || value === false ?
                            "" :
                            dataPriv.get( this, "__className__" ) || ""
                        );
                    }
                }
            } );
        },
    
        hasClass: function( selector ) {
            var className, elem,
                i = 0;
    
            className = " " + selector + " ";
            while ( ( elem = this[ i++ ] ) ) {
                if ( elem.nodeType === 1 &&
                    ( " " + getClass( elem ) + " " ).replace( rclass, " " )
                        .indexOf( className ) > -1
                ) {
                    return true;
                }
            }
    
            return false;
        }
    } );
    
    
    
    
    var rreturn = /\r/g,
        rspaces = /[\x20\t\r\n\f]+/g;
    
    jQuery.fn.extend( {
        val: function( value ) {
            var hooks, ret, isFunction,
                elem = this[ 0 ];
    
            if ( !arguments.length ) {
                if ( elem ) {
                    hooks = jQuery.valHooks[ elem.type ] ||
                        jQuery.valHooks[ elem.nodeName.toLowerCase() ];
    
                    if ( hooks &&
                        "get" in hooks &&
                        ( ret = hooks.get( elem, "value" ) ) !== undefined
                    ) {
                        return ret;
                    }
    
                    ret = elem.value;
    
                    return typeof ret === "string" ?
    
                        // Handle most common string cases
                        ret.replace( rreturn, "" ) :
    
                        // Handle cases where value is null/undef or number
                        ret == null ? "" : ret;
                }
    
                return;
            }
    
            isFunction = jQuery.isFunction( value );
    
            return this.each( function( i ) {
                var val;
    
                if ( this.nodeType !== 1 ) {
                    return;
                }
    
                if ( isFunction ) {
                    val = value.call( this, i, jQuery( this ).val() );
                } else {
                    val = value;
                }
    
                // Treat null/undefined as ""; convert numbers to string
                if ( val == null ) {
                    val = "";
    
                } else if ( typeof val === "number" ) {
                    val += "";
    
                } else if ( jQuery.isArray( val ) ) {
                    val = jQuery.map( val, function( value ) {
                        return value == null ? "" : value + "";
                    } );
                }
    
                hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
    
                // If set returns undefined, fall back to normal setting
                if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
                    this.value = val;
                }
            } );
        }
    } );
    
    jQuery.extend( {
        valHooks: {
            option: {
                get: function( elem ) {
    
                    var val = jQuery.find.attr( elem, "value" );
                    return val != null ?
                        val :
    
                        // Support: IE10-11+
                        // option.text throws exceptions (#14686, #14858)
                        // Strip and collapse whitespace
                        // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                        jQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );
                }
            },
            select: {
                get: function( elem ) {
                    var value, option,
                        options = elem.options,
                        index = elem.selectedIndex,
                        one = elem.type === "select-one" || index < 0,
                        values = one ? null : [],
                        max = one ? index + 1 : options.length,
                        i = index < 0 ?
                            max :
                            one ? index : 0;
    
                    // Loop through all the selected options
                    for ( ; i < max; i++ ) {
                        option = options[ i ];
    
                        // IE8-9 doesn't update selected after form reset (#2551)
                        if ( ( option.selected || i === index ) &&
    
                                // Don't return options that are disabled or in a disabled optgroup
                                ( support.optDisabled ?
                                    !option.disabled : option.getAttribute( "disabled" ) === null ) &&
                                ( !option.parentNode.disabled ||
                                    !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {
    
                            // Get the specific value for the option
                            value = jQuery( option ).val();
    
                            // We don't need an array for one selects
                            if ( one ) {
                                return value;
                            }
    
                            // Multi-Selects return an array
                            values.push( value );
                        }
                    }
    
                    return values;
                },
    
                set: function( elem, value ) {
                    var optionSet, option,
                        options = elem.options,
                        values = jQuery.makeArray( value ),
                        i = options.length;
    
                    while ( i-- ) {
                        option = options[ i ];
                        if ( option.selected =
                            jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
                        ) {
                            optionSet = true;
                        }
                    }
    
                    // Force browsers to behave consistently when non-matching value is set
                    if ( !optionSet ) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        }
    } );
    
    // Radios and checkboxes getter/setter
    jQuery.each( [ "radio", "checkbox" ], function() {
        jQuery.valHooks[ this ] = {
            set: function( elem, value ) {
                if ( jQuery.isArray( value ) ) {
                    return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
                }
            }
        };
        if ( !support.checkOn ) {
            jQuery.valHooks[ this ].get = function( elem ) {
                return elem.getAttribute( "value" ) === null ? "on" : elem.value;
            };
        }
    } );
    
    
    
    
    // Return jQuery for attributes-only inclusion
    
    
    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
    
    jQuery.extend( jQuery.event, {
    
        trigger: function( event, data, elem, onlyHandlers ) {
    
            var i, cur, tmp, bubbleType, ontype, handle, special,
                eventPath = [ elem || document ],
                type = hasOwn.call( event, "type" ) ? event.type : event,
                namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];
    
            cur = tmp = elem = elem || document;
    
            // Don't do events on text and comment nodes
            if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
                return;
            }
    
            // focus/blur morphs to focusin/out; ensure we're not firing them right now
            if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
                return;
            }
    
            if ( type.indexOf( "." ) > -1 ) {
    
                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split( "." );
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf( ":" ) < 0 && "on" + type;
    
            // Caller can pass in a jQuery.Event object, Object, or just an event type string
            event = event[ jQuery.expando ] ?
                event :
                new jQuery.Event( type, typeof event === "object" && event );
    
            // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join( "." );
            event.rnamespace = event.namespace ?
                new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
                null;
    
            // Clean up the event in case it is being reused
            event.result = undefined;
            if ( !event.target ) {
                event.target = elem;
            }
    
            // Clone any incoming data and prepend the event, creating the handler arg list
            data = data == null ?
                [ event ] :
                jQuery.makeArray( data, [ event ] );
    
            // Allow special events to draw outside the lines
            special = jQuery.event.special[ type ] || {};
            if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
                return;
            }
    
            // Determine event propagation path in advance, per W3C events spec (#9951)
            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
            if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
    
                bubbleType = special.delegateType || type;
                if ( !rfocusMorph.test( bubbleType + type ) ) {
                    cur = cur.parentNode;
                }
                for ( ; cur; cur = cur.parentNode ) {
                    eventPath.push( cur );
                    tmp = cur;
                }
    
                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                if ( tmp === ( elem.ownerDocument || document ) ) {
                    eventPath.push( tmp.defaultView || tmp.parentWindow || window );
                }
            }
    
            // Fire handlers on the event path
            i = 0;
            while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
    
                event.type = i > 1 ?
                    bubbleType :
                    special.bindType || type;
    
                // jQuery handler
                handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
                    dataPriv.get( cur, "handle" );
                if ( handle ) {
                    handle.apply( cur, data );
                }
    
                // Native handler
                handle = ontype && cur[ ontype ];
                if ( handle && handle.apply && acceptData( cur ) ) {
                    event.result = handle.apply( cur, data );
                    if ( event.result === false ) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;
    
            // If nobody prevented the default action, do it now
            if ( !onlyHandlers && !event.isDefaultPrevented() ) {
    
                if ( ( !special._default ||
                    special._default.apply( eventPath.pop(), data ) === false ) &&
                    acceptData( elem ) ) {
    
                    // Call a native DOM method on the target with the same name name as the event.
                    // Don't do default actions on window, that's where global variables be (#6170)
                    if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {
    
                        // Don't re-trigger an onFOO event when we call its FOO() method
                        tmp = elem[ ontype ];
    
                        if ( tmp ) {
                            elem[ ontype ] = null;
                        }
    
                        // Prevent re-triggering of the same event, since we already bubbled it above
                        jQuery.event.triggered = type;
                        elem[ type ]();
                        jQuery.event.triggered = undefined;
    
                        if ( tmp ) {
                            elem[ ontype ] = tmp;
                        }
                    }
                }
            }
    
            return event.result;
        },
    
        // Piggyback on a donor event to simulate a different one
        // Used only for `focus(in | out)` events
        simulate: function( type, elem, event ) {
            var e = jQuery.extend(
                new jQuery.Event(),
                event,
                {
                    type: type,
                    isSimulated: true
                }
            );
    
            jQuery.event.trigger( e, null, elem );
        }
    
    } );
    
    jQuery.fn.extend( {
    
        trigger: function( type, data ) {
            return this.each( function() {
                jQuery.event.trigger( type, data, this );
            } );
        },
        triggerHandler: function( type, data ) {
            var elem = this[ 0 ];
            if ( elem ) {
                return jQuery.event.trigger( type, data, elem, true );
            }
        }
    } );
    
    
    jQuery.each( ( "blur focus focusin focusout load resize scroll unload click dblclick " +
        "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
        "change select submit keydown keypress keyup error contextmenu" ).split( " " ),
        function( i, name ) {
    
        // Handle event binding
        jQuery.fn[ name ] = function( data, fn ) {
            return arguments.length > 0 ?
                this.on( name, null, data, fn ) :
                this.trigger( name );
        };
    } );
    
    jQuery.fn.extend( {
        hover: function( fnOver, fnOut ) {
            return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
        }
    } );
    
    
    
    
    support.focusin = "onfocusin" in window;
    
    
    // Support: Firefox
    // Firefox doesn't have focus(in | out) events
    // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
    //
    // Support: Chrome, Safari
    // focus(in | out) events fire after focus & blur events,
    // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
    // Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
    if ( !support.focusin ) {
        jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {
    
            // Attach a single capturing handler on the document while someone wants focusin/focusout
            var handler = function( event ) {
                jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
            };
    
            jQuery.event.special[ fix ] = {
                setup: function() {
                    var doc = this.ownerDocument || this,
                        attaches = dataPriv.access( doc, fix );
    
                    if ( !attaches ) {
                        doc.addEventListener( orig, handler, true );
                    }
                    dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
                },
                teardown: function() {
                    var doc = this.ownerDocument || this,
                        attaches = dataPriv.access( doc, fix ) - 1;
    
                    if ( !attaches ) {
                        doc.removeEventListener( orig, handler, true );
                        dataPriv.remove( doc, fix );
    
                    } else {
                        dataPriv.access( doc, fix, attaches );
                    }
                }
            };
        } );
    }
    var location = window.location;
    
    var nonce = jQuery.now();
    
    var rquery = ( /\?/ );
    
    
    
    // Support: Android 2.3
    // Workaround failure to string-cast null input
    jQuery.parseJSON = function( data ) {
        return JSON.parse( data + "" );
    };
    
    
    // Cross-browser xml parsing
    jQuery.parseXML = function( data ) {
        var xml;
        if ( !data || typeof data !== "string" ) {
            return null;
        }
    
        // Support: IE9
        try {
            xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
        } catch ( e ) {
            xml = undefined;
        }
    
        if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
            jQuery.error( "Invalid XML: " + data );
        }
        return xml;
    };
    
    
    var
        rhash = /#.*$/,
        rts = /([?&])_=[^&]*/,
        rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
    
        // #7653, #8125, #8152: local protocol detection
        rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
        rnoContent = /^(?:GET|HEAD)$/,
        rprotocol = /^\/\//,
    
        /* Prefilters
         * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
         * 2) These are called:
         *    - BEFORE asking for a transport
         *    - AFTER param serialization (s.data is a string if s.processData is true)
         * 3) key is the dataType
         * 4) the catchall symbol "*" can be used
         * 5) execution will start with transport dataType and THEN continue down to "*" if needed
         */
        prefilters = {},
    
        /* Transports bindings
         * 1) key is the dataType
         * 2) the catchall symbol "*" can be used
         * 3) selection will start with transport dataType and THEN go to "*" if needed
         */
        transports = {},
    
        // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
        allTypes = "*/".concat( "*" ),
    
        // Anchor tag for parsing the document origin
        originAnchor = document.createElement( "a" );
        originAnchor.href = location.href;
    
    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports( structure ) {
    
        // dataTypeExpression is optional and defaults to "*"
        return function( dataTypeExpression, func ) {
    
            if ( typeof dataTypeExpression !== "string" ) {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }
    
            var dataType,
                i = 0,
                dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];
    
            if ( jQuery.isFunction( func ) ) {
    
                // For each dataType in the dataTypeExpression
                while ( ( dataType = dataTypes[ i++ ] ) ) {
    
                    // Prepend if requested
                    if ( dataType[ 0 ] === "+" ) {
                        dataType = dataType.slice( 1 ) || "*";
                        ( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );
    
                    // Otherwise append
                    } else {
                        ( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
                    }
                }
            }
        };
    }
    
    // Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {
    
        var inspected = {},
            seekingTransport = ( structure === transports );
    
        function inspect( dataType ) {
            var selected;
            inspected[ dataType ] = true;
            jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
                var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
                if ( typeof dataTypeOrTransport === "string" &&
                    !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
    
                    options.dataTypes.unshift( dataTypeOrTransport );
                    inspect( dataTypeOrTransport );
                    return false;
                } else if ( seekingTransport ) {
                    return !( selected = dataTypeOrTransport );
                }
            } );
            return selected;
        }
    
        return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
    }
    
    // A special extend for ajax options
    // that takes "flat" options (not to be deep extended)
    // Fixes #9887
    function ajaxExtend( target, src ) {
        var key, deep,
            flatOptions = jQuery.ajaxSettings.flatOptions || {};
    
        for ( key in src ) {
            if ( src[ key ] !== undefined ) {
                ( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
            }
        }
        if ( deep ) {
            jQuery.extend( true, target, deep );
        }
    
        return target;
    }
    
    /* Handles responses to an ajax request:
     * - finds the right dataType (mediates between content-type and expected dataType)
     * - returns the corresponding response
     */
    function ajaxHandleResponses( s, jqXHR, responses ) {
    
        var ct, type, finalDataType, firstDataType,
            contents = s.contents,
            dataTypes = s.dataTypes;
    
        // Remove auto dataType and get content-type in the process
        while ( dataTypes[ 0 ] === "*" ) {
            dataTypes.shift();
            if ( ct === undefined ) {
                ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
            }
        }
    
        // Check if we're dealing with a known content-type
        if ( ct ) {
            for ( type in contents ) {
                if ( contents[ type ] && contents[ type ].test( ct ) ) {
                    dataTypes.unshift( type );
                    break;
                }
            }
        }
    
        // Check to see if we have a response for the expected dataType
        if ( dataTypes[ 0 ] in responses ) {
            finalDataType = dataTypes[ 0 ];
        } else {
    
            // Try convertible dataTypes
            for ( type in responses ) {
                if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
                    finalDataType = type;
                    break;
                }
                if ( !firstDataType ) {
                    firstDataType = type;
                }
            }
    
            // Or just use first one
            finalDataType = finalDataType || firstDataType;
        }
    
        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        if ( finalDataType ) {
            if ( finalDataType !== dataTypes[ 0 ] ) {
                dataTypes.unshift( finalDataType );
            }
            return responses[ finalDataType ];
        }
    }
    
    /* Chain conversions given the request and the original response
     * Also sets the responseXXX fields on the jqXHR instance
     */
    function ajaxConvert( s, response, jqXHR, isSuccess ) {
        var conv2, current, conv, tmp, prev,
            converters = {},
    
            // Work with a copy of dataTypes in case we need to modify it for conversion
            dataTypes = s.dataTypes.slice();
    
        // Create converters map with lowercased keys
        if ( dataTypes[ 1 ] ) {
            for ( conv in s.converters ) {
                converters[ conv.toLowerCase() ] = s.converters[ conv ];
            }
        }
    
        current = dataTypes.shift();
    
        // Convert to each sequential dataType
        while ( current ) {
    
            if ( s.responseFields[ current ] ) {
                jqXHR[ s.responseFields[ current ] ] = response;
            }
    
            // Apply the dataFilter if provided
            if ( !prev && isSuccess && s.dataFilter ) {
                response = s.dataFilter( response, s.dataType );
            }
    
            prev = current;
            current = dataTypes.shift();
    
            if ( current ) {
    
            // There's only work to do if current dataType is non-auto
                if ( current === "*" ) {
    
                    current = prev;
    
                // Convert response if prev dataType is non-auto and differs from current
                } else if ( prev !== "*" && prev !== current ) {
    
                    // Seek a direct converter
                    conv = converters[ prev + " " + current ] || converters[ "* " + current ];
    
                    // If none found, seek a pair
                    if ( !conv ) {
                        for ( conv2 in converters ) {
    
                            // If conv2 outputs current
                            tmp = conv2.split( " " );
                            if ( tmp[ 1 ] === current ) {
    
                                // If prev can be converted to accepted input
                                conv = converters[ prev + " " + tmp[ 0 ] ] ||
                                    converters[ "* " + tmp[ 0 ] ];
                                if ( conv ) {
    
                                    // Condense equivalence converters
                                    if ( conv === true ) {
                                        conv = converters[ conv2 ];
    
                                    // Otherwise, insert the intermediate dataType
                                    } else if ( converters[ conv2 ] !== true ) {
                                        current = tmp[ 0 ];
                                        dataTypes.unshift( tmp[ 1 ] );
                                    }
                                    break;
                                }
                            }
                        }
                    }
    
                    // Apply converter (if not an equivalence)
                    if ( conv !== true ) {
    
                        // Unless errors are allowed to bubble, catch and return them
                        if ( conv && s.throws ) {
                            response = conv( response );
                        } else {
                            try {
                                response = conv( response );
                            } catch ( e ) {
                                return {
                                    state: "parsererror",
                                    error: conv ? e : "No conversion from " + prev + " to " + current
                                };
                            }
                        }
                    }
                }
            }
        }
    
        return { state: "success", data: response };
    }
    
    jQuery.extend( {
    
        // Counter for holding the number of active queries
        active: 0,
    
        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},
    
        ajaxSettings: {
            url: location.href,
            type: "GET",
            isLocal: rlocalProtocol.test( location.protocol ),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            /*
            timeout: 0,
            data: null,
            dataType: null,
            username: null,
            password: null,
            cache: null,
            throws: false,
            traditional: false,
            headers: {},
            */
    
            accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
    
            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },
    
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
    
            // Data converters
            // Keys separate source (or catchall "*") and destination types with a single space
            converters: {
    
                // Convert anything to text
                "* text": String,
    
                // Text to html (true = no transformation)
                "text html": true,
    
                // Evaluate text as a json expression
                "text json": jQuery.parseJSON,
    
                // Parse text as xml
                "text xml": jQuery.parseXML
            },
    
            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
                url: true,
                context: true
            }
        },
    
        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function( target, settings ) {
            return settings ?
    
                // Building a settings object
                ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
    
                // Extending ajaxSettings
                ajaxExtend( jQuery.ajaxSettings, target );
        },
    
        ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
        ajaxTransport: addToPrefiltersOrTransports( transports ),
    
        // Main method
        ajax: function( url, options ) {
    
            // If url is an object, simulate pre-1.5 signature
            if ( typeof url === "object" ) {
                options = url;
                url = undefined;
            }
    
            // Force options to be an object
            options = options || {};
    
            var transport,
    
                // URL without anti-cache param
                cacheURL,
    
                // Response headers
                responseHeadersString,
                responseHeaders,
    
                // timeout handle
                timeoutTimer,
    
                // Url cleanup var
                urlAnchor,
    
                // To know if global events are to be dispatched
                fireGlobals,
    
                // Loop variable
                i,
    
                // Create the final options object
                s = jQuery.ajaxSetup( {}, options ),
    
                // Callbacks context
                callbackContext = s.context || s,
    
                // Context for global events is callbackContext if it is a DOM node or jQuery collection
                globalEventContext = s.context &&
                    ( callbackContext.nodeType || callbackContext.jquery ) ?
                        jQuery( callbackContext ) :
                        jQuery.event,
    
                // Deferreds
                deferred = jQuery.Deferred(),
                completeDeferred = jQuery.Callbacks( "once memory" ),
    
                // Status-dependent callbacks
                statusCode = s.statusCode || {},
    
                // Headers (they are sent all at once)
                requestHeaders = {},
                requestHeadersNames = {},
    
                // The jqXHR state
                state = 0,
    
                // Default abort message
                strAbort = "canceled",
    
                // Fake xhr
                jqXHR = {
                    readyState: 0,
    
                    // Builds headers hashtable if needed
                    getResponseHeader: function( key ) {
                        var match;
                        if ( state === 2 ) {
                            if ( !responseHeaders ) {
                                responseHeaders = {};
                                while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
                                    responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
                                }
                            }
                            match = responseHeaders[ key.toLowerCase() ];
                        }
                        return match == null ? null : match;
                    },
    
                    // Raw string
                    getAllResponseHeaders: function() {
                        return state === 2 ? responseHeadersString : null;
                    },
    
                    // Caches the header
                    setRequestHeader: function( name, value ) {
                        var lname = name.toLowerCase();
                        if ( !state ) {
                            name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
                            requestHeaders[ name ] = value;
                        }
                        return this;
                    },
    
                    // Overrides response content-type header
                    overrideMimeType: function( type ) {
                        if ( !state ) {
                            s.mimeType = type;
                        }
                        return this;
                    },
    
                    // Status-dependent callbacks
                    statusCode: function( map ) {
                        var code;
                        if ( map ) {
                            if ( state < 2 ) {
                                for ( code in map ) {
    
                                    // Lazy-add the new callback in a way that preserves old ones
                                    statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
                                }
                            } else {
    
                                // Execute the appropriate callbacks
                                jqXHR.always( map[ jqXHR.status ] );
                            }
                        }
                        return this;
                    },
    
                    // Cancel the request
                    abort: function( statusText ) {
                        var finalText = statusText || strAbort;
                        if ( transport ) {
                            transport.abort( finalText );
                        }
                        done( 0, finalText );
                        return this;
                    }
                };
    
            // Attach deferreds
            deferred.promise( jqXHR ).complete = completeDeferred.add;
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
    
            // Remove hash character (#7531: and string promotion)
            // Add protocol if not provided (prefilters might expect it)
            // Handle falsy url in the settings object (#10093: consistency with old signature)
            // We also use the url parameter if available
            s.url = ( ( url || s.url || location.href ) + "" ).replace( rhash, "" )
                .replace( rprotocol, location.protocol + "//" );
    
            // Alias method option to type as per ticket #12004
            s.type = options.method || options.type || s.method || s.type;
    
            // Extract dataTypes list
            s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];
    
            // A cross-domain request is in order when the origin doesn't match the current origin.
            if ( s.crossDomain == null ) {
                urlAnchor = document.createElement( "a" );
    
                // Support: IE8-11+
                // IE throws exception if url is malformed, e.g. http://example.com:80x/
                try {
                    urlAnchor.href = s.url;
    
                    // Support: IE8-11+
                    // Anchor's host property isn't correctly set when s.url is relative
                    urlAnchor.href = urlAnchor.href;
                    s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
                        urlAnchor.protocol + "//" + urlAnchor.host;
                } catch ( e ) {
    
                    // If there is an error parsing the URL, assume it is crossDomain,
                    // it can be rejected by the transport if it is invalid
                    s.crossDomain = true;
                }
            }
    
            // Convert data if not already a string
            if ( s.data && s.processData && typeof s.data !== "string" ) {
                s.data = jQuery.param( s.data, s.traditional );
            }
    
            // Apply prefilters
            inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
    
            // If request was aborted inside a prefilter, stop there
            if ( state === 2 ) {
                return jqXHR;
            }
    
            // We can fire global events as of now if asked to
            // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
            fireGlobals = jQuery.event && s.global;
    
            // Watch for a new set of requests
            if ( fireGlobals && jQuery.active++ === 0 ) {
                jQuery.event.trigger( "ajaxStart" );
            }
    
            // Uppercase the type
            s.type = s.type.toUpperCase();
    
            // Determine if request has content
            s.hasContent = !rnoContent.test( s.type );
    
            // Save the URL in case we're toying with the If-Modified-Since
            // and/or If-None-Match header later on
            cacheURL = s.url;
    
            // More options handling for requests with no content
            if ( !s.hasContent ) {
    
                // If data is available, append data to url
                if ( s.data ) {
                    cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
    
                    // #9682: remove data so that it's not used in an eventual retry
                    delete s.data;
                }
    
                // Add anti-cache in url if needed
                if ( s.cache === false ) {
                    s.url = rts.test( cacheURL ) ?
    
                        // If there is already a '_' parameter, set its value
                        cacheURL.replace( rts, "$1_=" + nonce++ ) :
    
                        // Otherwise add one to the end
                        cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
                }
            }
    
            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if ( s.ifModified ) {
                if ( jQuery.lastModified[ cacheURL ] ) {
                    jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
                }
                if ( jQuery.etag[ cacheURL ] ) {
                    jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
                }
            }
    
            // Set the correct header, if data is being sent
            if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
                jqXHR.setRequestHeader( "Content-Type", s.contentType );
            }
    
            // Set the Accepts header for the server, depending on the dataType
            jqXHR.setRequestHeader(
                "Accept",
                s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
                    s.accepts[ s.dataTypes[ 0 ] ] +
                        ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
                    s.accepts[ "*" ]
            );
    
            // Check for headers option
            for ( i in s.headers ) {
                jqXHR.setRequestHeader( i, s.headers[ i ] );
            }
    
            // Allow custom headers/mimetypes and early abort
            if ( s.beforeSend &&
                ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
    
                // Abort if not done already and return
                return jqXHR.abort();
            }
    
            // Aborting is no longer a cancellation
            strAbort = "abort";
    
            // Install callbacks on deferreds
            for ( i in { success: 1, error: 1, complete: 1 } ) {
                jqXHR[ i ]( s[ i ] );
            }
    
            // Get transport
            transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
    
            // If no transport, we auto-abort
            if ( !transport ) {
                done( -1, "No Transport" );
            } else {
                jqXHR.readyState = 1;
    
                // Send global event
                if ( fireGlobals ) {
                    globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
                }
    
                // If request was aborted inside ajaxSend, stop there
                if ( state === 2 ) {
                    return jqXHR;
                }
    
                // Timeout
                if ( s.async && s.timeout > 0 ) {
                    timeoutTimer = window.setTimeout( function() {
                        jqXHR.abort( "timeout" );
                    }, s.timeout );
                }
    
                try {
                    state = 1;
                    transport.send( requestHeaders, done );
                } catch ( e ) {
    
                    // Propagate exception as error if not done
                    if ( state < 2 ) {
                        done( -1, e );
    
                    // Simply rethrow otherwise
                    } else {
                        throw e;
                    }
                }
            }
    
            // Callback for when everything is done
            function done( status, nativeStatusText, responses, headers ) {
                var isSuccess, success, error, response, modified,
                    statusText = nativeStatusText;
    
                // Called once
                if ( state === 2 ) {
                    return;
                }
    
                // State is "done" now
                state = 2;
    
                // Clear timeout if it exists
                if ( timeoutTimer ) {
                    window.clearTimeout( timeoutTimer );
                }
    
                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined;
    
                // Cache response headers
                responseHeadersString = headers || "";
    
                // Set readyState
                jqXHR.readyState = status > 0 ? 4 : 0;
    
                // Determine if successful
                isSuccess = status >= 200 && status < 300 || status === 304;
    
                // Get response data
                if ( responses ) {
                    response = ajaxHandleResponses( s, jqXHR, responses );
                }
    
                // Convert no matter what (that way responseXXX fields are always set)
                response = ajaxConvert( s, response, jqXHR, isSuccess );
    
                // If successful, handle type chaining
                if ( isSuccess ) {
    
                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if ( s.ifModified ) {
                        modified = jqXHR.getResponseHeader( "Last-Modified" );
                        if ( modified ) {
                            jQuery.lastModified[ cacheURL ] = modified;
                        }
                        modified = jqXHR.getResponseHeader( "etag" );
                        if ( modified ) {
                            jQuery.etag[ cacheURL ] = modified;
                        }
                    }
    
                    // if no content
                    if ( status === 204 || s.type === "HEAD" ) {
                        statusText = "nocontent";
    
                    // if not modified
                    } else if ( status === 304 ) {
                        statusText = "notmodified";
    
                    // If we have data, let's convert it
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {
    
                    // Extract error from statusText and normalize for non-aborts
                    error = statusText;
                    if ( status || !statusText ) {
                        statusText = "error";
                        if ( status < 0 ) {
                            status = 0;
                        }
                    }
                }
    
                // Set data for the fake xhr object
                jqXHR.status = status;
                jqXHR.statusText = ( nativeStatusText || statusText ) + "";
    
                // Success/Error
                if ( isSuccess ) {
                    deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
                } else {
                    deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
                }
    
                // Status-dependent callbacks
                jqXHR.statusCode( statusCode );
                statusCode = undefined;
    
                if ( fireGlobals ) {
                    globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
                        [ jqXHR, s, isSuccess ? success : error ] );
                }
    
                // Complete
                completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
    
                if ( fireGlobals ) {
                    globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
    
                    // Handle the global AJAX counter
                    if ( !( --jQuery.active ) ) {
                        jQuery.event.trigger( "ajaxStop" );
                    }
                }
            }
    
            return jqXHR;
        },
    
        getJSON: function( url, data, callback ) {
            return jQuery.get( url, data, callback, "json" );
        },
    
        getScript: function( url, callback ) {
            return jQuery.get( url, undefined, callback, "script" );
        }
    } );
    
    jQuery.each( [ "get", "post" ], function( i, method ) {
        jQuery[ method ] = function( url, data, callback, type ) {
    
            // Shift arguments if data argument was omitted
            if ( jQuery.isFunction( data ) ) {
                type = type || callback;
                callback = data;
                data = undefined;
            }
    
            // The url can be an options object (which then must have .url)
            return jQuery.ajax( jQuery.extend( {
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            }, jQuery.isPlainObject( url ) && url ) );
        };
    } );
    
    
    jQuery._evalUrl = function( url ) {
        return jQuery.ajax( {
            url: url,
    
            // Make this explicit, since user can override this through ajaxSetup (#11264)
            type: "GET",
            dataType: "script",
            async: false,
            global: false,
            "throws": true
        } );
    };
    
    
    jQuery.fn.extend( {
        wrapAll: function( html ) {
            var wrap;
    
            if ( jQuery.isFunction( html ) ) {
                return this.each( function( i ) {
                    jQuery( this ).wrapAll( html.call( this, i ) );
                } );
            }
    
            if ( this[ 0 ] ) {
    
                // The elements to wrap the target around
                wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );
    
                if ( this[ 0 ].parentNode ) {
                    wrap.insertBefore( this[ 0 ] );
                }
    
                wrap.map( function() {
                    var elem = this;
    
                    while ( elem.firstElementChild ) {
                        elem = elem.firstElementChild;
                    }
    
                    return elem;
                } ).append( this );
            }
    
            return this;
        },
    
        wrapInner: function( html ) {
            if ( jQuery.isFunction( html ) ) {
                return this.each( function( i ) {
                    jQuery( this ).wrapInner( html.call( this, i ) );
                } );
            }
    
            return this.each( function() {
                var self = jQuery( this ),
                    contents = self.contents();
    
                if ( contents.length ) {
                    contents.wrapAll( html );
    
                } else {
                    self.append( html );
                }
            } );
        },
    
        wrap: function( html ) {
            var isFunction = jQuery.isFunction( html );
    
            return this.each( function( i ) {
                jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
            } );
        },
    
        unwrap: function() {
            return this.parent().each( function() {
                if ( !jQuery.nodeName( this, "body" ) ) {
                    jQuery( this ).replaceWith( this.childNodes );
                }
            } ).end();
        }
    } );
    
    
    jQuery.expr.filters.hidden = function( elem ) {
        return !jQuery.expr.filters.visible( elem );
    };
    jQuery.expr.filters.visible = function( elem ) {
    
        // Support: Opera <= 12.12
        // Opera reports offsetWidths and offsetHeights less than zero on some elements
        // Use OR instead of AND as the element is not visible if either is true
        // See tickets #10406 and #13132
        return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
    };
    
    
    
    
    var r20 = /%20/g,
        rbracket = /\[\]$/,
        rCRLF = /\r?\n/g,
        rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
        rsubmittable = /^(?:input|select|textarea|keygen)/i;
    
    function buildParams( prefix, obj, traditional, add ) {
        var name;
    
        if ( jQuery.isArray( obj ) ) {
    
            // Serialize array item.
            jQuery.each( obj, function( i, v ) {
                if ( traditional || rbracket.test( prefix ) ) {
    
                    // Treat each array item as a scalar.
                    add( prefix, v );
    
                } else {
    
                    // Item is non-scalar (array or object), encode its numeric index.
                    buildParams(
                        prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
                        v,
                        traditional,
                        add
                    );
                }
            } );
    
        } else if ( !traditional && jQuery.type( obj ) === "object" ) {
    
            // Serialize object item.
            for ( name in obj ) {
                buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
            }
    
        } else {
    
            // Serialize scalar item.
            add( prefix, obj );
        }
    }
    
    // Serialize an array of form elements or a set of
    // key/values into a query string
    jQuery.param = function( a, traditional ) {
        var prefix,
            s = [],
            add = function( key, value ) {
    
                // If value is a function, invoke it and return its value
                value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
                s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
            };
    
        // Set traditional to true for jQuery <= 1.3.2 behavior.
        if ( traditional === undefined ) {
            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
        }
    
        // If an array was passed in, assume that it is an array of form elements.
        if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
    
            // Serialize the form elements
            jQuery.each( a, function() {
                add( this.name, this.value );
            } );
    
        } else {
    
            // If traditional, encode the "old" way (the way 1.3.2 or older
            // did it), otherwise encode params recursively.
            for ( prefix in a ) {
                buildParams( prefix, a[ prefix ], traditional, add );
            }
        }
    
        // Return the resulting serialization
        return s.join( "&" ).replace( r20, "+" );
    };
    
    jQuery.fn.extend( {
        serialize: function() {
            return jQuery.param( this.serializeArray() );
        },
        serializeArray: function() {
            return this.map( function() {
    
                // Can add propHook for "elements" to filter or add form elements
                var elements = jQuery.prop( this, "elements" );
                return elements ? jQuery.makeArray( elements ) : this;
            } )
            .filter( function() {
                var type = this.type;
    
                // Use .is( ":disabled" ) so that fieldset[disabled] works
                return this.name && !jQuery( this ).is( ":disabled" ) &&
                    rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
                    ( this.checked || !rcheckableType.test( type ) );
            } )
            .map( function( i, elem ) {
                var val = jQuery( this ).val();
    
                return val == null ?
                    null :
                    jQuery.isArray( val ) ?
                        jQuery.map( val, function( val ) {
                            return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                        } ) :
                        { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
            } ).get();
        }
    } );
    
    
    jQuery.ajaxSettings.xhr = function() {
        try {
            return new window.XMLHttpRequest();
        } catch ( e ) {}
    };
    
    var xhrSuccessStatus = {
    
            // File protocol always yields status code 0, assume 200
            0: 200,
    
            // Support: IE9
            // #1450: sometimes IE returns 1223 when it should be 204
            1223: 204
        },
        xhrSupported = jQuery.ajaxSettings.xhr();
    
    support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
    support.ajax = xhrSupported = !!xhrSupported;
    
    jQuery.ajaxTransport( function( options ) {
        var callback, errorCallback;
    
        // Cross domain only allowed if supported through XMLHttpRequest
        if ( support.cors || xhrSupported && !options.crossDomain ) {
            return {
                send: function( headers, complete ) {
                    var i,
                        xhr = options.xhr();
    
                    xhr.open(
                        options.type,
                        options.url,
                        options.async,
                        options.username,
                        options.password
                    );
    
                    // Apply custom fields if provided
                    if ( options.xhrFields ) {
                        for ( i in options.xhrFields ) {
                            xhr[ i ] = options.xhrFields[ i ];
                        }
                    }
    
                    // Override mime type if needed
                    if ( options.mimeType && xhr.overrideMimeType ) {
                        xhr.overrideMimeType( options.mimeType );
                    }
    
                    // X-Requested-With header
                    // For cross-domain requests, seeing as conditions for a preflight are
                    // akin to a jigsaw puzzle, we simply never set it to be sure.
                    // (it can always be set on a per-request basis or even using ajaxSetup)
                    // For same-domain requests, won't change header if already provided.
                    if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
                        headers[ "X-Requested-With" ] = "XMLHttpRequest";
                    }
    
                    // Set headers
                    for ( i in headers ) {
                        xhr.setRequestHeader( i, headers[ i ] );
                    }
    
                    // Callback
                    callback = function( type ) {
                        return function() {
                            if ( callback ) {
                                callback = errorCallback = xhr.onload =
                                    xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
    
                                if ( type === "abort" ) {
                                    xhr.abort();
                                } else if ( type === "error" ) {
    
                                    // Support: IE9
                                    // On a manual native abort, IE9 throws
                                    // errors on any property access that is not readyState
                                    if ( typeof xhr.status !== "number" ) {
                                        complete( 0, "error" );
                                    } else {
                                        complete(
    
                                            // File: protocol always yields status 0; see #8605, #14207
                                            xhr.status,
                                            xhr.statusText
                                        );
                                    }
                                } else {
                                    complete(
                                        xhrSuccessStatus[ xhr.status ] || xhr.status,
                                        xhr.statusText,
    
                                        // Support: IE9 only
                                        // IE9 has no XHR2 but throws on binary (trac-11426)
                                        // For XHR2 non-text, let the caller handle it (gh-2498)
                                        ( xhr.responseType || "text" ) !== "text"  ||
                                        typeof xhr.responseText !== "string" ?
                                            { binary: xhr.response } :
                                            { text: xhr.responseText },
                                        xhr.getAllResponseHeaders()
                                    );
                                }
                            }
                        };
                    };
    
                    // Listen to events
                    xhr.onload = callback();
                    errorCallback = xhr.onerror = callback( "error" );
    
                    // Support: IE9
                    // Use onreadystatechange to replace onabort
                    // to handle uncaught aborts
                    if ( xhr.onabort !== undefined ) {
                        xhr.onabort = errorCallback;
                    } else {
                        xhr.onreadystatechange = function() {
    
                            // Check readyState before timeout as it changes
                            if ( xhr.readyState === 4 ) {
    
                                // Allow onerror to be called first,
                                // but that will not handle a native abort
                                // Also, save errorCallback to a variable
                                // as xhr.onerror cannot be accessed
                                window.setTimeout( function() {
                                    if ( callback ) {
                                        errorCallback();
                                    }
                                } );
                            }
                        };
                    }
    
                    // Create the abort callback
                    callback = callback( "abort" );
    
                    try {
    
                        // Do send the request (this may raise an exception)
                        xhr.send( options.hasContent && options.data || null );
                    } catch ( e ) {
    
                        // #14683: Only rethrow if this hasn't been notified as an error yet
                        if ( callback ) {
                            throw e;
                        }
                    }
                },
    
                abort: function() {
                    if ( callback ) {
                        callback();
                    }
                }
            };
        }
    } );
    
    
    
    
    // Install script dataType
    jQuery.ajaxSetup( {
        accepts: {
            script: "text/javascript, application/javascript, " +
                "application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /\b(?:java|ecma)script\b/
        },
        converters: {
            "text script": function( text ) {
                jQuery.globalEval( text );
                return text;
            }
        }
    } );
    
    // Handle cache's special case and crossDomain
    jQuery.ajaxPrefilter( "script", function( s ) {
        if ( s.cache === undefined ) {
            s.cache = false;
        }
        if ( s.crossDomain ) {
            s.type = "GET";
        }
    } );
    
    // Bind script tag hack transport
    jQuery.ajaxTransport( "script", function( s ) {
    
        // This transport only deals with cross domain requests
        if ( s.crossDomain ) {
            var script, callback;
            return {
                send: function( _, complete ) {
                    script = jQuery( "<script>" ).prop( {
                        charset: s.scriptCharset,
                        src: s.url
                    } ).on(
                        "load error",
                        callback = function( evt ) {
                            script.remove();
                            callback = null;
                            if ( evt ) {
                                complete( evt.type === "error" ? 404 : 200, evt.type );
                            }
                        }
                    );
    
                    // Use native DOM manipulation to avoid our domManip AJAX trickery
                    document.head.appendChild( script[ 0 ] );
                },
                abort: function() {
                    if ( callback ) {
                        callback();
                    }
                }
            };
        }
    } );
    
    
    
    
    var oldCallbacks = [],
        rjsonp = /(=)\?(?=&|$)|\?\?/;
    
    // Default jsonp settings
    jQuery.ajaxSetup( {
        jsonp: "callback",
        jsonpCallback: function() {
            var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
            this[ callback ] = true;
            return callback;
        }
    } );
    
    // Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
    
        var callbackName, overwritten, responseContainer,
            jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
                "url" :
                typeof s.data === "string" &&
                    ( s.contentType || "" )
                        .indexOf( "application/x-www-form-urlencoded" ) === 0 &&
                    rjsonp.test( s.data ) && "data"
            );
    
        // Handle iff the expected data type is "jsonp" or we have a parameter to set
        if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {
    
            // Get callback name, remembering preexisting value associated with it
            callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
                s.jsonpCallback() :
                s.jsonpCallback;
    
            // Insert callback into url or form data
            if ( jsonProp ) {
                s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
            } else if ( s.jsonp !== false ) {
                s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
            }
    
            // Use data converter to retrieve json after script execution
            s.converters[ "script json" ] = function() {
                if ( !responseContainer ) {
                    jQuery.error( callbackName + " was not called" );
                }
                return responseContainer[ 0 ];
            };
    
            // Force json dataType
            s.dataTypes[ 0 ] = "json";
    
            // Install callback
            overwritten = window[ callbackName ];
            window[ callbackName ] = function() {
                responseContainer = arguments;
            };
    
            // Clean-up function (fires after converters)
            jqXHR.always( function() {
    
                // If previous value didn't exist - remove it
                if ( overwritten === undefined ) {
                    jQuery( window ).removeProp( callbackName );
    
                // Otherwise restore preexisting value
                } else {
                    window[ callbackName ] = overwritten;
                }
    
                // Save back as free
                if ( s[ callbackName ] ) {
    
                    // Make sure that re-using the options doesn't screw things around
                    s.jsonpCallback = originalSettings.jsonpCallback;
    
                    // Save the callback name for future use
                    oldCallbacks.push( callbackName );
                }
    
                // Call if it was a function and we have a response
                if ( responseContainer && jQuery.isFunction( overwritten ) ) {
                    overwritten( responseContainer[ 0 ] );
                }
    
                responseContainer = overwritten = undefined;
            } );
    
            // Delegate to script
            return "script";
        }
    } );
    
    
    
    
    // Argument "data" should be string of html
    // context (optional): If specified, the fragment will be created in this context,
    // defaults to document
    // keepScripts (optional): If true, will include scripts passed in the html string
    jQuery.parseHTML = function( data, context, keepScripts ) {
        if ( !data || typeof data !== "string" ) {
            return null;
        }
        if ( typeof context === "boolean" ) {
            keepScripts = context;
            context = false;
        }
        context = context || document;
    
        var parsed = rsingleTag.exec( data ),
            scripts = !keepScripts && [];
    
        // Single tag
        if ( parsed ) {
            return [ context.createElement( parsed[ 1 ] ) ];
        }
    
        parsed = buildFragment( [ data ], context, scripts );
    
        if ( scripts && scripts.length ) {
            jQuery( scripts ).remove();
        }
    
        return jQuery.merge( [], parsed.childNodes );
    };
    
    
    // Keep a copy of the old load method
    var _load = jQuery.fn.load;
    
    /**
     * Load a url into a page
     */
    jQuery.fn.load = function( url, params, callback ) {
        if ( typeof url !== "string" && _load ) {
            return _load.apply( this, arguments );
        }
    
        var selector, type, response,
            self = this,
            off = url.indexOf( " " );
    
        if ( off > -1 ) {
            selector = jQuery.trim( url.slice( off ) );
            url = url.slice( 0, off );
        }
    
        // If it's a function
        if ( jQuery.isFunction( params ) ) {
    
            // We assume that it's the callback
            callback = params;
            params = undefined;
    
        // Otherwise, build a param string
        } else if ( params && typeof params === "object" ) {
            type = "POST";
        }
    
        // If we have elements to modify, make the request
        if ( self.length > 0 ) {
            jQuery.ajax( {
                url: url,
    
                // If "type" variable is undefined, then "GET" method will be used.
                // Make value of this field explicit since
                // user can override it through ajaxSetup method
                type: type || "GET",
                dataType: "html",
                data: params
            } ).done( function( responseText ) {
    
                // Save response for use in complete callback
                response = arguments;
    
                self.html( selector ?
    
                    // If a selector was specified, locate the right elements in a dummy div
                    // Exclude scripts to avoid IE 'Permission Denied' errors
                    jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :
    
                    // Otherwise use the full result
                    responseText );
    
            // If the request succeeds, this function gets "data", "status", "jqXHR"
            // but they are ignored because response was set above.
            // If it fails, this function gets "jqXHR", "status", "error"
            } ).always( callback && function( jqXHR, status ) {
                self.each( function() {
                    callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
                } );
            } );
        }
    
        return this;
    };
    
    
    
    
    // Attach a bunch of functions for handling common AJAX events
    jQuery.each( [
        "ajaxStart",
        "ajaxStop",
        "ajaxComplete",
        "ajaxError",
        "ajaxSuccess",
        "ajaxSend"
    ], function( i, type ) {
        jQuery.fn[ type ] = function( fn ) {
            return this.on( type, fn );
        };
    } );
    
    
    
    
    jQuery.expr.filters.animated = function( elem ) {
        return jQuery.grep( jQuery.timers, function( fn ) {
            return elem === fn.elem;
        } ).length;
    };
    
    
    
    
    /**
     * Gets a window from an element
     */
    function getWindow( elem ) {
        return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
    }
    
    jQuery.offset = {
        setOffset: function( elem, options, i ) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
                position = jQuery.css( elem, "position" ),
                curElem = jQuery( elem ),
                props = {};
    
            // Set position first, in-case top/left are set even on static elem
            if ( position === "static" ) {
                elem.style.position = "relative";
            }
    
            curOffset = curElem.offset();
            curCSSTop = jQuery.css( elem, "top" );
            curCSSLeft = jQuery.css( elem, "left" );
            calculatePosition = ( position === "absolute" || position === "fixed" ) &&
                ( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;
    
            // Need to be able to calculate position if either
            // top or left is auto and position is either absolute or fixed
            if ( calculatePosition ) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
    
            } else {
                curTop = parseFloat( curCSSTop ) || 0;
                curLeft = parseFloat( curCSSLeft ) || 0;
            }
    
            if ( jQuery.isFunction( options ) ) {
    
                // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
                options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
            }
    
            if ( options.top != null ) {
                props.top = ( options.top - curOffset.top ) + curTop;
            }
            if ( options.left != null ) {
                props.left = ( options.left - curOffset.left ) + curLeft;
            }
    
            if ( "using" in options ) {
                options.using.call( elem, props );
    
            } else {
                curElem.css( props );
            }
        }
    };
    
    jQuery.fn.extend( {
        offset: function( options ) {
            if ( arguments.length ) {
                return options === undefined ?
                    this :
                    this.each( function( i ) {
                        jQuery.offset.setOffset( this, options, i );
                    } );
            }
    
            var docElem, win,
                elem = this[ 0 ],
                box = { top: 0, left: 0 },
                doc = elem && elem.ownerDocument;
    
            if ( !doc ) {
                return;
            }
    
            docElem = doc.documentElement;
    
            // Make sure it's not a disconnected DOM node
            if ( !jQuery.contains( docElem, elem ) ) {
                return box;
            }
    
            box = elem.getBoundingClientRect();
            win = getWindow( doc );
            return {
                top: box.top + win.pageYOffset - docElem.clientTop,
                left: box.left + win.pageXOffset - docElem.clientLeft
            };
        },
    
        position: function() {
            if ( !this[ 0 ] ) {
                return;
            }
    
            var offsetParent, offset,
                elem = this[ 0 ],
                parentOffset = { top: 0, left: 0 };
    
            // Fixed elements are offset from window (parentOffset = {top:0, left: 0},
            // because it is its only offset parent
            if ( jQuery.css( elem, "position" ) === "fixed" ) {
    
                // Assume getBoundingClientRect is there when computed position is fixed
                offset = elem.getBoundingClientRect();
    
            } else {
    
                // Get *real* offsetParent
                offsetParent = this.offsetParent();
    
                // Get correct offsets
                offset = this.offset();
                if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
                    parentOffset = offsetParent.offset();
                }
    
                // Add offsetParent borders
                parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
                parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
            }
    
            // Subtract parent offsets and element margins
            return {
                top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
                left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
            };
        },
    
        // This method will return documentElement in the following cases:
        // 1) For the element inside the iframe without offsetParent, this method will return
        //    documentElement of the parent window
        // 2) For the hidden or detached element
        // 3) For body or html element, i.e. in case of the html node - it will return itself
        //
        // but those exceptions were never presented as a real life use-cases
        // and might be considered as more preferable results.
        //
        // This logic, however, is not guaranteed and can change at any point in the future
        offsetParent: function() {
            return this.map( function() {
                var offsetParent = this.offsetParent;
    
                while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
                    offsetParent = offsetParent.offsetParent;
                }
    
                return offsetParent || documentElement;
            } );
        }
    } );
    
    // Create scrollLeft and scrollTop methods
    jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
        var top = "pageYOffset" === prop;
    
        jQuery.fn[ method ] = function( val ) {
            return access( this, function( elem, method, val ) {
                var win = getWindow( elem );
    
                if ( val === undefined ) {
                    return win ? win[ prop ] : elem[ method ];
                }
    
                if ( win ) {
                    win.scrollTo(
                        !top ? val : win.pageXOffset,
                        top ? val : win.pageYOffset
                    );
    
                } else {
                    elem[ method ] = val;
                }
            }, method, val, arguments.length );
        };
    } );
    
    // Support: Safari<7-8+, Chrome<37-44+
    // Add the top/left cssHooks using jQuery.fn.position
    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
    // Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
    // getComputedStyle returns percent when specified for top/left/bottom/right;
    // rather than make the css module depend on the offset module, just check for it here
    jQuery.each( [ "top", "left" ], function( i, prop ) {
        jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
            function( elem, computed ) {
                if ( computed ) {
                    computed = curCSS( elem, prop );
    
                    // If curCSS returns percentage, fallback to offset
                    return rnumnonpx.test( computed ) ?
                        jQuery( elem ).position()[ prop ] + "px" :
                        computed;
                }
            }
        );
    } );
    
    
    // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
    jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
        jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
            function( defaultExtra, funcName ) {
    
            // Margin is only for outerHeight, outerWidth
            jQuery.fn[ funcName ] = function( margin, value ) {
                var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
                    extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );
    
                return access( this, function( elem, type, value ) {
                    var doc;
    
                    if ( jQuery.isWindow( elem ) ) {
    
                        // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                        // isn't a whole lot we can do. See pull request at this URL for discussion:
                        // https://github.com/jquery/jquery/pull/764
                        return elem.document.documentElement[ "client" + name ];
                    }
    
                    // Get document width or height
                    if ( elem.nodeType === 9 ) {
                        doc = elem.documentElement;
    
                        // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                        // whichever is greatest
                        return Math.max(
                            elem.body[ "scroll" + name ], doc[ "scroll" + name ],
                            elem.body[ "offset" + name ], doc[ "offset" + name ],
                            doc[ "client" + name ]
                        );
                    }
    
                    return value === undefined ?
    
                        // Get width or height on the element, requesting but not forcing parseFloat
                        jQuery.css( elem, type, extra ) :
    
                        // Set width or height on the element
                        jQuery.style( elem, type, value, extra );
                }, type, chainable ? margin : undefined, chainable, null );
            };
        } );
    } );
    
    
    jQuery.fn.extend( {
    
        bind: function( types, data, fn ) {
            return this.on( types, null, data, fn );
        },
        unbind: function( types, fn ) {
            return this.off( types, null, fn );
        },
    
        delegate: function( selector, types, data, fn ) {
            return this.on( types, selector, data, fn );
        },
        undelegate: function( selector, types, fn ) {
    
            // ( namespace ) or ( selector, types [, fn] )
            return arguments.length === 1 ?
                this.off( selector, "**" ) :
                this.off( types, selector || "**", fn );
        },
        size: function() {
            return this.length;
        }
    } );
    
    jQuery.fn.andSelf = jQuery.fn.addBack;
    
    
    
    
    // Register as a named AMD module, since jQuery can be concatenated with other
    // files that may use define, but not via a proper concatenation script that
    // understands anonymous AMD modules. A named AMD is safest and most robust
    // way to register. Lowercase jquery is used because AMD module names are
    // derived from file names, and jQuery is normally delivered in a lowercase
    // file name. Do this after creating the global so that if an AMD module wants
    // to call noConflict to hide this version of jQuery, it will work.
    
    // Note that for maximum portability, libraries that are not jQuery should
    // declare themselves as anonymous modules, and avoid setting a global if an
    // AMD loader is present. jQuery is a special case. For more information, see
    // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
    
    if ( typeof define === "function" && define.amd ) {
        define( "jquery", [], function() {
            return jQuery;
        } );
    }
    
    
    
    var
    
        // Map over jQuery in case of overwrite
        _jQuery = window.jQuery,
    
        // Map over the $ in case of overwrite
        _$ = window.$;
    
    jQuery.noConflict = function( deep ) {
        if ( window.$ === jQuery ) {
            window.$ = _$;
        }
    
        if ( deep && window.jQuery === jQuery ) {
            window.jQuery = _jQuery;
        }
    
        return jQuery;
    };
    
    // Expose jQuery and $ identifiers, even in AMD
    // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
    // and CommonJS for browser emulators (#13566)
    if ( !noGlobal ) {
        window.jQuery = window.$ = jQuery;
    }
    
    return jQuery;
    }));
    
    },{}],61:[function(require,module,exports){
    /*!
     * jQuery UI Widget 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Widget
    //>>group: Core
    //>>description: Provides a factory for creating stateful widgets with a common API.
    //>>docs: http://api.jqueryui.com/jQuery.widget/
    //>>demos: http://jqueryui.com/widget/
    
    ( function( factory ) {
        if ( typeof define === "function" && define.amd ) {
    
            // AMD. Register as an anonymous module.
            define( [ "jquery", "./version" ], factory );
        } else {
    
            // Browser globals
            factory( jQuery );
        }
    }( function( $ ) {
    
    var widgetUuid = 0;
    var widgetSlice = Array.prototype.slice;
    
    $.cleanData = ( function( orig ) {
        return function( elems ) {
            var events, elem, i;
            for ( i = 0; ( elem = elems[ i ] ) != null; i++ ) {
                try {
    
                    // Only trigger remove when necessary to save time
                    events = $._data( elem, "events" );
                    if ( events && events.remove ) {
                        $( elem ).triggerHandler( "remove" );
                    }
    
                // Http://bugs.jquery.com/ticket/8235
                } catch ( e ) {}
            }
            orig( elems );
        };
    } )( $.cleanData );
    
    $.widget = function( name, base, prototype ) {
        var existingConstructor, constructor, basePrototype;
    
        // ProxiedPrototype allows the provided prototype to remain unmodified
        // so that it can be used as a mixin for multiple widgets (#8876)
        var proxiedPrototype = {};
    
        var namespace = name.split( "." )[ 0 ];
        name = name.split( "." )[ 1 ];
        var fullName = namespace + "-" + name;
    
        if ( !prototype ) {
            prototype = base;
            base = $.Widget;
        }
    
        if ( $.isArray( prototype ) ) {
            prototype = $.extend.apply( null, [ {} ].concat( prototype ) );
        }
    
        // Create selector for plugin
        $.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
            return !!$.data( elem, fullName );
        };
    
        $[ namespace ] = $[ namespace ] || {};
        existingConstructor = $[ namespace ][ name ];
        constructor = $[ namespace ][ name ] = function( options, element ) {
    
            // Allow instantiation without "new" keyword
            if ( !this._createWidget ) {
                return new constructor( options, element );
            }
    
            // Allow instantiation without initializing for simple inheritance
            // must use "new" keyword (the code above always passes args)
            if ( arguments.length ) {
                this._createWidget( options, element );
            }
        };
    
        // Extend with the existing constructor to carry over any static properties
        $.extend( constructor, existingConstructor, {
            version: prototype.version,
    
            // Copy the object used to create the prototype in case we need to
            // redefine the widget later
            _proto: $.extend( {}, prototype ),
    
            // Track widgets that inherit from this widget in case this widget is
            // redefined after a widget inherits from it
            _childConstructors: []
        } );
    
        basePrototype = new base();
    
        // We need to make the options hash a property directly on the new instance
        // otherwise we'll modify the options hash on the prototype that we're
        // inheriting from
        basePrototype.options = $.widget.extend( {}, basePrototype.options );
        $.each( prototype, function( prop, value ) {
            if ( !$.isFunction( value ) ) {
                proxiedPrototype[ prop ] = value;
                return;
            }
            proxiedPrototype[ prop ] = ( function() {
                function _super() {
                    return base.prototype[ prop ].apply( this, arguments );
                }
    
                function _superApply( args ) {
                    return base.prototype[ prop ].apply( this, args );
                }
    
                return function() {
                    var __super = this._super;
                    var __superApply = this._superApply;
                    var returnValue;
    
                    this._super = _super;
                    this._superApply = _superApply;
    
                    returnValue = value.apply( this, arguments );
    
                    this._super = __super;
                    this._superApply = __superApply;
    
                    return returnValue;
                };
            } )();
        } );
        constructor.prototype = $.widget.extend( basePrototype, {
    
            // TODO: remove support for widgetEventPrefix
            // always use the name + a colon as the prefix, e.g., draggable:start
            // don't prefix for widgets that aren't DOM-based
            widgetEventPrefix: existingConstructor ? ( basePrototype.widgetEventPrefix || name ) : name
        }, proxiedPrototype, {
            constructor: constructor,
            namespace: namespace,
            widgetName: name,
            widgetFullName: fullName
        } );
    
        // If this widget is being redefined then we need to find all widgets that
        // are inheriting from it and redefine all of them so that they inherit from
        // the new version of this widget. We're essentially trying to replace one
        // level in the prototype chain.
        if ( existingConstructor ) {
            $.each( existingConstructor._childConstructors, function( i, child ) {
                var childPrototype = child.prototype;
    
                // Redefine the child widget using the same prototype that was
                // originally used, but inherit from the new version of the base
                $.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor,
                    child._proto );
            } );
    
            // Remove the list of existing child constructors from the old constructor
            // so the old child constructors can be garbage collected
            delete existingConstructor._childConstructors;
        } else {
            base._childConstructors.push( constructor );
        }
    
        $.widget.bridge( name, constructor );
    
        return constructor;
    };
    
    $.widget.extend = function( target ) {
        var input = widgetSlice.call( arguments, 1 );
        var inputIndex = 0;
        var inputLength = input.length;
        var key;
        var value;
    
        for ( ; inputIndex < inputLength; inputIndex++ ) {
            for ( key in input[ inputIndex ] ) {
                value = input[ inputIndex ][ key ];
                if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
    
                    // Clone objects
                    if ( $.isPlainObject( value ) ) {
                        target[ key ] = $.isPlainObject( target[ key ] ) ?
                            $.widget.extend( {}, target[ key ], value ) :
    
                            // Don't extend strings, arrays, etc. with objects
                            $.widget.extend( {}, value );
    
                    // Copy everything else by reference
                    } else {
                        target[ key ] = value;
                    }
                }
            }
        }
        return target;
    };
    
    $.widget.bridge = function( name, object ) {
        var fullName = object.prototype.widgetFullName || name;
        $.fn[ name ] = function( options ) {
            var isMethodCall = typeof options === "string";
            var args = widgetSlice.call( arguments, 1 );
            var returnValue = this;
    
            if ( isMethodCall ) {
    
                // If this is an empty collection, we need to have the instance method
                // return undefined instead of the jQuery instance
                if ( !this.length && options === "instance" ) {
                    returnValue = undefined;
                } else {
                    this.each( function() {
                        var methodValue;
                        var instance = $.data( this, fullName );
    
                        if ( options === "instance" ) {
                            returnValue = instance;
                            return false;
                        }
    
                        if ( !instance ) {
                            return $.error( "cannot call methods on " + name +
                                " prior to initialization; " +
                                "attempted to call method '" + options + "'" );
                        }
    
                        if ( !$.isFunction( instance[ options ] ) || options.charAt( 0 ) === "_" ) {
                            return $.error( "no such method '" + options + "' for " + name +
                                " widget instance" );
                        }
    
                        methodValue = instance[ options ].apply( instance, args );
    
                        if ( methodValue !== instance && methodValue !== undefined ) {
                            returnValue = methodValue && methodValue.jquery ?
                                returnValue.pushStack( methodValue.get() ) :
                                methodValue;
                            return false;
                        }
                    } );
                }
            } else {
    
                // Allow multiple hashes to be passed on init
                if ( args.length ) {
                    options = $.widget.extend.apply( null, [ options ].concat( args ) );
                }
    
                this.each( function() {
                    var instance = $.data( this, fullName );
                    if ( instance ) {
                        instance.option( options || {} );
                        if ( instance._init ) {
                            instance._init();
                        }
                    } else {
                        $.data( this, fullName, new object( options, this ) );
                    }
                } );
            }
    
            return returnValue;
        };
    };
    
    $.Widget = function( /* options, element */ ) {};
    $.Widget._childConstructors = [];
    
    $.Widget.prototype = {
        widgetName: "widget",
        widgetEventPrefix: "",
        defaultElement: "<div>",
    
        options: {
            classes: {},
            disabled: false,
    
            // Callbacks
            create: null
        },
    
        _createWidget: function( options, element ) {
            element = $( element || this.defaultElement || this )[ 0 ];
            this.element = $( element );
            this.uuid = widgetUuid++;
            this.eventNamespace = "." + this.widgetName + this.uuid;
    
            this.bindings = $();
            this.hoverable = $();
            this.focusable = $();
            this.classesElementLookup = {};
    
            if ( element !== this ) {
                $.data( element, this.widgetFullName, this );
                this._on( true, this.element, {
                    remove: function( event ) {
                        if ( event.target === element ) {
                            this.destroy();
                        }
                    }
                } );
                this.document = $( element.style ?
    
                    // Element within the document
                    element.ownerDocument :
    
                    // Element is window or document
                    element.document || element );
                this.window = $( this.document[ 0 ].defaultView || this.document[ 0 ].parentWindow );
            }
    
            this.options = $.widget.extend( {},
                this.options,
                this._getCreateOptions(),
                options );
    
            this._create();
    
            if ( this.options.disabled ) {
                this._setOptionDisabled( this.options.disabled );
            }
    
            this._trigger( "create", null, this._getCreateEventData() );
            this._init();
        },
    
        _getCreateOptions: function() {
            return {};
        },
    
        _getCreateEventData: $.noop,
    
        _create: $.noop,
    
        _init: $.noop,
    
        destroy: function() {
            var that = this;
    
            this._destroy();
            $.each( this.classesElementLookup, function( key, value ) {
                that._removeClass( value, key );
            } );
    
            // We can probably remove the unbind calls in 2.0
            // all event bindings should go through this._on()
            this.element
                .off( this.eventNamespace )
                .removeData( this.widgetFullName );
            this.widget()
                .off( this.eventNamespace )
                .removeAttr( "aria-disabled" );
    
            // Clean up events and states
            this.bindings.off( this.eventNamespace );
        },
    
        _destroy: $.noop,
    
        widget: function() {
            return this.element;
        },
    
        option: function( key, value ) {
            var options = key;
            var parts;
            var curOption;
            var i;
    
            if ( arguments.length === 0 ) {
    
                // Don't return a reference to the internal hash
                return $.widget.extend( {}, this.options );
            }
    
            if ( typeof key === "string" ) {
    
                // Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
                options = {};
                parts = key.split( "." );
                key = parts.shift();
                if ( parts.length ) {
                    curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
                    for ( i = 0; i < parts.length - 1; i++ ) {
                        curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
                        curOption = curOption[ parts[ i ] ];
                    }
                    key = parts.pop();
                    if ( arguments.length === 1 ) {
                        return curOption[ key ] === undefined ? null : curOption[ key ];
                    }
                    curOption[ key ] = value;
                } else {
                    if ( arguments.length === 1 ) {
                        return this.options[ key ] === undefined ? null : this.options[ key ];
                    }
                    options[ key ] = value;
                }
            }
    
            this._setOptions( options );
    
            return this;
        },
    
        _setOptions: function( options ) {
            var key;
    
            for ( key in options ) {
                this._setOption( key, options[ key ] );
            }
    
            return this;
        },
    
        _setOption: function( key, value ) {
            if ( key === "classes" ) {
                this._setOptionClasses( value );
            }
    
            this.options[ key ] = value;
    
            if ( key === "disabled" ) {
                this._setOptionDisabled( value );
            }
    
            return this;
        },
    
        _setOptionClasses: function( value ) {
            var classKey, elements, currentElements;
    
            for ( classKey in value ) {
                currentElements = this.classesElementLookup[ classKey ];
                if ( value[ classKey ] === this.options.classes[ classKey ] ||
                        !currentElements ||
                        !currentElements.length ) {
                    continue;
                }
    
                // We are doing this to create a new jQuery object because the _removeClass() call
                // on the next line is going to destroy the reference to the current elements being
                // tracked. We need to save a copy of this collection so that we can add the new classes
                // below.
                elements = $( currentElements.get() );
                this._removeClass( currentElements, classKey );
    
                // We don't use _addClass() here, because that uses this.options.classes
                // for generating the string of classes. We want to use the value passed in from
                // _setOption(), this is the new value of the classes option which was passed to
                // _setOption(). We pass this value directly to _classes().
                elements.addClass( this._classes( {
                    element: elements,
                    keys: classKey,
                    classes: value,
                    add: true
                } ) );
            }
        },
    
        _setOptionDisabled: function( value ) {
            this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null, !!value );
    
            // If the widget is becoming disabled, then nothing is interactive
            if ( value ) {
                this._removeClass( this.hoverable, null, "ui-state-hover" );
                this._removeClass( this.focusable, null, "ui-state-focus" );
            }
        },
    
        enable: function() {
            return this._setOptions( { disabled: false } );
        },
    
        disable: function() {
            return this._setOptions( { disabled: true } );
        },
    
        _classes: function( options ) {
            var full = [];
            var that = this;
    
            options = $.extend( {
                element: this.element,
                classes: this.options.classes || {}
            }, options );
    
            function processClassString( classes, checkOption ) {
                var current, i;
                for ( i = 0; i < classes.length; i++ ) {
                    current = that.classesElementLookup[ classes[ i ] ] || $();
                    if ( options.add ) {
                        current = $( $.unique( current.get().concat( options.element.get() ) ) );
                    } else {
                        current = $( current.not( options.element ).get() );
                    }
                    that.classesElementLookup[ classes[ i ] ] = current;
                    full.push( classes[ i ] );
                    if ( checkOption && options.classes[ classes[ i ] ] ) {
                        full.push( options.classes[ classes[ i ] ] );
                    }
                }
            }
    
            this._on( options.element, {
                "remove": "_untrackClassesElement"
            } );
    
            if ( options.keys ) {
                processClassString( options.keys.match( /\S+/g ) || [], true );
            }
            if ( options.extra ) {
                processClassString( options.extra.match( /\S+/g ) || [] );
            }
    
            return full.join( " " );
        },
    
        _untrackClassesElement: function( event ) {
            var that = this;
            $.each( that.classesElementLookup, function( key, value ) {
                if ( $.inArray( event.target, value ) !== -1 ) {
                    that.classesElementLookup[ key ] = $( value.not( event.target ).get() );
                }
            } );
        },
    
        _removeClass: function( element, keys, extra ) {
            return this._toggleClass( element, keys, extra, false );
        },
    
        _addClass: function( element, keys, extra ) {
            return this._toggleClass( element, keys, extra, true );
        },
    
        _toggleClass: function( element, keys, extra, add ) {
            add = ( typeof add === "boolean" ) ? add : extra;
            var shift = ( typeof element === "string" || element === null ),
                options = {
                    extra: shift ? keys : extra,
                    keys: shift ? element : keys,
                    element: shift ? this.element : element,
                    add: add
                };
            options.element.toggleClass( this._classes( options ), add );
            return this;
        },
    
        _on: function( suppressDisabledCheck, element, handlers ) {
            var delegateElement;
            var instance = this;
    
            // No suppressDisabledCheck flag, shuffle arguments
            if ( typeof suppressDisabledCheck !== "boolean" ) {
                handlers = element;
                element = suppressDisabledCheck;
                suppressDisabledCheck = false;
            }
    
            // No element argument, shuffle and use this.element
            if ( !handlers ) {
                handlers = element;
                element = this.element;
                delegateElement = this.widget();
            } else {
                element = delegateElement = $( element );
                this.bindings = this.bindings.add( element );
            }
    
            $.each( handlers, function( event, handler ) {
                function handlerProxy() {
    
                    // Allow widgets to customize the disabled handling
                    // - disabled as an array instead of boolean
                    // - disabled class as method for disabling individual parts
                    if ( !suppressDisabledCheck &&
                            ( instance.options.disabled === true ||
                            $( this ).hasClass( "ui-state-disabled" ) ) ) {
                        return;
                    }
                    return ( typeof handler === "string" ? instance[ handler ] : handler )
                        .apply( instance, arguments );
                }
    
                // Copy the guid so direct unbinding works
                if ( typeof handler !== "string" ) {
                    handlerProxy.guid = handler.guid =
                        handler.guid || handlerProxy.guid || $.guid++;
                }
    
                var match = event.match( /^([\w:-]*)\s*(.*)$/ );
                var eventName = match[ 1 ] + instance.eventNamespace;
                var selector = match[ 2 ];
    
                if ( selector ) {
                    delegateElement.on( eventName, selector, handlerProxy );
                } else {
                    element.on( eventName, handlerProxy );
                }
            } );
        },
    
        _off: function( element, eventName ) {
            eventName = ( eventName || "" ).split( " " ).join( this.eventNamespace + " " ) +
                this.eventNamespace;
            element.off( eventName ).off( eventName );
    
            // Clear the stack to avoid memory leaks (#10056)
            this.bindings = $( this.bindings.not( element ).get() );
            this.focusable = $( this.focusable.not( element ).get() );
            this.hoverable = $( this.hoverable.not( element ).get() );
        },
    
        _delay: function( handler, delay ) {
            function handlerProxy() {
                return ( typeof handler === "string" ? instance[ handler ] : handler )
                    .apply( instance, arguments );
            }
            var instance = this;
            return setTimeout( handlerProxy, delay || 0 );
        },
    
        _hoverable: function( element ) {
            this.hoverable = this.hoverable.add( element );
            this._on( element, {
                mouseenter: function( event ) {
                    this._addClass( $( event.currentTarget ), null, "ui-state-hover" );
                },
                mouseleave: function( event ) {
                    this._removeClass( $( event.currentTarget ), null, "ui-state-hover" );
                }
            } );
        },
    
        _focusable: function( element ) {
            this.focusable = this.focusable.add( element );
            this._on( element, {
                focusin: function( event ) {
                    this._addClass( $( event.currentTarget ), null, "ui-state-focus" );
                },
                focusout: function( event ) {
                    this._removeClass( $( event.currentTarget ), null, "ui-state-focus" );
                }
            } );
        },
    
        _trigger: function( type, event, data ) {
            var prop, orig;
            var callback = this.options[ type ];
    
            data = data || {};
            event = $.Event( event );
            event.type = ( type === this.widgetEventPrefix ?
                type :
                this.widgetEventPrefix + type ).toLowerCase();
    
            // The original event may come from any element
            // so we need to reset the target on the new event
            event.target = this.element[ 0 ];
    
            // Copy original event properties over to the new event
            orig = event.originalEvent;
            if ( orig ) {
                for ( prop in orig ) {
                    if ( !( prop in event ) ) {
                        event[ prop ] = orig[ prop ];
                    }
                }
            }
    
            this.element.trigger( event, data );
            return !( $.isFunction( callback ) &&
                callback.apply( this.element[ 0 ], [ event ].concat( data ) ) === false ||
                event.isDefaultPrevented() );
        }
    };
    
    $.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
        $.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
            if ( typeof options === "string" ) {
                options = { effect: options };
            }
    
            var hasOptions;
            var effectName = !options ?
                method :
                options === true || typeof options === "number" ?
                    defaultEffect :
                    options.effect || defaultEffect;
    
            options = options || {};
            if ( typeof options === "number" ) {
                options = { duration: options };
            }
    
            hasOptions = !$.isEmptyObject( options );
            options.complete = callback;
    
            if ( options.delay ) {
                element.delay( options.delay );
            }
    
            if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
                element[ method ]( options );
            } else if ( effectName !== method && element[ effectName ] ) {
                element[ effectName ]( options.duration, options.easing, callback );
            } else {
                element.queue( function( next ) {
                    $( this )[ method ]();
                    if ( callback ) {
                        callback.call( element[ 0 ] );
                    }
                    next();
                } );
            }
        };
    } );
    
    return $.widget;
    
    } ) );
    
    },{}],62:[function(require,module,exports){
    // jscs:disable maximumLineLength
    /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
    /*!
     * jQuery UI Datepicker 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    
    //>>label: Datepicker
    //>>group: Widgets
    //>>description: Displays a calendar from an input or inline for selecting dates.
    //>>docs: http://api.jqueryui.com/datepicker/
    //>>demos: http://jqueryui.com/datepicker/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/datepicker.css
    //>>css.theme: ../../themes/base/theme.css
    
    ( function( factory ) {
        if ( typeof define === "function" && define.amd ) {
    
            // AMD. Register as an anonymous module.
            define( [
                "jquery",
                "../version",
                "../keycode"
            ], factory );
        } else {
    
            // Browser globals
            factory( jQuery );
        }
    }( function( $ ) {
    
    $.extend( $.ui, { datepicker: { version: "1.12.1" } } );
    
    var datepicker_instActive;
    
    function datepicker_getZindex( elem ) {
        var position, value;
        while ( elem.length && elem[ 0 ] !== document ) {
    
            // Ignore z-index if position is set to a value where z-index is ignored by the browser
            // This makes behavior of this function consistent across browsers
            // WebKit always returns auto if the element is positioned
            position = elem.css( "position" );
            if ( position === "absolute" || position === "relative" || position === "fixed" ) {
    
                // IE returns 0 when zIndex is not specified
                // other browsers return a string
                // we ignore the case of nested elements with an explicit value of 0
                // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
                value = parseInt( elem.css( "zIndex" ), 10 );
                if ( !isNaN( value ) && value !== 0 ) {
                    return value;
                }
            }
            elem = elem.parent();
        }
    
        return 0;
    }
    /* Date picker manager.
       Use the singleton instance of this class, $.datepicker, to interact with the date picker.
       Settings for (groups of) date pickers are maintained in an instance object,
       allowing multiple different settings on the same page. */
    
    function Datepicker() {
        this._curInst = null; // The current instance in use
        this._keyEvent = false; // If the last event was a key event
        this._disabledInputs = []; // List of date picker inputs that have been disabled
        this._datepickerShowing = false; // True if the popup picker is showing , false if not
        this._inDialog = false; // True if showing within a "dialog", false if not
        this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
        this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
        this._appendClass = "ui-datepicker-append"; // The name of the append marker class
        this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
        this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
        this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
        this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
        this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
        this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
        this.regional = []; // Available regional settings, indexed by language code
        this.regional[ "" ] = { // Default regional settings
            closeText: "Done", // Display text for close link
            prevText: "Prev", // Display text for previous month link
            nextText: "Next", // Display text for next month link
            currentText: "Today", // Display text for current month link
            monthNames: [ "January","February","March","April","May","June",
                "July","August","September","October","November","December" ], // Names of months for drop-down and formatting
            monthNamesShort: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ], // For formatting
            dayNames: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ], // For formatting
            dayNamesShort: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ], // For formatting
            dayNamesMin: [ "Su","Mo","Tu","We","Th","Fr","Sa" ], // Column headings for days starting at Sunday
            weekHeader: "Wk", // Column header for week of the year
            dateFormat: "mm/dd/yy", // See format options on parseDate
            firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
            isRTL: false, // True if right-to-left language, false if left-to-right
            showMonthAfterYear: false, // True if the year select precedes month, false for month then year
            yearSuffix: "" // Additional text to append to the year in the month headers
        };
        this._defaults = { // Global defaults for all the date picker instances
            showOn: "focus", // "focus" for popup on focus,
                // "button" for trigger button, or "both" for either
            showAnim: "fadeIn", // Name of jQuery animation for popup
            showOptions: {}, // Options for enhanced animations
            defaultDate: null, // Used when field is blank: actual date,
                // +/-number for offset from today, null for today
            appendText: "", // Display text following the input box, e.g. showing the format
            buttonText: "...", // Text for trigger button
            buttonImage: "", // URL for trigger button image
            buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
            hideIfNoPrevNext: false, // True to hide next/previous month links
                // if not applicable, false to just disable them
            navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
            gotoCurrent: false, // True if today link goes back to current selection instead
            changeMonth: false, // True if month can be selected directly, false if only prev/next
            changeYear: false, // True if year can be selected directly, false if only prev/next
            yearRange: "c-10:c+10", // Range of years to display in drop-down,
                // either relative to today's year (-nn:+nn), relative to currently displayed year
                // (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
            showOtherMonths: false, // True to show dates in other months, false to leave blank
            selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
            showWeek: false, // True to show week of the year, false to not show it
            calculateWeek: this.iso8601Week, // How to calculate the week of the year,
                // takes a Date and returns the number of the week for it
            shortYearCutoff: "+10", // Short year values < this are in the current century,
                // > this are in the previous century,
                // string value starting with "+" for current year + value
            minDate: null, // The earliest selectable date, or null for no limit
            maxDate: null, // The latest selectable date, or null for no limit
            duration: "fast", // Duration of display/closure
            beforeShowDay: null, // Function that takes a date and returns an array with
                // [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
                // [2] = cell title (optional), e.g. $.datepicker.noWeekends
            beforeShow: null, // Function that takes an input field and
                // returns a set of custom settings for the date picker
            onSelect: null, // Define a callback function when a date is selected
            onChangeMonthYear: null, // Define a callback function when the month or year is changed
            onClose: null, // Define a callback function when the datepicker is closed
            numberOfMonths: 1, // Number of months to show at a time
            showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
            stepMonths: 1, // Number of months to step back/forward
            stepBigMonths: 12, // Number of months to step back/forward for the big links
            altField: "", // Selector for an alternate field to store selected dates into
            altFormat: "", // The date format to use for the alternate field
            constrainInput: true, // The input is constrained by the current date format
            showButtonPanel: false, // True to show button panel, false to not show it
            autoSize: false, // True to size the input for the date format, false to leave as is
            disabled: false // The initial disabled state
        };
        $.extend( this._defaults, this.regional[ "" ] );
        this.regional.en = $.extend( true, {}, this.regional[ "" ] );
        this.regional[ "en-US" ] = $.extend( true, {}, this.regional.en );
        this.dpDiv = datepicker_bindHover( $( "<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>" ) );
    }
    
    $.extend( Datepicker.prototype, {
        /* Class name added to elements to indicate already configured with a date picker. */
        markerClassName: "hasDatepicker",
    
        //Keep track of the maximum number of rows displayed (see #7043)
        maxRows: 4,
    
        // TODO rename to "widget" when switching to widget factory
        _widgetDatepicker: function() {
            return this.dpDiv;
        },
    
        /* Override the default settings for all instances of the date picker.
         * @param  settings  object - the new settings to use as defaults (anonymous object)
         * @return the manager object
         */
        setDefaults: function( settings ) {
            datepicker_extendRemove( this._defaults, settings || {} );
            return this;
        },
    
        /* Attach the date picker to a jQuery selection.
         * @param  target	element - the target input field or division or span
         * @param  settings  object - the new settings to use for this date picker instance (anonymous)
         */
        _attachDatepicker: function( target, settings ) {
            var nodeName, inline, inst;
            nodeName = target.nodeName.toLowerCase();
            inline = ( nodeName === "div" || nodeName === "span" );
            if ( !target.id ) {
                this.uuid += 1;
                target.id = "dp" + this.uuid;
            }
            inst = this._newInst( $( target ), inline );
            inst.settings = $.extend( {}, settings || {} );
            if ( nodeName === "input" ) {
                this._connectDatepicker( target, inst );
            } else if ( inline ) {
                this._inlineDatepicker( target, inst );
            }
        },
    
        /* Create a new instance object. */
        _newInst: function( target, inline ) {
            var id = target[ 0 ].id.replace( /([^A-Za-z0-9_\-])/g, "\\\\$1" ); // escape jQuery meta chars
            return { id: id, input: target, // associated target
                selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
                drawMonth: 0, drawYear: 0, // month being drawn
                inline: inline, // is datepicker inline or not
                dpDiv: ( !inline ? this.dpDiv : // presentation div
                datepicker_bindHover( $( "<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>" ) ) ) };
        },
    
        /* Attach the date picker to an input field. */
        _connectDatepicker: function( target, inst ) {
            var input = $( target );
            inst.append = $( [] );
            inst.trigger = $( [] );
            if ( input.hasClass( this.markerClassName ) ) {
                return;
            }
            this._attachments( input, inst );
            input.addClass( this.markerClassName ).on( "keydown", this._doKeyDown ).
                on( "keypress", this._doKeyPress ).on( "keyup", this._doKeyUp );
            this._autoSize( inst );
            $.data( target, "datepicker", inst );
    
            //If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
            if ( inst.settings.disabled ) {
                this._disableDatepicker( target );
            }
        },
    
        /* Make attachments based on settings. */
        _attachments: function( input, inst ) {
            var showOn, buttonText, buttonImage,
                appendText = this._get( inst, "appendText" ),
                isRTL = this._get( inst, "isRTL" );
    
            if ( inst.append ) {
                inst.append.remove();
            }
            if ( appendText ) {
                inst.append = $( "<span class='" + this._appendClass + "'>" + appendText + "</span>" );
                input[ isRTL ? "before" : "after" ]( inst.append );
            }
    
            input.off( "focus", this._showDatepicker );
    
            if ( inst.trigger ) {
                inst.trigger.remove();
            }
    
            showOn = this._get( inst, "showOn" );
            if ( showOn === "focus" || showOn === "both" ) { // pop-up date picker when in the marked field
                input.on( "focus", this._showDatepicker );
            }
            if ( showOn === "button" || showOn === "both" ) { // pop-up date picker when button clicked
                buttonText = this._get( inst, "buttonText" );
                buttonImage = this._get( inst, "buttonImage" );
                inst.trigger = $( this._get( inst, "buttonImageOnly" ) ?
                    $( "<img/>" ).addClass( this._triggerClass ).
                        attr( { src: buttonImage, alt: buttonText, title: buttonText } ) :
                    $( "<button type='button'></button>" ).addClass( this._triggerClass ).
                        html( !buttonImage ? buttonText : $( "<img/>" ).attr(
                        { src:buttonImage, alt:buttonText, title:buttonText } ) ) );
                input[ isRTL ? "before" : "after" ]( inst.trigger );
                inst.trigger.on( "click", function() {
                    if ( $.datepicker._datepickerShowing && $.datepicker._lastInput === input[ 0 ] ) {
                        $.datepicker._hideDatepicker();
                    } else if ( $.datepicker._datepickerShowing && $.datepicker._lastInput !== input[ 0 ] ) {
                        $.datepicker._hideDatepicker();
                        $.datepicker._showDatepicker( input[ 0 ] );
                    } else {
                        $.datepicker._showDatepicker( input[ 0 ] );
                    }
                    return false;
                } );
            }
        },
    
        /* Apply the maximum length for the date format. */
        _autoSize: function( inst ) {
            if ( this._get( inst, "autoSize" ) && !inst.inline ) {
                var findMax, max, maxI, i,
                    date = new Date( 2009, 12 - 1, 20 ), // Ensure double digits
                    dateFormat = this._get( inst, "dateFormat" );
    
                if ( dateFormat.match( /[DM]/ ) ) {
                    findMax = function( names ) {
                        max = 0;
                        maxI = 0;
                        for ( i = 0; i < names.length; i++ ) {
                            if ( names[ i ].length > max ) {
                                max = names[ i ].length;
                                maxI = i;
                            }
                        }
                        return maxI;
                    };
                    date.setMonth( findMax( this._get( inst, ( dateFormat.match( /MM/ ) ?
                        "monthNames" : "monthNamesShort" ) ) ) );
                    date.setDate( findMax( this._get( inst, ( dateFormat.match( /DD/ ) ?
                        "dayNames" : "dayNamesShort" ) ) ) + 20 - date.getDay() );
                }
                inst.input.attr( "size", this._formatDate( inst, date ).length );
            }
        },
    
        /* Attach an inline date picker to a div. */
        _inlineDatepicker: function( target, inst ) {
            var divSpan = $( target );
            if ( divSpan.hasClass( this.markerClassName ) ) {
                return;
            }
            divSpan.addClass( this.markerClassName ).append( inst.dpDiv );
            $.data( target, "datepicker", inst );
            this._setDate( inst, this._getDefaultDate( inst ), true );
            this._updateDatepicker( inst );
            this._updateAlternate( inst );
    
            //If disabled option is true, disable the datepicker before showing it (see ticket #5665)
            if ( inst.settings.disabled ) {
                this._disableDatepicker( target );
            }
    
            // Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
            // http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
            inst.dpDiv.css( "display", "block" );
        },
    
        /* Pop-up the date picker in a "dialog" box.
         * @param  input element - ignored
         * @param  date	string or Date - the initial date to display
         * @param  onSelect  function - the function to call when a date is selected
         * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
         * @param  pos int[2] - coordinates for the dialog's position within the screen or
         *					event - with x/y coordinates or
         *					leave empty for default (screen centre)
         * @return the manager object
         */
        _dialogDatepicker: function( input, date, onSelect, settings, pos ) {
            var id, browserWidth, browserHeight, scrollX, scrollY,
                inst = this._dialogInst; // internal instance
    
            if ( !inst ) {
                this.uuid += 1;
                id = "dp" + this.uuid;
                this._dialogInput = $( "<input type='text' id='" + id +
                    "' style='position: absolute; top: -100px; width: 0px;'/>" );
                this._dialogInput.on( "keydown", this._doKeyDown );
                $( "body" ).append( this._dialogInput );
                inst = this._dialogInst = this._newInst( this._dialogInput, false );
                inst.settings = {};
                $.data( this._dialogInput[ 0 ], "datepicker", inst );
            }
            datepicker_extendRemove( inst.settings, settings || {} );
            date = ( date && date.constructor === Date ? this._formatDate( inst, date ) : date );
            this._dialogInput.val( date );
    
            this._pos = ( pos ? ( pos.length ? pos : [ pos.pageX, pos.pageY ] ) : null );
            if ( !this._pos ) {
                browserWidth = document.documentElement.clientWidth;
                browserHeight = document.documentElement.clientHeight;
                scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
                scrollY = document.documentElement.scrollTop || document.body.scrollTop;
                this._pos = // should use actual width/height below
                    [ ( browserWidth / 2 ) - 100 + scrollX, ( browserHeight / 2 ) - 150 + scrollY ];
            }
    
            // Move input on screen for focus, but hidden behind dialog
            this._dialogInput.css( "left", ( this._pos[ 0 ] + 20 ) + "px" ).css( "top", this._pos[ 1 ] + "px" );
            inst.settings.onSelect = onSelect;
            this._inDialog = true;
            this.dpDiv.addClass( this._dialogClass );
            this._showDatepicker( this._dialogInput[ 0 ] );
            if ( $.blockUI ) {
                $.blockUI( this.dpDiv );
            }
            $.data( this._dialogInput[ 0 ], "datepicker", inst );
            return this;
        },
    
        /* Detach a datepicker from its control.
         * @param  target	element - the target input field or division or span
         */
        _destroyDatepicker: function( target ) {
            var nodeName,
                $target = $( target ),
                inst = $.data( target, "datepicker" );
    
            if ( !$target.hasClass( this.markerClassName ) ) {
                return;
            }
    
            nodeName = target.nodeName.toLowerCase();
            $.removeData( target, "datepicker" );
            if ( nodeName === "input" ) {
                inst.append.remove();
                inst.trigger.remove();
                $target.removeClass( this.markerClassName ).
                    off( "focus", this._showDatepicker ).
                    off( "keydown", this._doKeyDown ).
                    off( "keypress", this._doKeyPress ).
                    off( "keyup", this._doKeyUp );
            } else if ( nodeName === "div" || nodeName === "span" ) {
                $target.removeClass( this.markerClassName ).empty();
            }
    
            if ( datepicker_instActive === inst ) {
                datepicker_instActive = null;
            }
        },
    
        /* Enable the date picker to a jQuery selection.
         * @param  target	element - the target input field or division or span
         */
        _enableDatepicker: function( target ) {
            var nodeName, inline,
                $target = $( target ),
                inst = $.data( target, "datepicker" );
    
            if ( !$target.hasClass( this.markerClassName ) ) {
                return;
            }
    
            nodeName = target.nodeName.toLowerCase();
            if ( nodeName === "input" ) {
                target.disabled = false;
                inst.trigger.filter( "button" ).
                    each( function() { this.disabled = false; } ).end().
                    filter( "img" ).css( { opacity: "1.0", cursor: "" } );
            } else if ( nodeName === "div" || nodeName === "span" ) {
                inline = $target.children( "." + this._inlineClass );
                inline.children().removeClass( "ui-state-disabled" );
                inline.find( "select.ui-datepicker-month, select.ui-datepicker-year" ).
                    prop( "disabled", false );
            }
            this._disabledInputs = $.map( this._disabledInputs,
                function( value ) { return ( value === target ? null : value ); } ); // delete entry
        },
    
        /* Disable the date picker to a jQuery selection.
         * @param  target	element - the target input field or division or span
         */
        _disableDatepicker: function( target ) {
            var nodeName, inline,
                $target = $( target ),
                inst = $.data( target, "datepicker" );
    
            if ( !$target.hasClass( this.markerClassName ) ) {
                return;
            }
    
            nodeName = target.nodeName.toLowerCase();
            if ( nodeName === "input" ) {
                target.disabled = true;
                inst.trigger.filter( "button" ).
                    each( function() { this.disabled = true; } ).end().
                    filter( "img" ).css( { opacity: "0.5", cursor: "default" } );
            } else if ( nodeName === "div" || nodeName === "span" ) {
                inline = $target.children( "." + this._inlineClass );
                inline.children().addClass( "ui-state-disabled" );
                inline.find( "select.ui-datepicker-month, select.ui-datepicker-year" ).
                    prop( "disabled", true );
            }
            this._disabledInputs = $.map( this._disabledInputs,
                function( value ) { return ( value === target ? null : value ); } ); // delete entry
            this._disabledInputs[ this._disabledInputs.length ] = target;
        },
    
        /* Is the first field in a jQuery collection disabled as a datepicker?
         * @param  target	element - the target input field or division or span
         * @return boolean - true if disabled, false if enabled
         */
        _isDisabledDatepicker: function( target ) {
            if ( !target ) {
                return false;
            }
            for ( var i = 0; i < this._disabledInputs.length; i++ ) {
                if ( this._disabledInputs[ i ] === target ) {
                    return true;
                }
            }
            return false;
        },
    
        /* Retrieve the instance data for the target control.
         * @param  target  element - the target input field or division or span
         * @return  object - the associated instance data
         * @throws  error if a jQuery problem getting data
         */
        _getInst: function( target ) {
            try {
                return $.data( target, "datepicker" );
            }
            catch ( err ) {
                throw "Missing instance data for this datepicker";
            }
        },
    
        /* Update or retrieve the settings for a date picker attached to an input field or division.
         * @param  target  element - the target input field or division or span
         * @param  name	object - the new settings to update or
         *				string - the name of the setting to change or retrieve,
         *				when retrieving also "all" for all instance settings or
         *				"defaults" for all global defaults
         * @param  value   any - the new value for the setting
         *				(omit if above is an object or to retrieve a value)
         */
        _optionDatepicker: function( target, name, value ) {
            var settings, date, minDate, maxDate,
                inst = this._getInst( target );
    
            if ( arguments.length === 2 && typeof name === "string" ) {
                return ( name === "defaults" ? $.extend( {}, $.datepicker._defaults ) :
                    ( inst ? ( name === "all" ? $.extend( {}, inst.settings ) :
                    this._get( inst, name ) ) : null ) );
            }
    
            settings = name || {};
            if ( typeof name === "string" ) {
                settings = {};
                settings[ name ] = value;
            }
    
            if ( inst ) {
                if ( this._curInst === inst ) {
                    this._hideDatepicker();
                }
    
                date = this._getDateDatepicker( target, true );
                minDate = this._getMinMaxDate( inst, "min" );
                maxDate = this._getMinMaxDate( inst, "max" );
                datepicker_extendRemove( inst.settings, settings );
    
                // reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
                if ( minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined ) {
                    inst.settings.minDate = this._formatDate( inst, minDate );
                }
                if ( maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined ) {
                    inst.settings.maxDate = this._formatDate( inst, maxDate );
                }
                if ( "disabled" in settings ) {
                    if ( settings.disabled ) {
                        this._disableDatepicker( target );
                    } else {
                        this._enableDatepicker( target );
                    }
                }
                this._attachments( $( target ), inst );
                this._autoSize( inst );
                this._setDate( inst, date );
                this._updateAlternate( inst );
                this._updateDatepicker( inst );
            }
        },
    
        // Change method deprecated
        _changeDatepicker: function( target, name, value ) {
            this._optionDatepicker( target, name, value );
        },
    
        /* Redraw the date picker attached to an input field or division.
         * @param  target  element - the target input field or division or span
         */
        _refreshDatepicker: function( target ) {
            var inst = this._getInst( target );
            if ( inst ) {
                this._updateDatepicker( inst );
            }
        },
    
        /* Set the dates for a jQuery selection.
         * @param  target element - the target input field or division or span
         * @param  date	Date - the new date
         */
        _setDateDatepicker: function( target, date ) {
            var inst = this._getInst( target );
            if ( inst ) {
                this._setDate( inst, date );
                this._updateDatepicker( inst );
                this._updateAlternate( inst );
            }
        },
    
        /* Get the date(s) for the first entry in a jQuery selection.
         * @param  target element - the target input field or division or span
         * @param  noDefault boolean - true if no default date is to be used
         * @return Date - the current date
         */
        _getDateDatepicker: function( target, noDefault ) {
            var inst = this._getInst( target );
            if ( inst && !inst.inline ) {
                this._setDateFromField( inst, noDefault );
            }
            return ( inst ? this._getDate( inst ) : null );
        },
    
        /* Handle keystrokes. */
        _doKeyDown: function( event ) {
            var onSelect, dateStr, sel,
                inst = $.datepicker._getInst( event.target ),
                handled = true,
                isRTL = inst.dpDiv.is( ".ui-datepicker-rtl" );
    
            inst._keyEvent = true;
            if ( $.datepicker._datepickerShowing ) {
                switch ( event.keyCode ) {
                    case 9: $.datepicker._hideDatepicker();
                            handled = false;
                            break; // hide on tab out
                    case 13: sel = $( "td." + $.datepicker._dayOverClass + ":not(." +
                                        $.datepicker._currentClass + ")", inst.dpDiv );
                            if ( sel[ 0 ] ) {
                                $.datepicker._selectDay( event.target, inst.selectedMonth, inst.selectedYear, sel[ 0 ] );
                            }
    
                            onSelect = $.datepicker._get( inst, "onSelect" );
                            if ( onSelect ) {
                                dateStr = $.datepicker._formatDate( inst );
    
                                // Trigger custom callback
                                onSelect.apply( ( inst.input ? inst.input[ 0 ] : null ), [ dateStr, inst ] );
                            } else {
                                $.datepicker._hideDatepicker();
                            }
    
                            return false; // don't submit the form
                    case 27: $.datepicker._hideDatepicker();
                            break; // hide on escape
                    case 33: $.datepicker._adjustDate( event.target, ( event.ctrlKey ?
                                -$.datepicker._get( inst, "stepBigMonths" ) :
                                -$.datepicker._get( inst, "stepMonths" ) ), "M" );
                            break; // previous month/year on page up/+ ctrl
                    case 34: $.datepicker._adjustDate( event.target, ( event.ctrlKey ?
                                +$.datepicker._get( inst, "stepBigMonths" ) :
                                +$.datepicker._get( inst, "stepMonths" ) ), "M" );
                            break; // next month/year on page down/+ ctrl
                    case 35: if ( event.ctrlKey || event.metaKey ) {
                                $.datepicker._clearDate( event.target );
                            }
                            handled = event.ctrlKey || event.metaKey;
                            break; // clear on ctrl or command +end
                    case 36: if ( event.ctrlKey || event.metaKey ) {
                                $.datepicker._gotoToday( event.target );
                            }
                            handled = event.ctrlKey || event.metaKey;
                            break; // current on ctrl or command +home
                    case 37: if ( event.ctrlKey || event.metaKey ) {
                                $.datepicker._adjustDate( event.target, ( isRTL ? +1 : -1 ), "D" );
                            }
                            handled = event.ctrlKey || event.metaKey;
    
                            // -1 day on ctrl or command +left
                            if ( event.originalEvent.altKey ) {
                                $.datepicker._adjustDate( event.target, ( event.ctrlKey ?
                                    -$.datepicker._get( inst, "stepBigMonths" ) :
                                    -$.datepicker._get( inst, "stepMonths" ) ), "M" );
                            }
    
                            // next month/year on alt +left on Mac
                            break;
                    case 38: if ( event.ctrlKey || event.metaKey ) {
                                $.datepicker._adjustDate( event.target, -7, "D" );
                            }
                            handled = event.ctrlKey || event.metaKey;
                            break; // -1 week on ctrl or command +up
                    case 39: if ( event.ctrlKey || event.metaKey ) {
                                $.datepicker._adjustDate( event.target, ( isRTL ? -1 : +1 ), "D" );
                            }
                            handled = event.ctrlKey || event.metaKey;
    
                            // +1 day on ctrl or command +right
                            if ( event.originalEvent.altKey ) {
                                $.datepicker._adjustDate( event.target, ( event.ctrlKey ?
                                    +$.datepicker._get( inst, "stepBigMonths" ) :
                                    +$.datepicker._get( inst, "stepMonths" ) ), "M" );
                            }
    
                            // next month/year on alt +right
                            break;
                    case 40: if ( event.ctrlKey || event.metaKey ) {
                                $.datepicker._adjustDate( event.target, +7, "D" );
                            }
                            handled = event.ctrlKey || event.metaKey;
                            break; // +1 week on ctrl or command +down
                    default: handled = false;
                }
            } else if ( event.keyCode === 36 && event.ctrlKey ) { // display the date picker on ctrl+home
                $.datepicker._showDatepicker( this );
            } else {
                handled = false;
            }
    
            if ( handled ) {
                event.preventDefault();
                event.stopPropagation();
            }
        },
    
        /* Filter entered characters - based on date format. */
        _doKeyPress: function( event ) {
            var chars, chr,
                inst = $.datepicker._getInst( event.target );
    
            if ( $.datepicker._get( inst, "constrainInput" ) ) {
                chars = $.datepicker._possibleChars( $.datepicker._get( inst, "dateFormat" ) );
                chr = String.fromCharCode( event.charCode == null ? event.keyCode : event.charCode );
                return event.ctrlKey || event.metaKey || ( chr < " " || !chars || chars.indexOf( chr ) > -1 );
            }
        },
    
        /* Synchronise manual entry and field/alternate field. */
        _doKeyUp: function( event ) {
            var date,
                inst = $.datepicker._getInst( event.target );
    
            if ( inst.input.val() !== inst.lastVal ) {
                try {
                    date = $.datepicker.parseDate( $.datepicker._get( inst, "dateFormat" ),
                        ( inst.input ? inst.input.val() : null ),
                        $.datepicker._getFormatConfig( inst ) );
    
                    if ( date ) { // only if valid
                        $.datepicker._setDateFromField( inst );
                        $.datepicker._updateAlternate( inst );
                        $.datepicker._updateDatepicker( inst );
                    }
                }
                catch ( err ) {
                }
            }
            return true;
        },
    
        /* Pop-up the date picker for a given input field.
         * If false returned from beforeShow event handler do not show.
         * @param  input  element - the input field attached to the date picker or
         *					event - if triggered by focus
         */
        _showDatepicker: function( input ) {
            input = input.target || input;
            if ( input.nodeName.toLowerCase() !== "input" ) { // find from button/image trigger
                input = $( "input", input.parentNode )[ 0 ];
            }
    
            if ( $.datepicker._isDisabledDatepicker( input ) || $.datepicker._lastInput === input ) { // already here
                return;
            }
    
            var inst, beforeShow, beforeShowSettings, isFixed,
                offset, showAnim, duration;
    
            inst = $.datepicker._getInst( input );
            if ( $.datepicker._curInst && $.datepicker._curInst !== inst ) {
                $.datepicker._curInst.dpDiv.stop( true, true );
                if ( inst && $.datepicker._datepickerShowing ) {
                    $.datepicker._hideDatepicker( $.datepicker._curInst.input[ 0 ] );
                }
            }
    
            beforeShow = $.datepicker._get( inst, "beforeShow" );
            beforeShowSettings = beforeShow ? beforeShow.apply( input, [ input, inst ] ) : {};
            if ( beforeShowSettings === false ) {
                return;
            }
            datepicker_extendRemove( inst.settings, beforeShowSettings );
    
            inst.lastVal = null;
            $.datepicker._lastInput = input;
            $.datepicker._setDateFromField( inst );
    
            if ( $.datepicker._inDialog ) { // hide cursor
                input.value = "";
            }
            if ( !$.datepicker._pos ) { // position below input
                $.datepicker._pos = $.datepicker._findPos( input );
                $.datepicker._pos[ 1 ] += input.offsetHeight; // add the height
            }
    
            isFixed = false;
            $( input ).parents().each( function() {
                isFixed |= $( this ).css( "position" ) === "fixed";
                return !isFixed;
            } );
    
            offset = { left: $.datepicker._pos[ 0 ], top: $.datepicker._pos[ 1 ] };
            $.datepicker._pos = null;
    
            //to avoid flashes on Firefox
            inst.dpDiv.empty();
    
            // determine sizing offscreen
            inst.dpDiv.css( { position: "absolute", display: "block", top: "-1000px" } );
            $.datepicker._updateDatepicker( inst );
    
            // fix width for dynamic number of date pickers
            // and adjust position before showing
            offset = $.datepicker._checkOffset( inst, offset, isFixed );
            inst.dpDiv.css( { position: ( $.datepicker._inDialog && $.blockUI ?
                "static" : ( isFixed ? "fixed" : "absolute" ) ), display: "none",
                left: offset.left + "px", top: offset.top + "px" } );
    
            if ( !inst.inline ) {
                showAnim = $.datepicker._get( inst, "showAnim" );
                duration = $.datepicker._get( inst, "duration" );
                inst.dpDiv.css( "z-index", datepicker_getZindex( $( input ) ) + 1 );
                $.datepicker._datepickerShowing = true;
    
                if ( $.effects && $.effects.effect[ showAnim ] ) {
                    inst.dpDiv.show( showAnim, $.datepicker._get( inst, "showOptions" ), duration );
                } else {
                    inst.dpDiv[ showAnim || "show" ]( showAnim ? duration : null );
                }
    
                if ( $.datepicker._shouldFocusInput( inst ) ) {
                    inst.input.trigger( "focus" );
                }
    
                $.datepicker._curInst = inst;
            }
        },
    
        /* Generate the date picker content. */
        _updateDatepicker: function( inst ) {
            this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
            datepicker_instActive = inst; // for delegate hover events
            inst.dpDiv.empty().append( this._generateHTML( inst ) );
            this._attachHandlers( inst );
    
            var origyearshtml,
                numMonths = this._getNumberOfMonths( inst ),
                cols = numMonths[ 1 ],
                width = 17,
                activeCell = inst.dpDiv.find( "." + this._dayOverClass + " a" );
    
            if ( activeCell.length > 0 ) {
                datepicker_handleMouseover.apply( activeCell.get( 0 ) );
            }
    
            inst.dpDiv.removeClass( "ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4" ).width( "" );
            if ( cols > 1 ) {
                inst.dpDiv.addClass( "ui-datepicker-multi-" + cols ).css( "width", ( width * cols ) + "em" );
            }
            inst.dpDiv[ ( numMonths[ 0 ] !== 1 || numMonths[ 1 ] !== 1 ? "add" : "remove" ) +
                "Class" ]( "ui-datepicker-multi" );
            inst.dpDiv[ ( this._get( inst, "isRTL" ) ? "add" : "remove" ) +
                "Class" ]( "ui-datepicker-rtl" );
    
            if ( inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {
                inst.input.trigger( "focus" );
            }
    
            // Deffered render of the years select (to avoid flashes on Firefox)
            if ( inst.yearshtml ) {
                origyearshtml = inst.yearshtml;
                setTimeout( function() {
    
                    //assure that inst.yearshtml didn't change.
                    if ( origyearshtml === inst.yearshtml && inst.yearshtml ) {
                        inst.dpDiv.find( "select.ui-datepicker-year:first" ).replaceWith( inst.yearshtml );
                    }
                    origyearshtml = inst.yearshtml = null;
                }, 0 );
            }
        },
    
        // #6694 - don't focus the input if it's already focused
        // this breaks the change event in IE
        // Support: IE and jQuery <1.9
        _shouldFocusInput: function( inst ) {
            return inst.input && inst.input.is( ":visible" ) && !inst.input.is( ":disabled" ) && !inst.input.is( ":focus" );
        },
    
        /* Check positioning to remain on screen. */
        _checkOffset: function( inst, offset, isFixed ) {
            var dpWidth = inst.dpDiv.outerWidth(),
                dpHeight = inst.dpDiv.outerHeight(),
                inputWidth = inst.input ? inst.input.outerWidth() : 0,
                inputHeight = inst.input ? inst.input.outerHeight() : 0,
                viewWidth = document.documentElement.clientWidth + ( isFixed ? 0 : $( document ).scrollLeft() ),
                viewHeight = document.documentElement.clientHeight + ( isFixed ? 0 : $( document ).scrollTop() );
    
            offset.left -= ( this._get( inst, "isRTL" ) ? ( dpWidth - inputWidth ) : 0 );
            offset.left -= ( isFixed && offset.left === inst.input.offset().left ) ? $( document ).scrollLeft() : 0;
            offset.top -= ( isFixed && offset.top === ( inst.input.offset().top + inputHeight ) ) ? $( document ).scrollTop() : 0;
    
            // Now check if datepicker is showing outside window viewport - move to a better place if so.
            offset.left -= Math.min( offset.left, ( offset.left + dpWidth > viewWidth && viewWidth > dpWidth ) ?
                Math.abs( offset.left + dpWidth - viewWidth ) : 0 );
            offset.top -= Math.min( offset.top, ( offset.top + dpHeight > viewHeight && viewHeight > dpHeight ) ?
                Math.abs( dpHeight + inputHeight ) : 0 );
    
            return offset;
        },
    
        /* Find an object's position on the screen. */
        _findPos: function( obj ) {
            var position,
                inst = this._getInst( obj ),
                isRTL = this._get( inst, "isRTL" );
    
            while ( obj && ( obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden( obj ) ) ) {
                obj = obj[ isRTL ? "previousSibling" : "nextSibling" ];
            }
    
            position = $( obj ).offset();
            return [ position.left, position.top ];
        },
    
        /* Hide the date picker from view.
         * @param  input  element - the input field attached to the date picker
         */
        _hideDatepicker: function( input ) {
            var showAnim, duration, postProcess, onClose,
                inst = this._curInst;
    
            if ( !inst || ( input && inst !== $.data( input, "datepicker" ) ) ) {
                return;
            }
    
            if ( this._datepickerShowing ) {
                showAnim = this._get( inst, "showAnim" );
                duration = this._get( inst, "duration" );
                postProcess = function() {
                    $.datepicker._tidyDialog( inst );
                };
    
                // DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
                if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {
                    inst.dpDiv.hide( showAnim, $.datepicker._get( inst, "showOptions" ), duration, postProcess );
                } else {
                    inst.dpDiv[ ( showAnim === "slideDown" ? "slideUp" :
                        ( showAnim === "fadeIn" ? "fadeOut" : "hide" ) ) ]( ( showAnim ? duration : null ), postProcess );
                }
    
                if ( !showAnim ) {
                    postProcess();
                }
                this._datepickerShowing = false;
    
                onClose = this._get( inst, "onClose" );
                if ( onClose ) {
                    onClose.apply( ( inst.input ? inst.input[ 0 ] : null ), [ ( inst.input ? inst.input.val() : "" ), inst ] );
                }
    
                this._lastInput = null;
                if ( this._inDialog ) {
                    this._dialogInput.css( { position: "absolute", left: "0", top: "-100px" } );
                    if ( $.blockUI ) {
                        $.unblockUI();
                        $( "body" ).append( this.dpDiv );
                    }
                }
                this._inDialog = false;
            }
        },
    
        /* Tidy up after a dialog display. */
        _tidyDialog: function( inst ) {
            inst.dpDiv.removeClass( this._dialogClass ).off( ".ui-datepicker-calendar" );
        },
    
        /* Close date picker if clicked elsewhere. */
        _checkExternalClick: function( event ) {
            if ( !$.datepicker._curInst ) {
                return;
            }
    
            var $target = $( event.target ),
                inst = $.datepicker._getInst( $target[ 0 ] );
    
            if ( ( ( $target[ 0 ].id !== $.datepicker._mainDivId &&
                    $target.parents( "#" + $.datepicker._mainDivId ).length === 0 &&
                    !$target.hasClass( $.datepicker.markerClassName ) &&
                    !$target.closest( "." + $.datepicker._triggerClass ).length &&
                    $.datepicker._datepickerShowing && !( $.datepicker._inDialog && $.blockUI ) ) ) ||
                ( $target.hasClass( $.datepicker.markerClassName ) && $.datepicker._curInst !== inst ) ) {
                    $.datepicker._hideDatepicker();
            }
        },
    
        /* Adjust one of the date sub-fields. */
        _adjustDate: function( id, offset, period ) {
            var target = $( id ),
                inst = this._getInst( target[ 0 ] );
    
            if ( this._isDisabledDatepicker( target[ 0 ] ) ) {
                return;
            }
            this._adjustInstDate( inst, offset +
                ( period === "M" ? this._get( inst, "showCurrentAtPos" ) : 0 ), // undo positioning
                period );
            this._updateDatepicker( inst );
        },
    
        /* Action for current link. */
        _gotoToday: function( id ) {
            var date,
                target = $( id ),
                inst = this._getInst( target[ 0 ] );
    
            if ( this._get( inst, "gotoCurrent" ) && inst.currentDay ) {
                inst.selectedDay = inst.currentDay;
                inst.drawMonth = inst.selectedMonth = inst.currentMonth;
                inst.drawYear = inst.selectedYear = inst.currentYear;
            } else {
                date = new Date();
                inst.selectedDay = date.getDate();
                inst.drawMonth = inst.selectedMonth = date.getMonth();
                inst.drawYear = inst.selectedYear = date.getFullYear();
            }
            this._notifyChange( inst );
            this._adjustDate( target );
        },
    
        /* Action for selecting a new month/year. */
        _selectMonthYear: function( id, select, period ) {
            var target = $( id ),
                inst = this._getInst( target[ 0 ] );
    
            inst[ "selected" + ( period === "M" ? "Month" : "Year" ) ] =
            inst[ "draw" + ( period === "M" ? "Month" : "Year" ) ] =
                parseInt( select.options[ select.selectedIndex ].value, 10 );
    
            this._notifyChange( inst );
            this._adjustDate( target );
        },
    
        /* Action for selecting a day. */
        _selectDay: function( id, month, year, td ) {
            var inst,
                target = $( id );
    
            if ( $( td ).hasClass( this._unselectableClass ) || this._isDisabledDatepicker( target[ 0 ] ) ) {
                return;
            }
    
            inst = this._getInst( target[ 0 ] );
            inst.selectedDay = inst.currentDay = $( "a", td ).html();
            inst.selectedMonth = inst.currentMonth = month;
            inst.selectedYear = inst.currentYear = year;
            this._selectDate( id, this._formatDate( inst,
                inst.currentDay, inst.currentMonth, inst.currentYear ) );
        },
    
        /* Erase the input field and hide the date picker. */
        _clearDate: function( id ) {
            var target = $( id );
            this._selectDate( target, "" );
        },
    
        /* Update the input field with the selected date. */
        _selectDate: function( id, dateStr ) {
            var onSelect,
                target = $( id ),
                inst = this._getInst( target[ 0 ] );
    
            dateStr = ( dateStr != null ? dateStr : this._formatDate( inst ) );
            if ( inst.input ) {
                inst.input.val( dateStr );
            }
            this._updateAlternate( inst );
    
            onSelect = this._get( inst, "onSelect" );
            if ( onSelect ) {
                onSelect.apply( ( inst.input ? inst.input[ 0 ] : null ), [ dateStr, inst ] );  // trigger custom callback
            } else if ( inst.input ) {
                inst.input.trigger( "change" ); // fire the change event
            }
    
            if ( inst.inline ) {
                this._updateDatepicker( inst );
            } else {
                this._hideDatepicker();
                this._lastInput = inst.input[ 0 ];
                if ( typeof( inst.input[ 0 ] ) !== "object" ) {
                    inst.input.trigger( "focus" ); // restore focus
                }
                this._lastInput = null;
            }
        },
    
        /* Update any alternate field to synchronise with the main field. */
        _updateAlternate: function( inst ) {
            var altFormat, date, dateStr,
                altField = this._get( inst, "altField" );
    
            if ( altField ) { // update alternate field too
                altFormat = this._get( inst, "altFormat" ) || this._get( inst, "dateFormat" );
                date = this._getDate( inst );
                dateStr = this.formatDate( altFormat, date, this._getFormatConfig( inst ) );
                $( altField ).val( dateStr );
            }
        },
    
        /* Set as beforeShowDay function to prevent selection of weekends.
         * @param  date  Date - the date to customise
         * @return [boolean, string] - is this date selectable?, what is its CSS class?
         */
        noWeekends: function( date ) {
            var day = date.getDay();
            return [ ( day > 0 && day < 6 ), "" ];
        },
    
        /* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
         * @param  date  Date - the date to get the week for
         * @return  number - the number of the week within the year that contains this date
         */
        iso8601Week: function( date ) {
            var time,
                checkDate = new Date( date.getTime() );
    
            // Find Thursday of this week starting on Monday
            checkDate.setDate( checkDate.getDate() + 4 - ( checkDate.getDay() || 7 ) );
    
            time = checkDate.getTime();
            checkDate.setMonth( 0 ); // Compare with Jan 1
            checkDate.setDate( 1 );
            return Math.floor( Math.round( ( time - checkDate ) / 86400000 ) / 7 ) + 1;
        },
    
        /* Parse a string value into a date object.
         * See formatDate below for the possible formats.
         *
         * @param  format string - the expected format of the date
         * @param  value string - the date in the above format
         * @param  settings Object - attributes include:
         *					shortYearCutoff  number - the cutoff year for determining the century (optional)
         *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
         *					dayNames		string[7] - names of the days from Sunday (optional)
         *					monthNamesShort string[12] - abbreviated names of the months (optional)
         *					monthNames		string[12] - names of the months (optional)
         * @return  Date - the extracted date value or null if value is blank
         */
        parseDate: function( format, value, settings ) {
            if ( format == null || value == null ) {
                throw "Invalid arguments";
            }
    
            value = ( typeof value === "object" ? value.toString() : value + "" );
            if ( value === "" ) {
                return null;
            }
    
            var iFormat, dim, extra,
                iValue = 0,
                shortYearCutoffTemp = ( settings ? settings.shortYearCutoff : null ) || this._defaults.shortYearCutoff,
                shortYearCutoff = ( typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
                    new Date().getFullYear() % 100 + parseInt( shortYearCutoffTemp, 10 ) ),
                dayNamesShort = ( settings ? settings.dayNamesShort : null ) || this._defaults.dayNamesShort,
                dayNames = ( settings ? settings.dayNames : null ) || this._defaults.dayNames,
                monthNamesShort = ( settings ? settings.monthNamesShort : null ) || this._defaults.monthNamesShort,
                monthNames = ( settings ? settings.monthNames : null ) || this._defaults.monthNames,
                year = -1,
                month = -1,
                day = -1,
                doy = -1,
                literal = false,
                date,
    
                // Check whether a format character is doubled
                lookAhead = function( match ) {
                    var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
                    if ( matches ) {
                        iFormat++;
                    }
                    return matches;
                },
    
                // Extract a number from the string value
                getNumber = function( match ) {
                    var isDoubled = lookAhead( match ),
                        size = ( match === "@" ? 14 : ( match === "!" ? 20 :
                        ( match === "y" && isDoubled ? 4 : ( match === "o" ? 3 : 2 ) ) ) ),
                        minSize = ( match === "y" ? size : 1 ),
                        digits = new RegExp( "^\\d{" + minSize + "," + size + "}" ),
                        num = value.substring( iValue ).match( digits );
                    if ( !num ) {
                        throw "Missing number at position " + iValue;
                    }
                    iValue += num[ 0 ].length;
                    return parseInt( num[ 0 ], 10 );
                },
    
                // Extract a name from the string value and convert to an index
                getName = function( match, shortNames, longNames ) {
                    var index = -1,
                        names = $.map( lookAhead( match ) ? longNames : shortNames, function( v, k ) {
                            return [ [ k, v ] ];
                        } ).sort( function( a, b ) {
                            return -( a[ 1 ].length - b[ 1 ].length );
                        } );
    
                    $.each( names, function( i, pair ) {
                        var name = pair[ 1 ];
                        if ( value.substr( iValue, name.length ).toLowerCase() === name.toLowerCase() ) {
                            index = pair[ 0 ];
                            iValue += name.length;
                            return false;
                        }
                    } );
                    if ( index !== -1 ) {
                        return index + 1;
                    } else {
                        throw "Unknown name at position " + iValue;
                    }
                },
    
                // Confirm that a literal character matches the string value
                checkLiteral = function() {
                    if ( value.charAt( iValue ) !== format.charAt( iFormat ) ) {
                        throw "Unexpected literal at position " + iValue;
                    }
                    iValue++;
                };
    
            for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
                if ( literal ) {
                    if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
                        literal = false;
                    } else {
                        checkLiteral();
                    }
                } else {
                    switch ( format.charAt( iFormat ) ) {
                        case "d":
                            day = getNumber( "d" );
                            break;
                        case "D":
                            getName( "D", dayNamesShort, dayNames );
                            break;
                        case "o":
                            doy = getNumber( "o" );
                            break;
                        case "m":
                            month = getNumber( "m" );
                            break;
                        case "M":
                            month = getName( "M", monthNamesShort, monthNames );
                            break;
                        case "y":
                            year = getNumber( "y" );
                            break;
                        case "@":
                            date = new Date( getNumber( "@" ) );
                            year = date.getFullYear();
                            month = date.getMonth() + 1;
                            day = date.getDate();
                            break;
                        case "!":
                            date = new Date( ( getNumber( "!" ) - this._ticksTo1970 ) / 10000 );
                            year = date.getFullYear();
                            month = date.getMonth() + 1;
                            day = date.getDate();
                            break;
                        case "'":
                            if ( lookAhead( "'" ) ) {
                                checkLiteral();
                            } else {
                                literal = true;
                            }
                            break;
                        default:
                            checkLiteral();
                    }
                }
            }
    
            if ( iValue < value.length ) {
                extra = value.substr( iValue );
                if ( !/^\s+/.test( extra ) ) {
                    throw "Extra/unparsed characters found in date: " + extra;
                }
            }
    
            if ( year === -1 ) {
                year = new Date().getFullYear();
            } else if ( year < 100 ) {
                year += new Date().getFullYear() - new Date().getFullYear() % 100 +
                    ( year <= shortYearCutoff ? 0 : -100 );
            }
    
            if ( doy > -1 ) {
                month = 1;
                day = doy;
                do {
                    dim = this._getDaysInMonth( year, month - 1 );
                    if ( day <= dim ) {
                        break;
                    }
                    month++;
                    day -= dim;
                } while ( true );
            }
    
            date = this._daylightSavingAdjust( new Date( year, month - 1, day ) );
            if ( date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day ) {
                throw "Invalid date"; // E.g. 31/02/00
            }
            return date;
        },
    
        /* Standard date formats. */
        ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
        COOKIE: "D, dd M yy",
        ISO_8601: "yy-mm-dd",
        RFC_822: "D, d M y",
        RFC_850: "DD, dd-M-y",
        RFC_1036: "D, d M y",
        RFC_1123: "D, d M yy",
        RFC_2822: "D, d M yy",
        RSS: "D, d M y", // RFC 822
        TICKS: "!",
        TIMESTAMP: "@",
        W3C: "yy-mm-dd", // ISO 8601
    
        _ticksTo1970: ( ( ( 1970 - 1 ) * 365 + Math.floor( 1970 / 4 ) - Math.floor( 1970 / 100 ) +
            Math.floor( 1970 / 400 ) ) * 24 * 60 * 60 * 10000000 ),
    
        /* Format a date object into a string value.
         * The format can be combinations of the following:
         * d  - day of month (no leading zero)
         * dd - day of month (two digit)
         * o  - day of year (no leading zeros)
         * oo - day of year (three digit)
         * D  - day name short
         * DD - day name long
         * m  - month of year (no leading zero)
         * mm - month of year (two digit)
         * M  - month name short
         * MM - month name long
         * y  - year (two digit)
         * yy - year (four digit)
         * @ - Unix timestamp (ms since 01/01/1970)
         * ! - Windows ticks (100ns since 01/01/0001)
         * "..." - literal text
         * '' - single quote
         *
         * @param  format string - the desired format of the date
         * @param  date Date - the date value to format
         * @param  settings Object - attributes include:
         *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
         *					dayNames		string[7] - names of the days from Sunday (optional)
         *					monthNamesShort string[12] - abbreviated names of the months (optional)
         *					monthNames		string[12] - names of the months (optional)
         * @return  string - the date in the above format
         */
        formatDate: function( format, date, settings ) {
            if ( !date ) {
                return "";
            }
    
            var iFormat,
                dayNamesShort = ( settings ? settings.dayNamesShort : null ) || this._defaults.dayNamesShort,
                dayNames = ( settings ? settings.dayNames : null ) || this._defaults.dayNames,
                monthNamesShort = ( settings ? settings.monthNamesShort : null ) || this._defaults.monthNamesShort,
                monthNames = ( settings ? settings.monthNames : null ) || this._defaults.monthNames,
    
                // Check whether a format character is doubled
                lookAhead = function( match ) {
                    var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
                    if ( matches ) {
                        iFormat++;
                    }
                    return matches;
                },
    
                // Format a number, with leading zero if necessary
                formatNumber = function( match, value, len ) {
                    var num = "" + value;
                    if ( lookAhead( match ) ) {
                        while ( num.length < len ) {
                            num = "0" + num;
                        }
                    }
                    return num;
                },
    
                // Format a name, short or long as requested
                formatName = function( match, value, shortNames, longNames ) {
                    return ( lookAhead( match ) ? longNames[ value ] : shortNames[ value ] );
                },
                output = "",
                literal = false;
    
            if ( date ) {
                for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
                    if ( literal ) {
                        if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
                            literal = false;
                        } else {
                            output += format.charAt( iFormat );
                        }
                    } else {
                        switch ( format.charAt( iFormat ) ) {
                            case "d":
                                output += formatNumber( "d", date.getDate(), 2 );
                                break;
                            case "D":
                                output += formatName( "D", date.getDay(), dayNamesShort, dayNames );
                                break;
                            case "o":
                                output += formatNumber( "o",
                                    Math.round( ( new Date( date.getFullYear(), date.getMonth(), date.getDate() ).getTime() - new Date( date.getFullYear(), 0, 0 ).getTime() ) / 86400000 ), 3 );
                                break;
                            case "m":
                                output += formatNumber( "m", date.getMonth() + 1, 2 );
                                break;
                            case "M":
                                output += formatName( "M", date.getMonth(), monthNamesShort, monthNames );
                                break;
                            case "y":
                                output += ( lookAhead( "y" ) ? date.getFullYear() :
                                    ( date.getFullYear() % 100 < 10 ? "0" : "" ) + date.getFullYear() % 100 );
                                break;
                            case "@":
                                output += date.getTime();
                                break;
                            case "!":
                                output += date.getTime() * 10000 + this._ticksTo1970;
                                break;
                            case "'":
                                if ( lookAhead( "'" ) ) {
                                    output += "'";
                                } else {
                                    literal = true;
                                }
                                break;
                            default:
                                output += format.charAt( iFormat );
                        }
                    }
                }
            }
            return output;
        },
    
        /* Extract all possible characters from the date format. */
        _possibleChars: function( format ) {
            var iFormat,
                chars = "",
                literal = false,
    
                // Check whether a format character is doubled
                lookAhead = function( match ) {
                    var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
                    if ( matches ) {
                        iFormat++;
                    }
                    return matches;
                };
    
            for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
                if ( literal ) {
                    if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
                        literal = false;
                    } else {
                        chars += format.charAt( iFormat );
                    }
                } else {
                    switch ( format.charAt( iFormat ) ) {
                        case "d": case "m": case "y": case "@":
                            chars += "0123456789";
                            break;
                        case "D": case "M":
                            return null; // Accept anything
                        case "'":
                            if ( lookAhead( "'" ) ) {
                                chars += "'";
                            } else {
                                literal = true;
                            }
                            break;
                        default:
                            chars += format.charAt( iFormat );
                    }
                }
            }
            return chars;
        },
    
        /* Get a setting value, defaulting if necessary. */
        _get: function( inst, name ) {
            return inst.settings[ name ] !== undefined ?
                inst.settings[ name ] : this._defaults[ name ];
        },
    
        /* Parse existing date and initialise date picker. */
        _setDateFromField: function( inst, noDefault ) {
            if ( inst.input.val() === inst.lastVal ) {
                return;
            }
    
            var dateFormat = this._get( inst, "dateFormat" ),
                dates = inst.lastVal = inst.input ? inst.input.val() : null,
                defaultDate = this._getDefaultDate( inst ),
                date = defaultDate,
                settings = this._getFormatConfig( inst );
    
            try {
                date = this.parseDate( dateFormat, dates, settings ) || defaultDate;
            } catch ( event ) {
                dates = ( noDefault ? "" : dates );
            }
            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();
            inst.currentDay = ( dates ? date.getDate() : 0 );
            inst.currentMonth = ( dates ? date.getMonth() : 0 );
            inst.currentYear = ( dates ? date.getFullYear() : 0 );
            this._adjustInstDate( inst );
        },
    
        /* Retrieve the default date shown on opening. */
        _getDefaultDate: function( inst ) {
            return this._restrictMinMax( inst,
                this._determineDate( inst, this._get( inst, "defaultDate" ), new Date() ) );
        },
    
        /* A date may be specified as an exact value or a relative one. */
        _determineDate: function( inst, date, defaultDate ) {
            var offsetNumeric = function( offset ) {
                    var date = new Date();
                    date.setDate( date.getDate() + offset );
                    return date;
                },
                offsetString = function( offset ) {
                    try {
                        return $.datepicker.parseDate( $.datepicker._get( inst, "dateFormat" ),
                            offset, $.datepicker._getFormatConfig( inst ) );
                    }
                    catch ( e ) {
    
                        // Ignore
                    }
    
                    var date = ( offset.toLowerCase().match( /^c/ ) ?
                        $.datepicker._getDate( inst ) : null ) || new Date(),
                        year = date.getFullYear(),
                        month = date.getMonth(),
                        day = date.getDate(),
                        pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
                        matches = pattern.exec( offset );
    
                    while ( matches ) {
                        switch ( matches[ 2 ] || "d" ) {
                            case "d" : case "D" :
                                day += parseInt( matches[ 1 ], 10 ); break;
                            case "w" : case "W" :
                                day += parseInt( matches[ 1 ], 10 ) * 7; break;
                            case "m" : case "M" :
                                month += parseInt( matches[ 1 ], 10 );
                                day = Math.min( day, $.datepicker._getDaysInMonth( year, month ) );
                                break;
                            case "y": case "Y" :
                                year += parseInt( matches[ 1 ], 10 );
                                day = Math.min( day, $.datepicker._getDaysInMonth( year, month ) );
                                break;
                        }
                        matches = pattern.exec( offset );
                    }
                    return new Date( year, month, day );
                },
                newDate = ( date == null || date === "" ? defaultDate : ( typeof date === "string" ? offsetString( date ) :
                    ( typeof date === "number" ? ( isNaN( date ) ? defaultDate : offsetNumeric( date ) ) : new Date( date.getTime() ) ) ) );
    
            newDate = ( newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate );
            if ( newDate ) {
                newDate.setHours( 0 );
                newDate.setMinutes( 0 );
                newDate.setSeconds( 0 );
                newDate.setMilliseconds( 0 );
            }
            return this._daylightSavingAdjust( newDate );
        },
    
        /* Handle switch to/from daylight saving.
         * Hours may be non-zero on daylight saving cut-over:
         * > 12 when midnight changeover, but then cannot generate
         * midnight datetime, so jump to 1AM, otherwise reset.
         * @param  date  (Date) the date to check
         * @return  (Date) the corrected date
         */
        _daylightSavingAdjust: function( date ) {
            if ( !date ) {
                return null;
            }
            date.setHours( date.getHours() > 12 ? date.getHours() + 2 : 0 );
            return date;
        },
    
        /* Set the date(s) directly. */
        _setDate: function( inst, date, noChange ) {
            var clear = !date,
                origMonth = inst.selectedMonth,
                origYear = inst.selectedYear,
                newDate = this._restrictMinMax( inst, this._determineDate( inst, date, new Date() ) );
    
            inst.selectedDay = inst.currentDay = newDate.getDate();
            inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
            inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
            if ( ( origMonth !== inst.selectedMonth || origYear !== inst.selectedYear ) && !noChange ) {
                this._notifyChange( inst );
            }
            this._adjustInstDate( inst );
            if ( inst.input ) {
                inst.input.val( clear ? "" : this._formatDate( inst ) );
            }
        },
    
        /* Retrieve the date(s) directly. */
        _getDate: function( inst ) {
            var startDate = ( !inst.currentYear || ( inst.input && inst.input.val() === "" ) ? null :
                this._daylightSavingAdjust( new Date(
                inst.currentYear, inst.currentMonth, inst.currentDay ) ) );
                return startDate;
        },
    
        /* Attach the onxxx handlers.  These are declared statically so
         * they work with static code transformers like Caja.
         */
        _attachHandlers: function( inst ) {
            var stepMonths = this._get( inst, "stepMonths" ),
                id = "#" + inst.id.replace( /\\\\/g, "\\" );
            inst.dpDiv.find( "[data-handler]" ).map( function() {
                var handler = {
                    prev: function() {
                        $.datepicker._adjustDate( id, -stepMonths, "M" );
                    },
                    next: function() {
                        $.datepicker._adjustDate( id, +stepMonths, "M" );
                    },
                    hide: function() {
                        $.datepicker._hideDatepicker();
                    },
                    today: function() {
                        $.datepicker._gotoToday( id );
                    },
                    selectDay: function() {
                        $.datepicker._selectDay( id, +this.getAttribute( "data-month" ), +this.getAttribute( "data-year" ), this );
                        return false;
                    },
                    selectMonth: function() {
                        $.datepicker._selectMonthYear( id, this, "M" );
                        return false;
                    },
                    selectYear: function() {
                        $.datepicker._selectMonthYear( id, this, "Y" );
                        return false;
                    }
                };
                $( this ).on( this.getAttribute( "data-event" ), handler[ this.getAttribute( "data-handler" ) ] );
            } );
        },
    
        /* Generate the HTML for the current state of the date picker. */
        _generateHTML: function( inst ) {
            var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
                controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
                monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
                selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
                cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
                printDate, dRow, tbody, daySettings, otherMonth, unselectable,
                tempDate = new Date(),
                today = this._daylightSavingAdjust(
                    new Date( tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate() ) ), // clear time
                isRTL = this._get( inst, "isRTL" ),
                showButtonPanel = this._get( inst, "showButtonPanel" ),
                hideIfNoPrevNext = this._get( inst, "hideIfNoPrevNext" ),
                navigationAsDateFormat = this._get( inst, "navigationAsDateFormat" ),
                numMonths = this._getNumberOfMonths( inst ),
                showCurrentAtPos = this._get( inst, "showCurrentAtPos" ),
                stepMonths = this._get( inst, "stepMonths" ),
                isMultiMonth = ( numMonths[ 0 ] !== 1 || numMonths[ 1 ] !== 1 ),
                currentDate = this._daylightSavingAdjust( ( !inst.currentDay ? new Date( 9999, 9, 9 ) :
                    new Date( inst.currentYear, inst.currentMonth, inst.currentDay ) ) ),
                minDate = this._getMinMaxDate( inst, "min" ),
                maxDate = this._getMinMaxDate( inst, "max" ),
                drawMonth = inst.drawMonth - showCurrentAtPos,
                drawYear = inst.drawYear;
    
            if ( drawMonth < 0 ) {
                drawMonth += 12;
                drawYear--;
            }
            if ( maxDate ) {
                maxDraw = this._daylightSavingAdjust( new Date( maxDate.getFullYear(),
                    maxDate.getMonth() - ( numMonths[ 0 ] * numMonths[ 1 ] ) + 1, maxDate.getDate() ) );
                maxDraw = ( minDate && maxDraw < minDate ? minDate : maxDraw );
                while ( this._daylightSavingAdjust( new Date( drawYear, drawMonth, 1 ) ) > maxDraw ) {
                    drawMonth--;
                    if ( drawMonth < 0 ) {
                        drawMonth = 11;
                        drawYear--;
                    }
                }
            }
            inst.drawMonth = drawMonth;
            inst.drawYear = drawYear;
    
            prevText = this._get( inst, "prevText" );
            prevText = ( !navigationAsDateFormat ? prevText : this.formatDate( prevText,
                this._daylightSavingAdjust( new Date( drawYear, drawMonth - stepMonths, 1 ) ),
                this._getFormatConfig( inst ) ) );
    
            prev = ( this._canAdjustMonth( inst, -1, drawYear, drawMonth ) ?
                "<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
                " title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w" ) + "'>" + prevText + "</span></a>" :
                ( hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w" ) + "'>" + prevText + "</span></a>" ) );
    
            nextText = this._get( inst, "nextText" );
            nextText = ( !navigationAsDateFormat ? nextText : this.formatDate( nextText,
                this._daylightSavingAdjust( new Date( drawYear, drawMonth + stepMonths, 1 ) ),
                this._getFormatConfig( inst ) ) );
    
            next = ( this._canAdjustMonth( inst, +1, drawYear, drawMonth ) ?
                "<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
                " title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e" ) + "'>" + nextText + "</span></a>" :
                ( hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e" ) + "'>" + nextText + "</span></a>" ) );
    
            currentText = this._get( inst, "currentText" );
            gotoDate = ( this._get( inst, "gotoCurrent" ) && inst.currentDay ? currentDate : today );
            currentText = ( !navigationAsDateFormat ? currentText :
                this.formatDate( currentText, gotoDate, this._getFormatConfig( inst ) ) );
    
            controls = ( !inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
                this._get( inst, "closeText" ) + "</button>" : "" );
    
            buttonPanel = ( showButtonPanel ) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + ( isRTL ? controls : "" ) +
                ( this._isInRange( inst, gotoDate ) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
                ">" + currentText + "</button>" : "" ) + ( isRTL ? "" : controls ) + "</div>" : "";
    
            firstDay = parseInt( this._get( inst, "firstDay" ), 10 );
            firstDay = ( isNaN( firstDay ) ? 0 : firstDay );
    
            showWeek = this._get( inst, "showWeek" );
            dayNames = this._get( inst, "dayNames" );
            dayNamesMin = this._get( inst, "dayNamesMin" );
            monthNames = this._get( inst, "monthNames" );
            monthNamesShort = this._get( inst, "monthNamesShort" );
            beforeShowDay = this._get( inst, "beforeShowDay" );
            showOtherMonths = this._get( inst, "showOtherMonths" );
            selectOtherMonths = this._get( inst, "selectOtherMonths" );
            defaultDate = this._getDefaultDate( inst );
            html = "";
    
            for ( row = 0; row < numMonths[ 0 ]; row++ ) {
                group = "";
                this.maxRows = 4;
                for ( col = 0; col < numMonths[ 1 ]; col++ ) {
                    selectedDate = this._daylightSavingAdjust( new Date( drawYear, drawMonth, inst.selectedDay ) );
                    cornerClass = " ui-corner-all";
                    calender = "";
                    if ( isMultiMonth ) {
                        calender += "<div class='ui-datepicker-group";
                        if ( numMonths[ 1 ] > 1 ) {
                            switch ( col ) {
                                case 0: calender += " ui-datepicker-group-first";
                                    cornerClass = " ui-corner-" + ( isRTL ? "right" : "left" ); break;
                                case numMonths[ 1 ] - 1: calender += " ui-datepicker-group-last";
                                    cornerClass = " ui-corner-" + ( isRTL ? "left" : "right" ); break;
                                default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;
                            }
                        }
                        calender += "'>";
                    }
                    calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
                        ( /all|left/.test( cornerClass ) && row === 0 ? ( isRTL ? next : prev ) : "" ) +
                        ( /all|right/.test( cornerClass ) && row === 0 ? ( isRTL ? prev : next ) : "" ) +
                        this._generateMonthYearHeader( inst, drawMonth, drawYear, minDate, maxDate,
                        row > 0 || col > 0, monthNames, monthNamesShort ) + // draw month headers
                        "</div><table class='ui-datepicker-calendar'><thead>" +
                        "<tr>";
                    thead = ( showWeek ? "<th class='ui-datepicker-week-col'>" + this._get( inst, "weekHeader" ) + "</th>" : "" );
                    for ( dow = 0; dow < 7; dow++ ) { // days of the week
                        day = ( dow + firstDay ) % 7;
                        thead += "<th scope='col'" + ( ( dow + firstDay + 6 ) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "" ) + ">" +
                            "<span title='" + dayNames[ day ] + "'>" + dayNamesMin[ day ] + "</span></th>";
                    }
                    calender += thead + "</tr></thead><tbody>";
                    daysInMonth = this._getDaysInMonth( drawYear, drawMonth );
                    if ( drawYear === inst.selectedYear && drawMonth === inst.selectedMonth ) {
                        inst.selectedDay = Math.min( inst.selectedDay, daysInMonth );
                    }
                    leadDays = ( this._getFirstDayOfMonth( drawYear, drawMonth ) - firstDay + 7 ) % 7;
                    curRows = Math.ceil( ( leadDays + daysInMonth ) / 7 ); // calculate the number of rows to generate
                    numRows = ( isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows ); //If multiple months, use the higher number of rows (see #7043)
                    this.maxRows = numRows;
                    printDate = this._daylightSavingAdjust( new Date( drawYear, drawMonth, 1 - leadDays ) );
                    for ( dRow = 0; dRow < numRows; dRow++ ) { // create date picker rows
                        calender += "<tr>";
                        tbody = ( !showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
                            this._get( inst, "calculateWeek" )( printDate ) + "</td>" );
                        for ( dow = 0; dow < 7; dow++ ) { // create date picker days
                            daySettings = ( beforeShowDay ?
                                beforeShowDay.apply( ( inst.input ? inst.input[ 0 ] : null ), [ printDate ] ) : [ true, "" ] );
                            otherMonth = ( printDate.getMonth() !== drawMonth );
                            unselectable = ( otherMonth && !selectOtherMonths ) || !daySettings[ 0 ] ||
                                ( minDate && printDate < minDate ) || ( maxDate && printDate > maxDate );
                            tbody += "<td class='" +
                                ( ( dow + firstDay + 6 ) % 7 >= 5 ? " ui-datepicker-week-end" : "" ) + // highlight weekends
                                ( otherMonth ? " ui-datepicker-other-month" : "" ) + // highlight days from other months
                                ( ( printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent ) || // user pressed key
                                ( defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime() ) ?
    
                                // or defaultDate is current printedDate and defaultDate is selectedDate
                                " " + this._dayOverClass : "" ) + // highlight selected day
                                ( unselectable ? " " + this._unselectableClass + " ui-state-disabled" : "" ) +  // highlight unselectable days
                                ( otherMonth && !showOtherMonths ? "" : " " + daySettings[ 1 ] + // highlight custom dates
                                ( printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "" ) + // highlight selected day
                                ( printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "" ) ) + "'" + // highlight today (if different)
                                ( ( !otherMonth || showOtherMonths ) && daySettings[ 2 ] ? " title='" + daySettings[ 2 ].replace( /'/g, "&#39;" ) + "'" : "" ) + // cell title
                                ( unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'" ) + ">" + // actions
                                ( otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
                                ( unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
                                ( printDate.getTime() === today.getTime() ? " ui-state-highlight" : "" ) +
                                ( printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "" ) + // highlight selected day
                                ( otherMonth ? " ui-priority-secondary" : "" ) + // distinguish dates from other months
                                "' href='#'>" + printDate.getDate() + "</a>" ) ) + "</td>"; // display selectable date
                            printDate.setDate( printDate.getDate() + 1 );
                            printDate = this._daylightSavingAdjust( printDate );
                        }
                        calender += tbody + "</tr>";
                    }
                    drawMonth++;
                    if ( drawMonth > 11 ) {
                        drawMonth = 0;
                        drawYear++;
                    }
                    calender += "</tbody></table>" + ( isMultiMonth ? "</div>" +
                                ( ( numMonths[ 0 ] > 0 && col === numMonths[ 1 ] - 1 ) ? "<div class='ui-datepicker-row-break'></div>" : "" ) : "" );
                    group += calender;
                }
                html += group;
            }
            html += buttonPanel;
            inst._keyEvent = false;
            return html;
        },
    
        /* Generate the month and year header. */
        _generateMonthYearHeader: function( inst, drawMonth, drawYear, minDate, maxDate,
                secondary, monthNames, monthNamesShort ) {
    
            var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
                changeMonth = this._get( inst, "changeMonth" ),
                changeYear = this._get( inst, "changeYear" ),
                showMonthAfterYear = this._get( inst, "showMonthAfterYear" ),
                html = "<div class='ui-datepicker-title'>",
                monthHtml = "";
    
            // Month selection
            if ( secondary || !changeMonth ) {
                monthHtml += "<span class='ui-datepicker-month'>" + monthNames[ drawMonth ] + "</span>";
            } else {
                inMinYear = ( minDate && minDate.getFullYear() === drawYear );
                inMaxYear = ( maxDate && maxDate.getFullYear() === drawYear );
                monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
                for ( month = 0; month < 12; month++ ) {
                    if ( ( !inMinYear || month >= minDate.getMonth() ) && ( !inMaxYear || month <= maxDate.getMonth() ) ) {
                        monthHtml += "<option value='" + month + "'" +
                            ( month === drawMonth ? " selected='selected'" : "" ) +
                            ">" + monthNamesShort[ month ] + "</option>";
                    }
                }
                monthHtml += "</select>";
            }
    
            if ( !showMonthAfterYear ) {
                html += monthHtml + ( secondary || !( changeMonth && changeYear ) ? "&#xa0;" : "" );
            }
    
            // Year selection
            if ( !inst.yearshtml ) {
                inst.yearshtml = "";
                if ( secondary || !changeYear ) {
                    html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
                } else {
    
                    // determine range of years to display
                    years = this._get( inst, "yearRange" ).split( ":" );
                    thisYear = new Date().getFullYear();
                    determineYear = function( value ) {
                        var year = ( value.match( /c[+\-].*/ ) ? drawYear + parseInt( value.substring( 1 ), 10 ) :
                            ( value.match( /[+\-].*/ ) ? thisYear + parseInt( value, 10 ) :
                            parseInt( value, 10 ) ) );
                        return ( isNaN( year ) ? thisYear : year );
                    };
                    year = determineYear( years[ 0 ] );
                    endYear = Math.max( year, determineYear( years[ 1 ] || "" ) );
                    year = ( minDate ? Math.max( year, minDate.getFullYear() ) : year );
                    endYear = ( maxDate ? Math.min( endYear, maxDate.getFullYear() ) : endYear );
                    inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
                    for ( ; year <= endYear; year++ ) {
                        inst.yearshtml += "<option value='" + year + "'" +
                            ( year === drawYear ? " selected='selected'" : "" ) +
                            ">" + year + "</option>";
                    }
                    inst.yearshtml += "</select>";
    
                    html += inst.yearshtml;
                    inst.yearshtml = null;
                }
            }
    
            html += this._get( inst, "yearSuffix" );
            if ( showMonthAfterYear ) {
                html += ( secondary || !( changeMonth && changeYear ) ? "&#xa0;" : "" ) + monthHtml;
            }
            html += "</div>"; // Close datepicker_header
            return html;
        },
    
        /* Adjust one of the date sub-fields. */
        _adjustInstDate: function( inst, offset, period ) {
            var year = inst.selectedYear + ( period === "Y" ? offset : 0 ),
                month = inst.selectedMonth + ( period === "M" ? offset : 0 ),
                day = Math.min( inst.selectedDay, this._getDaysInMonth( year, month ) ) + ( period === "D" ? offset : 0 ),
                date = this._restrictMinMax( inst, this._daylightSavingAdjust( new Date( year, month, day ) ) );
    
            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();
            if ( period === "M" || period === "Y" ) {
                this._notifyChange( inst );
            }
        },
    
        /* Ensure a date is within any min/max bounds. */
        _restrictMinMax: function( inst, date ) {
            var minDate = this._getMinMaxDate( inst, "min" ),
                maxDate = this._getMinMaxDate( inst, "max" ),
                newDate = ( minDate && date < minDate ? minDate : date );
            return ( maxDate && newDate > maxDate ? maxDate : newDate );
        },
    
        /* Notify change of month/year. */
        _notifyChange: function( inst ) {
            var onChange = this._get( inst, "onChangeMonthYear" );
            if ( onChange ) {
                onChange.apply( ( inst.input ? inst.input[ 0 ] : null ),
                    [ inst.selectedYear, inst.selectedMonth + 1, inst ] );
            }
        },
    
        /* Determine the number of months to show. */
        _getNumberOfMonths: function( inst ) {
            var numMonths = this._get( inst, "numberOfMonths" );
            return ( numMonths == null ? [ 1, 1 ] : ( typeof numMonths === "number" ? [ 1, numMonths ] : numMonths ) );
        },
    
        /* Determine the current maximum date - ensure no time components are set. */
        _getMinMaxDate: function( inst, minMax ) {
            return this._determineDate( inst, this._get( inst, minMax + "Date" ), null );
        },
    
        /* Find the number of days in a given month. */
        _getDaysInMonth: function( year, month ) {
            return 32 - this._daylightSavingAdjust( new Date( year, month, 32 ) ).getDate();
        },
    
        /* Find the day of the week of the first of a month. */
        _getFirstDayOfMonth: function( year, month ) {
            return new Date( year, month, 1 ).getDay();
        },
    
        /* Determines if we should allow a "next/prev" month display change. */
        _canAdjustMonth: function( inst, offset, curYear, curMonth ) {
            var numMonths = this._getNumberOfMonths( inst ),
                date = this._daylightSavingAdjust( new Date( curYear,
                curMonth + ( offset < 0 ? offset : numMonths[ 0 ] * numMonths[ 1 ] ), 1 ) );
    
            if ( offset < 0 ) {
                date.setDate( this._getDaysInMonth( date.getFullYear(), date.getMonth() ) );
            }
            return this._isInRange( inst, date );
        },
    
        /* Is the given date in the accepted range? */
        _isInRange: function( inst, date ) {
            var yearSplit, currentYear,
                minDate = this._getMinMaxDate( inst, "min" ),
                maxDate = this._getMinMaxDate( inst, "max" ),
                minYear = null,
                maxYear = null,
                years = this._get( inst, "yearRange" );
                if ( years ) {
                    yearSplit = years.split( ":" );
                    currentYear = new Date().getFullYear();
                    minYear = parseInt( yearSplit[ 0 ], 10 );
                    maxYear = parseInt( yearSplit[ 1 ], 10 );
                    if ( yearSplit[ 0 ].match( /[+\-].*/ ) ) {
                        minYear += currentYear;
                    }
                    if ( yearSplit[ 1 ].match( /[+\-].*/ ) ) {
                        maxYear += currentYear;
                    }
                }
    
            return ( ( !minDate || date.getTime() >= minDate.getTime() ) &&
                ( !maxDate || date.getTime() <= maxDate.getTime() ) &&
                ( !minYear || date.getFullYear() >= minYear ) &&
                ( !maxYear || date.getFullYear() <= maxYear ) );
        },
    
        /* Provide the configuration settings for formatting/parsing. */
        _getFormatConfig: function( inst ) {
            var shortYearCutoff = this._get( inst, "shortYearCutoff" );
            shortYearCutoff = ( typeof shortYearCutoff !== "string" ? shortYearCutoff :
                new Date().getFullYear() % 100 + parseInt( shortYearCutoff, 10 ) );
            return { shortYearCutoff: shortYearCutoff,
                dayNamesShort: this._get( inst, "dayNamesShort" ), dayNames: this._get( inst, "dayNames" ),
                monthNamesShort: this._get( inst, "monthNamesShort" ), monthNames: this._get( inst, "monthNames" ) };
        },
    
        /* Format the given date for display. */
        _formatDate: function( inst, day, month, year ) {
            if ( !day ) {
                inst.currentDay = inst.selectedDay;
                inst.currentMonth = inst.selectedMonth;
                inst.currentYear = inst.selectedYear;
            }
            var date = ( day ? ( typeof day === "object" ? day :
                this._daylightSavingAdjust( new Date( year, month, day ) ) ) :
                this._daylightSavingAdjust( new Date( inst.currentYear, inst.currentMonth, inst.currentDay ) ) );
            return this.formatDate( this._get( inst, "dateFormat" ), date, this._getFormatConfig( inst ) );
        }
    } );
    
    /*
     * Bind hover events for datepicker elements.
     * Done via delegate so the binding only occurs once in the lifetime of the parent div.
     * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
     */
    function datepicker_bindHover( dpDiv ) {
        var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
        return dpDiv.on( "mouseout", selector, function() {
                $( this ).removeClass( "ui-state-hover" );
                if ( this.className.indexOf( "ui-datepicker-prev" ) !== -1 ) {
                    $( this ).removeClass( "ui-datepicker-prev-hover" );
                }
                if ( this.className.indexOf( "ui-datepicker-next" ) !== -1 ) {
                    $( this ).removeClass( "ui-datepicker-next-hover" );
                }
            } )
            .on( "mouseover", selector, datepicker_handleMouseover );
    }
    
    function datepicker_handleMouseover() {
        if ( !$.datepicker._isDisabledDatepicker( datepicker_instActive.inline ? datepicker_instActive.dpDiv.parent()[ 0 ] : datepicker_instActive.input[ 0 ] ) ) {
            $( this ).parents( ".ui-datepicker-calendar" ).find( "a" ).removeClass( "ui-state-hover" );
            $( this ).addClass( "ui-state-hover" );
            if ( this.className.indexOf( "ui-datepicker-prev" ) !== -1 ) {
                $( this ).addClass( "ui-datepicker-prev-hover" );
            }
            if ( this.className.indexOf( "ui-datepicker-next" ) !== -1 ) {
                $( this ).addClass( "ui-datepicker-next-hover" );
            }
        }
    }
    
    /* jQuery extend now ignores nulls! */
    function datepicker_extendRemove( target, props ) {
        $.extend( target, props );
        for ( var name in props ) {
            if ( props[ name ] == null ) {
                target[ name ] = props[ name ];
            }
        }
        return target;
    }
    
    /* Invoke the datepicker functionality.
       @param  options  string - a command, optionally followed by additional parameters or
                        Object - settings for attaching new datepicker functionality
       @return  jQuery object */
    $.fn.datepicker = function( options ) {
    
        /* Verify an empty collection wasn't passed - Fixes #6976 */
        if ( !this.length ) {
            return this;
        }
    
        /* Initialise the date picker. */
        if ( !$.datepicker.initialized ) {
            $( document ).on( "mousedown", $.datepicker._checkExternalClick );
            $.datepicker.initialized = true;
        }
    
        /* Append datepicker main container to body if not exist. */
        if ( $( "#" + $.datepicker._mainDivId ).length === 0 ) {
            $( "body" ).append( $.datepicker.dpDiv );
        }
    
        var otherArgs = Array.prototype.slice.call( arguments, 1 );
        if ( typeof options === "string" && ( options === "isDisabled" || options === "getDate" || options === "widget" ) ) {
            return $.datepicker[ "_" + options + "Datepicker" ].
                apply( $.datepicker, [ this[ 0 ] ].concat( otherArgs ) );
        }
        if ( options === "option" && arguments.length === 2 && typeof arguments[ 1 ] === "string" ) {
            return $.datepicker[ "_" + options + "Datepicker" ].
                apply( $.datepicker, [ this[ 0 ] ].concat( otherArgs ) );
        }
        return this.each( function() {
            typeof options === "string" ?
                $.datepicker[ "_" + options + "Datepicker" ].
                    apply( $.datepicker, [ this ].concat( otherArgs ) ) :
                $.datepicker._attachDatepicker( this, options );
        } );
    };
    
    $.datepicker = new Datepicker(); // singleton instance
    $.datepicker.initialized = false;
    $.datepicker.uuid = new Date().getTime();
    $.datepicker.version = "1.12.1";
    
    return $.datepicker;
    
    } ) );
    
    },{}],63:[function(require,module,exports){
    arguments[4][60][0].apply(exports,arguments)
    },{"dup":60}],64:[function(require,module,exports){
    /*!
     * Knockout JavaScript library v3.4.2
     * (c) The Knockout.js team - http://knockoutjs.com/
     * License: MIT (http://www.opensource.org/licenses/mit-license.php)
     */
    
    (function(){
    var DEBUG=true;
    (function(undefined){
        // (0, eval)('this') is a robust way of getting a reference to the global object
        // For details, see http://stackoverflow.com/questions/14119988/return-this-0-evalthis/14120023#14120023
        var window = this || (0, eval)('this'),
            document = window['document'],
            navigator = window['navigator'],
            jQueryInstance = window["jQuery"],
            JSON = window["JSON"];
    (function(factory) {
        // Support three module loading scenarios
        if (typeof define === 'function' && define['amd']) {
            // [1] AMD anonymous module
            define(['exports', 'require'], factory);
        } else if (typeof exports === 'object' && typeof module === 'object') {
            // [2] CommonJS/Node.js
            factory(module['exports'] || exports);  // module.exports is for Node.js
        } else {
            // [3] No module loader (plain <script> tag) - put directly in global namespace
            factory(window['ko'] = {});
        }
    }(function(koExports, amdRequire){
    // Internally, all KO objects are attached to koExports (even the non-exported ones whose names will be minified by the closure compiler).
    // In the future, the following "ko" variable may be made distinct from "koExports" so that private objects are not externally reachable.
    var ko = typeof koExports !== 'undefined' ? koExports : {};
    // Google Closure Compiler helpers (used only to make the minified file smaller)
    ko.exportSymbol = function(koPath, object) {
        var tokens = koPath.split(".");
    
        // In the future, "ko" may become distinct from "koExports" (so that non-exported objects are not reachable)
        // At that point, "target" would be set to: (typeof koExports !== "undefined" ? koExports : ko)
        var target = ko;
    
        for (var i = 0; i < tokens.length - 1; i++)
            target = target[tokens[i]];
        target[tokens[tokens.length - 1]] = object;
    };
    ko.exportProperty = function(owner, publicName, object) {
        owner[publicName] = object;
    };
    ko.version = "3.4.2";
    
    ko.exportSymbol('version', ko.version);
    // For any options that may affect various areas of Knockout and aren't directly associated with data binding.
    ko.options = {
        'deferUpdates': false,
        'useOnlyNativeEvents': false
    };
    
    //ko.exportSymbol('options', ko.options);   // 'options' isn't minified
    ko.utils = (function () {
        function objectForEach(obj, action) {
            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    action(prop, obj[prop]);
                }
            }
        }
    
        function extend(target, source) {
            if (source) {
                for(var prop in source) {
                    if(source.hasOwnProperty(prop)) {
                        target[prop] = source[prop];
                    }
                }
            }
            return target;
        }
    
        function setPrototypeOf(obj, proto) {
            obj.__proto__ = proto;
            return obj;
        }
    
        var canSetPrototype = ({ __proto__: [] } instanceof Array);
        var canUseSymbols = !DEBUG && typeof Symbol === 'function';
    
        // Represent the known event types in a compact way, then at runtime transform it into a hash with event name as key (for fast lookup)
        var knownEvents = {}, knownEventTypesByEventName = {};
        var keyEventTypeName = (navigator && /Firefox\/2/i.test(navigator.userAgent)) ? 'KeyboardEvent' : 'UIEvents';
        knownEvents[keyEventTypeName] = ['keyup', 'keydown', 'keypress'];
        knownEvents['MouseEvents'] = ['click', 'dblclick', 'mousedown', 'mouseup', 'mousemove', 'mouseover', 'mouseout', 'mouseenter', 'mouseleave'];
        objectForEach(knownEvents, function(eventType, knownEventsForType) {
            if (knownEventsForType.length) {
                for (var i = 0, j = knownEventsForType.length; i < j; i++)
                    knownEventTypesByEventName[knownEventsForType[i]] = eventType;
            }
        });
        var eventsThatMustBeRegisteredUsingAttachEvent = { 'propertychange': true }; // Workaround for an IE9 issue - https://github.com/SteveSanderson/knockout/issues/406
    
        // Detect IE versions for bug workarounds (uses IE conditionals, not UA string, for robustness)
        // Note that, since IE 10 does not support conditional comments, the following logic only detects IE < 10.
        // Currently this is by design, since IE 10+ behaves correctly when treated as a standard browser.
        // If there is a future need to detect specific versions of IE10+, we will amend this.
        var ieVersion = document && (function() {
            var version = 3, div = document.createElement('div'), iElems = div.getElementsByTagName('i');
    
            // Keep constructing conditional HTML blocks until we hit one that resolves to an empty fragment
            while (
                div.innerHTML = '<!--[if gt IE ' + (++version) + ']><i></i><![endif]-->',
                iElems[0]
            ) {}
            return version > 4 ? version : undefined;
        }());
        var isIe6 = ieVersion === 6,
            isIe7 = ieVersion === 7;
    
        function isClickOnCheckableElement(element, eventType) {
            if ((ko.utils.tagNameLower(element) !== "input") || !element.type) return false;
            if (eventType.toLowerCase() != "click") return false;
            var inputType = element.type;
            return (inputType == "checkbox") || (inputType == "radio");
        }
    
        // For details on the pattern for changing node classes
        // see: https://github.com/knockout/knockout/issues/1597
        var cssClassNameRegex = /\S+/g;
    
        function toggleDomNodeCssClass(node, classNames, shouldHaveClass) {
            var addOrRemoveFn;
            if (classNames) {
                if (typeof node.classList === 'object') {
                    addOrRemoveFn = node.classList[shouldHaveClass ? 'add' : 'remove'];
                    ko.utils.arrayForEach(classNames.match(cssClassNameRegex), function(className) {
                        addOrRemoveFn.call(node.classList, className);
                    });
                } else if (typeof node.className['baseVal'] === 'string') {
                    // SVG tag .classNames is an SVGAnimatedString instance
                    toggleObjectClassPropertyString(node.className, 'baseVal', classNames, shouldHaveClass);
                } else {
                    // node.className ought to be a string.
                    toggleObjectClassPropertyString(node, 'className', classNames, shouldHaveClass);
                }
            }
        }
    
        function toggleObjectClassPropertyString(obj, prop, classNames, shouldHaveClass) {
            // obj/prop is either a node/'className' or a SVGAnimatedString/'baseVal'.
            var currentClassNames = obj[prop].match(cssClassNameRegex) || [];
            ko.utils.arrayForEach(classNames.match(cssClassNameRegex), function(className) {
                ko.utils.addOrRemoveItem(currentClassNames, className, shouldHaveClass);
            });
            obj[prop] = currentClassNames.join(" ");
        }
    
        return {
            fieldsIncludedWithJsonPost: ['authenticity_token', /^__RequestVerificationToken(_.*)?$/],
    
            arrayForEach: function (array, action) {
                for (var i = 0, j = array.length; i < j; i++)
                    action(array[i], i);
            },
    
            arrayIndexOf: function (array, item) {
                if (typeof Array.prototype.indexOf == "function")
                    return Array.prototype.indexOf.call(array, item);
                for (var i = 0, j = array.length; i < j; i++)
                    if (array[i] === item)
                        return i;
                return -1;
            },
    
            arrayFirst: function (array, predicate, predicateOwner) {
                for (var i = 0, j = array.length; i < j; i++)
                    if (predicate.call(predicateOwner, array[i], i))
                        return array[i];
                return null;
            },
    
            arrayRemoveItem: function (array, itemToRemove) {
                var index = ko.utils.arrayIndexOf(array, itemToRemove);
                if (index > 0) {
                    array.splice(index, 1);
                }
                else if (index === 0) {
                    array.shift();
                }
            },
    
            arrayGetDistinctValues: function (array) {
                array = array || [];
                var result = [];
                for (var i = 0, j = array.length; i < j; i++) {
                    if (ko.utils.arrayIndexOf(result, array[i]) < 0)
                        result.push(array[i]);
                }
                return result;
            },
    
            arrayMap: function (array, mapping) {
                array = array || [];
                var result = [];
                for (var i = 0, j = array.length; i < j; i++)
                    result.push(mapping(array[i], i));
                return result;
            },
    
            arrayFilter: function (array, predicate) {
                array = array || [];
                var result = [];
                for (var i = 0, j = array.length; i < j; i++)
                    if (predicate(array[i], i))
                        result.push(array[i]);
                return result;
            },
    
            arrayPushAll: function (array, valuesToPush) {
                if (valuesToPush instanceof Array)
                    array.push.apply(array, valuesToPush);
                else
                    for (var i = 0, j = valuesToPush.length; i < j; i++)
                        array.push(valuesToPush[i]);
                return array;
            },
    
            addOrRemoveItem: function(array, value, included) {
                var existingEntryIndex = ko.utils.arrayIndexOf(ko.utils.peekObservable(array), value);
                if (existingEntryIndex < 0) {
                    if (included)
                        array.push(value);
                } else {
                    if (!included)
                        array.splice(existingEntryIndex, 1);
                }
            },
    
            canSetPrototype: canSetPrototype,
    
            extend: extend,
    
            setPrototypeOf: setPrototypeOf,
    
            setPrototypeOfOrExtend: canSetPrototype ? setPrototypeOf : extend,
    
            objectForEach: objectForEach,
    
            objectMap: function(source, mapping) {
                if (!source)
                    return source;
                var target = {};
                for (var prop in source) {
                    if (source.hasOwnProperty(prop)) {
                        target[prop] = mapping(source[prop], prop, source);
                    }
                }
                return target;
            },
    
            emptyDomNode: function (domNode) {
                while (domNode.firstChild) {
                    ko.removeNode(domNode.firstChild);
                }
            },
    
            moveCleanedNodesToContainerElement: function(nodes) {
                // Ensure it's a real array, as we're about to reparent the nodes and
                // we don't want the underlying collection to change while we're doing that.
                var nodesArray = ko.utils.makeArray(nodes);
                var templateDocument = (nodesArray[0] && nodesArray[0].ownerDocument) || document;
    
                var container = templateDocument.createElement('div');
                for (var i = 0, j = nodesArray.length; i < j; i++) {
                    container.appendChild(ko.cleanNode(nodesArray[i]));
                }
                return container;
            },
    
            cloneNodes: function (nodesArray, shouldCleanNodes) {
                for (var i = 0, j = nodesArray.length, newNodesArray = []; i < j; i++) {
                    var clonedNode = nodesArray[i].cloneNode(true);
                    newNodesArray.push(shouldCleanNodes ? ko.cleanNode(clonedNode) : clonedNode);
                }
                return newNodesArray;
            },
    
            setDomNodeChildren: function (domNode, childNodes) {
                ko.utils.emptyDomNode(domNode);
                if (childNodes) {
                    for (var i = 0, j = childNodes.length; i < j; i++)
                        domNode.appendChild(childNodes[i]);
                }
            },
    
            replaceDomNodes: function (nodeToReplaceOrNodeArray, newNodesArray) {
                var nodesToReplaceArray = nodeToReplaceOrNodeArray.nodeType ? [nodeToReplaceOrNodeArray] : nodeToReplaceOrNodeArray;
                if (nodesToReplaceArray.length > 0) {
                    var insertionPoint = nodesToReplaceArray[0];
                    var parent = insertionPoint.parentNode;
                    for (var i = 0, j = newNodesArray.length; i < j; i++)
                        parent.insertBefore(newNodesArray[i], insertionPoint);
                    for (var i = 0, j = nodesToReplaceArray.length; i < j; i++) {
                        ko.removeNode(nodesToReplaceArray[i]);
                    }
                }
            },
    
            fixUpContinuousNodeArray: function(continuousNodeArray, parentNode) {
                // Before acting on a set of nodes that were previously outputted by a template function, we have to reconcile
                // them against what is in the DOM right now. It may be that some of the nodes have already been removed, or that
                // new nodes might have been inserted in the middle, for example by a binding. Also, there may previously have been
                // leading comment nodes (created by rewritten string-based templates) that have since been removed during binding.
                // So, this function translates the old "map" output array into its best guess of the set of current DOM nodes.
                //
                // Rules:
                //   [A] Any leading nodes that have been removed should be ignored
                //       These most likely correspond to memoization nodes that were already removed during binding
                //       See https://github.com/knockout/knockout/pull/440
                //   [B] Any trailing nodes that have been remove should be ignored
                //       This prevents the code here from adding unrelated nodes to the array while processing rule [C]
                //       See https://github.com/knockout/knockout/pull/1903
                //   [C] We want to output a continuous series of nodes. So, ignore any nodes that have already been removed,
                //       and include any nodes that have been inserted among the previous collection
    
                if (continuousNodeArray.length) {
                    // The parent node can be a virtual element; so get the real parent node
                    parentNode = (parentNode.nodeType === 8 && parentNode.parentNode) || parentNode;
    
                    // Rule [A]
                    while (continuousNodeArray.length && continuousNodeArray[0].parentNode !== parentNode)
                        continuousNodeArray.splice(0, 1);
    
                    // Rule [B]
                    while (continuousNodeArray.length > 1 && continuousNodeArray[continuousNodeArray.length - 1].parentNode !== parentNode)
                        continuousNodeArray.length--;
    
                    // Rule [C]
                    if (continuousNodeArray.length > 1) {
                        var current = continuousNodeArray[0], last = continuousNodeArray[continuousNodeArray.length - 1];
                        // Replace with the actual new continuous node set
                        continuousNodeArray.length = 0;
                        while (current !== last) {
                            continuousNodeArray.push(current);
                            current = current.nextSibling;
                        }
                        continuousNodeArray.push(last);
                    }
                }
                return continuousNodeArray;
            },
    
            setOptionNodeSelectionState: function (optionNode, isSelected) {
                // IE6 sometimes throws "unknown error" if you try to write to .selected directly, whereas Firefox struggles with setAttribute. Pick one based on browser.
                if (ieVersion < 7)
                    optionNode.setAttribute("selected", isSelected);
                else
                    optionNode.selected = isSelected;
            },
    
            stringTrim: function (string) {
                return string === null || string === undefined ? '' :
                    string.trim ?
                        string.trim() :
                        string.toString().replace(/^[\s\xa0]+|[\s\xa0]+$/g, '');
            },
    
            stringStartsWith: function (string, startsWith) {
                string = string || "";
                if (startsWith.length > string.length)
                    return false;
                return string.substring(0, startsWith.length) === startsWith;
            },
    
            domNodeIsContainedBy: function (node, containedByNode) {
                if (node === containedByNode)
                    return true;
                if (node.nodeType === 11)
                    return false; // Fixes issue #1162 - can't use node.contains for document fragments on IE8
                if (containedByNode.contains)
                    return containedByNode.contains(node.nodeType === 3 ? node.parentNode : node);
                if (containedByNode.compareDocumentPosition)
                    return (containedByNode.compareDocumentPosition(node) & 16) == 16;
                while (node && node != containedByNode) {
                    node = node.parentNode;
                }
                return !!node;
            },
    
            domNodeIsAttachedToDocument: function (node) {
                return ko.utils.domNodeIsContainedBy(node, node.ownerDocument.documentElement);
            },
    
            anyDomNodeIsAttachedToDocument: function(nodes) {
                return !!ko.utils.arrayFirst(nodes, ko.utils.domNodeIsAttachedToDocument);
            },
    
            tagNameLower: function(element) {
                // For HTML elements, tagName will always be upper case; for XHTML elements, it'll be lower case.
                // Possible future optimization: If we know it's an element from an XHTML document (not HTML),
                // we don't need to do the .toLowerCase() as it will always be lower case anyway.
                return element && element.tagName && element.tagName.toLowerCase();
            },
    
            catchFunctionErrors: function (delegate) {
                return ko['onError'] ? function () {
                    try {
                        return delegate.apply(this, arguments);
                    } catch (e) {
                        ko['onError'] && ko['onError'](e);
                        throw e;
                    }
                } : delegate;
            },
    
            setTimeout: function (handler, timeout) {
                return setTimeout(ko.utils.catchFunctionErrors(handler), timeout);
            },
    
            deferError: function (error) {
                setTimeout(function () {
                    ko['onError'] && ko['onError'](error);
                    throw error;
                }, 0);
            },
    
            registerEventHandler: function (element, eventType, handler) {
                var wrappedHandler = ko.utils.catchFunctionErrors(handler);
    
                var mustUseAttachEvent = ieVersion && eventsThatMustBeRegisteredUsingAttachEvent[eventType];
                if (!ko.options['useOnlyNativeEvents'] && !mustUseAttachEvent && jQueryInstance) {
                    jQueryInstance(element)['bind'](eventType, wrappedHandler);
                } else if (!mustUseAttachEvent && typeof element.addEventListener == "function")
                    element.addEventListener(eventType, wrappedHandler, false);
                else if (typeof element.attachEvent != "undefined") {
                    var attachEventHandler = function (event) { wrappedHandler.call(element, event); },
                        attachEventName = "on" + eventType;
                    element.attachEvent(attachEventName, attachEventHandler);
    
                    // IE does not dispose attachEvent handlers automatically (unlike with addEventListener)
                    // so to avoid leaks, we have to remove them manually. See bug #856
                    ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
                        element.detachEvent(attachEventName, attachEventHandler);
                    });
                } else
                    throw new Error("Browser doesn't support addEventListener or attachEvent");
            },
    
            triggerEvent: function (element, eventType) {
                if (!(element && element.nodeType))
                    throw new Error("element must be a DOM node when calling triggerEvent");
    
                // For click events on checkboxes and radio buttons, jQuery toggles the element checked state *after* the
                // event handler runs instead of *before*. (This was fixed in 1.9 for checkboxes but not for radio buttons.)
                // IE doesn't change the checked state when you trigger the click event using "fireEvent".
                // In both cases, we'll use the click method instead.
                var useClickWorkaround = isClickOnCheckableElement(element, eventType);
    
                if (!ko.options['useOnlyNativeEvents'] && jQueryInstance && !useClickWorkaround) {
                    jQueryInstance(element)['trigger'](eventType);
                } else if (typeof document.createEvent == "function") {
                    if (typeof element.dispatchEvent == "function") {
                        var eventCategory = knownEventTypesByEventName[eventType] || "HTMLEvents";
                        var event = document.createEvent(eventCategory);
                        event.initEvent(eventType, true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, element);
                        element.dispatchEvent(event);
                    }
                    else
                        throw new Error("The supplied element doesn't support dispatchEvent");
                } else if (useClickWorkaround && element.click) {
                    element.click();
                } else if (typeof element.fireEvent != "undefined") {
                    element.fireEvent("on" + eventType);
                } else {
                    throw new Error("Browser doesn't support triggering events");
                }
            },
    
            unwrapObservable: function (value) {
                return ko.isObservable(value) ? value() : value;
            },
    
            peekObservable: function (value) {
                return ko.isObservable(value) ? value.peek() : value;
            },
    
            toggleDomNodeCssClass: toggleDomNodeCssClass,
    
            setTextContent: function(element, textContent) {
                var value = ko.utils.unwrapObservable(textContent);
                if ((value === null) || (value === undefined))
                    value = "";
    
                // We need there to be exactly one child: a text node.
                // If there are no children, more than one, or if it's not a text node,
                // we'll clear everything and create a single text node.
                var innerTextNode = ko.virtualElements.firstChild(element);
                if (!innerTextNode || innerTextNode.nodeType != 3 || ko.virtualElements.nextSibling(innerTextNode)) {
                    ko.virtualElements.setDomNodeChildren(element, [element.ownerDocument.createTextNode(value)]);
                } else {
                    innerTextNode.data = value;
                }
    
                ko.utils.forceRefresh(element);
            },
    
            setElementName: function(element, name) {
                element.name = name;
    
                // Workaround IE 6/7 issue
                // - https://github.com/SteveSanderson/knockout/issues/197
                // - http://www.matts411.com/post/setting_the_name_attribute_in_ie_dom/
                if (ieVersion <= 7) {
                    try {
                        element.mergeAttributes(document.createElement("<input name='" + element.name + "'/>"), false);
                    }
                    catch(e) {} // For IE9 with doc mode "IE9 Standards" and browser mode "IE9 Compatibility View"
                }
            },
    
            forceRefresh: function(node) {
                // Workaround for an IE9 rendering bug - https://github.com/SteveSanderson/knockout/issues/209
                if (ieVersion >= 9) {
                    // For text nodes and comment nodes (most likely virtual elements), we will have to refresh the container
                    var elem = node.nodeType == 1 ? node : node.parentNode;
                    if (elem.style)
                        elem.style.zoom = elem.style.zoom;
                }
            },
    
            ensureSelectElementIsRenderedCorrectly: function(selectElement) {
                // Workaround for IE9 rendering bug - it doesn't reliably display all the text in dynamically-added select boxes unless you force it to re-render by updating the width.
                // (See https://github.com/SteveSanderson/knockout/issues/312, http://stackoverflow.com/questions/5908494/select-only-shows-first-char-of-selected-option)
                // Also fixes IE7 and IE8 bug that causes selects to be zero width if enclosed by 'if' or 'with'. (See issue #839)
                if (ieVersion) {
                    var originalWidth = selectElement.style.width;
                    selectElement.style.width = 0;
                    selectElement.style.width = originalWidth;
                }
            },
    
            range: function (min, max) {
                min = ko.utils.unwrapObservable(min);
                max = ko.utils.unwrapObservable(max);
                var result = [];
                for (var i = min; i <= max; i++)
                    result.push(i);
                return result;
            },
    
            makeArray: function(arrayLikeObject) {
                var result = [];
                for (var i = 0, j = arrayLikeObject.length; i < j; i++) {
                    result.push(arrayLikeObject[i]);
                };
                return result;
            },
    
            createSymbolOrString: function(identifier) {
                return canUseSymbols ? Symbol(identifier) : identifier;
            },
    
            isIe6 : isIe6,
            isIe7 : isIe7,
            ieVersion : ieVersion,
    
            getFormFields: function(form, fieldName) {
                var fields = ko.utils.makeArray(form.getElementsByTagName("input")).concat(ko.utils.makeArray(form.getElementsByTagName("textarea")));
                var isMatchingField = (typeof fieldName == 'string')
                    ? function(field) { return field.name === fieldName }
                    : function(field) { return fieldName.test(field.name) }; // Treat fieldName as regex or object containing predicate
                var matches = [];
                for (var i = fields.length - 1; i >= 0; i--) {
                    if (isMatchingField(fields[i]))
                        matches.push(fields[i]);
                };
                return matches;
            },
    
            parseJson: function (jsonString) {
                if (typeof jsonString == "string") {
                    jsonString = ko.utils.stringTrim(jsonString);
                    if (jsonString) {
                        if (JSON && JSON.parse) // Use native parsing where available
                            return JSON.parse(jsonString);
                        return (new Function("return " + jsonString))(); // Fallback on less safe parsing for older browsers
                    }
                }
                return null;
            },
    
            stringifyJson: function (data, replacer, space) {   // replacer and space are optional
                if (!JSON || !JSON.stringify)
                    throw new Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");
                return JSON.stringify(ko.utils.unwrapObservable(data), replacer, space);
            },
    
            postJson: function (urlOrForm, data, options) {
                options = options || {};
                var params = options['params'] || {};
                var includeFields = options['includeFields'] || this.fieldsIncludedWithJsonPost;
                var url = urlOrForm;
    
                // If we were given a form, use its 'action' URL and pick out any requested field values
                if((typeof urlOrForm == 'object') && (ko.utils.tagNameLower(urlOrForm) === "form")) {
                    var originalForm = urlOrForm;
                    url = originalForm.action;
                    for (var i = includeFields.length - 1; i >= 0; i--) {
                        var fields = ko.utils.getFormFields(originalForm, includeFields[i]);
                        for (var j = fields.length - 1; j >= 0; j--)
                            params[fields[j].name] = fields[j].value;
                    }
                }
    
                data = ko.utils.unwrapObservable(data);
                var form = document.createElement("form");
                form.style.display = "none";
                form.action = url;
                form.method = "post";
                for (var key in data) {
                    // Since 'data' this is a model object, we include all properties including those inherited from its prototype
                    var input = document.createElement("input");
                    input.type = "hidden";
                    input.name = key;
                    input.value = ko.utils.stringifyJson(ko.utils.unwrapObservable(data[key]));
                    form.appendChild(input);
                }
                objectForEach(params, function(key, value) {
                    var input = document.createElement("input");
                    input.type = "hidden";
                    input.name = key;
                    input.value = value;
                    form.appendChild(input);
                });
                document.body.appendChild(form);
                options['submitter'] ? options['submitter'](form) : form.submit();
                setTimeout(function () { form.parentNode.removeChild(form); }, 0);
            }
        }
    }());
    
    ko.exportSymbol('utils', ko.utils);
    ko.exportSymbol('utils.arrayForEach', ko.utils.arrayForEach);
    ko.exportSymbol('utils.arrayFirst', ko.utils.arrayFirst);
    ko.exportSymbol('utils.arrayFilter', ko.utils.arrayFilter);
    ko.exportSymbol('utils.arrayGetDistinctValues', ko.utils.arrayGetDistinctValues);
    ko.exportSymbol('utils.arrayIndexOf', ko.utils.arrayIndexOf);
    ko.exportSymbol('utils.arrayMap', ko.utils.arrayMap);
    ko.exportSymbol('utils.arrayPushAll', ko.utils.arrayPushAll);
    ko.exportSymbol('utils.arrayRemoveItem', ko.utils.arrayRemoveItem);
    ko.exportSymbol('utils.extend', ko.utils.extend);
    ko.exportSymbol('utils.fieldsIncludedWithJsonPost', ko.utils.fieldsIncludedWithJsonPost);
    ko.exportSymbol('utils.getFormFields', ko.utils.getFormFields);
    ko.exportSymbol('utils.peekObservable', ko.utils.peekObservable);
    ko.exportSymbol('utils.postJson', ko.utils.postJson);
    ko.exportSymbol('utils.parseJson', ko.utils.parseJson);
    ko.exportSymbol('utils.registerEventHandler', ko.utils.registerEventHandler);
    ko.exportSymbol('utils.stringifyJson', ko.utils.stringifyJson);
    ko.exportSymbol('utils.range', ko.utils.range);
    ko.exportSymbol('utils.toggleDomNodeCssClass', ko.utils.toggleDomNodeCssClass);
    ko.exportSymbol('utils.triggerEvent', ko.utils.triggerEvent);
    ko.exportSymbol('utils.unwrapObservable', ko.utils.unwrapObservable);
    ko.exportSymbol('utils.objectForEach', ko.utils.objectForEach);
    ko.exportSymbol('utils.addOrRemoveItem', ko.utils.addOrRemoveItem);
    ko.exportSymbol('utils.setTextContent', ko.utils.setTextContent);
    ko.exportSymbol('unwrap', ko.utils.unwrapObservable); // Convenient shorthand, because this is used so commonly
    
    if (!Function.prototype['bind']) {
        // Function.prototype.bind is a standard part of ECMAScript 5th Edition (December 2009, http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf)
        // In case the browser doesn't implement it natively, provide a JavaScript implementation. This implementation is based on the one in prototype.js
        Function.prototype['bind'] = function (object) {
            var originalFunction = this;
            if (arguments.length === 1) {
                return function () {
                    return originalFunction.apply(object, arguments);
                };
            } else {
                var partialArgs = Array.prototype.slice.call(arguments, 1);
                return function () {
                    var args = partialArgs.slice(0);
                    args.push.apply(args, arguments);
                    return originalFunction.apply(object, args);
                };
            }
        };
    }
    
    ko.utils.domData = new (function () {
        var uniqueId = 0;
        var dataStoreKeyExpandoPropertyName = "__ko__" + (new Date).getTime();
        var dataStore = {};
    
        function getAll(node, createIfNotFound) {
            var dataStoreKey = node[dataStoreKeyExpandoPropertyName];
            var hasExistingDataStore = dataStoreKey && (dataStoreKey !== "null") && dataStore[dataStoreKey];
            if (!hasExistingDataStore) {
                if (!createIfNotFound)
                    return undefined;
                dataStoreKey = node[dataStoreKeyExpandoPropertyName] = "ko" + uniqueId++;
                dataStore[dataStoreKey] = {};
            }
            return dataStore[dataStoreKey];
        }
    
        return {
            get: function (node, key) {
                var allDataForNode = getAll(node, false);
                return allDataForNode === undefined ? undefined : allDataForNode[key];
            },
            set: function (node, key, value) {
                if (value === undefined) {
                    // Make sure we don't actually create a new domData key if we are actually deleting a value
                    if (getAll(node, false) === undefined)
                        return;
                }
                var allDataForNode = getAll(node, true);
                allDataForNode[key] = value;
            },
            clear: function (node) {
                var dataStoreKey = node[dataStoreKeyExpandoPropertyName];
                if (dataStoreKey) {
                    delete dataStore[dataStoreKey];
                    node[dataStoreKeyExpandoPropertyName] = null;
                    return true; // Exposing "did clean" flag purely so specs can infer whether things have been cleaned up as intended
                }
                return false;
            },
    
            nextKey: function () {
                return (uniqueId++) + dataStoreKeyExpandoPropertyName;
            }
        };
    })();
    
    ko.exportSymbol('utils.domData', ko.utils.domData);
    ko.exportSymbol('utils.domData.clear', ko.utils.domData.clear); // Exporting only so specs can clear up after themselves fully
    
    ko.utils.domNodeDisposal = new (function () {
        var domDataKey = ko.utils.domData.nextKey();
        var cleanableNodeTypes = { 1: true, 8: true, 9: true };       // Element, Comment, Document
        var cleanableNodeTypesWithDescendants = { 1: true, 9: true }; // Element, Document
    
        function getDisposeCallbacksCollection(node, createIfNotFound) {
            var allDisposeCallbacks = ko.utils.domData.get(node, domDataKey);
            if ((allDisposeCallbacks === undefined) && createIfNotFound) {
                allDisposeCallbacks = [];
                ko.utils.domData.set(node, domDataKey, allDisposeCallbacks);
            }
            return allDisposeCallbacks;
        }
        function destroyCallbacksCollection(node) {
            ko.utils.domData.set(node, domDataKey, undefined);
        }
    
        function cleanSingleNode(node) {
            // Run all the dispose callbacks
            var callbacks = getDisposeCallbacksCollection(node, false);
            if (callbacks) {
                callbacks = callbacks.slice(0); // Clone, as the array may be modified during iteration (typically, callbacks will remove themselves)
                for (var i = 0; i < callbacks.length; i++)
                    callbacks[i](node);
            }
    
            // Erase the DOM data
            ko.utils.domData.clear(node);
    
            // Perform cleanup needed by external libraries (currently only jQuery, but can be extended)
            ko.utils.domNodeDisposal["cleanExternalData"](node);
    
            // Clear any immediate-child comment nodes, as these wouldn't have been found by
            // node.getElementsByTagName("*") in cleanNode() (comment nodes aren't elements)
            if (cleanableNodeTypesWithDescendants[node.nodeType])
                cleanImmediateCommentTypeChildren(node);
        }
    
        function cleanImmediateCommentTypeChildren(nodeWithChildren) {
            var child, nextChild = nodeWithChildren.firstChild;
            while (child = nextChild) {
                nextChild = child.nextSibling;
                if (child.nodeType === 8)
                    cleanSingleNode(child);
            }
        }
    
        return {
            addDisposeCallback : function(node, callback) {
                if (typeof callback != "function")
                    throw new Error("Callback must be a function");
                getDisposeCallbacksCollection(node, true).push(callback);
            },
    
            removeDisposeCallback : function(node, callback) {
                var callbacksCollection = getDisposeCallbacksCollection(node, false);
                if (callbacksCollection) {
                    ko.utils.arrayRemoveItem(callbacksCollection, callback);
                    if (callbacksCollection.length == 0)
                        destroyCallbacksCollection(node);
                }
            },
    
            cleanNode : function(node) {
                // First clean this node, where applicable
                if (cleanableNodeTypes[node.nodeType]) {
                    cleanSingleNode(node);
    
                    // ... then its descendants, where applicable
                    if (cleanableNodeTypesWithDescendants[node.nodeType]) {
                        // Clone the descendants list in case it changes during iteration
                        var descendants = [];
                        ko.utils.arrayPushAll(descendants, node.getElementsByTagName("*"));
                        for (var i = 0, j = descendants.length; i < j; i++)
                            cleanSingleNode(descendants[i]);
                    }
                }
                return node;
            },
    
            removeNode : function(node) {
                ko.cleanNode(node);
                if (node.parentNode)
                    node.parentNode.removeChild(node);
            },
    
            "cleanExternalData" : function (node) {
                // Special support for jQuery here because it's so commonly used.
                // Many jQuery plugins (including jquery.tmpl) store data using jQuery's equivalent of domData
                // so notify it to tear down any resources associated with the node & descendants here.
                if (jQueryInstance && (typeof jQueryInstance['cleanData'] == "function"))
                    jQueryInstance['cleanData']([node]);
            }
        };
    })();
    ko.cleanNode = ko.utils.domNodeDisposal.cleanNode; // Shorthand name for convenience
    ko.removeNode = ko.utils.domNodeDisposal.removeNode; // Shorthand name for convenience
    ko.exportSymbol('cleanNode', ko.cleanNode);
    ko.exportSymbol('removeNode', ko.removeNode);
    ko.exportSymbol('utils.domNodeDisposal', ko.utils.domNodeDisposal);
    ko.exportSymbol('utils.domNodeDisposal.addDisposeCallback', ko.utils.domNodeDisposal.addDisposeCallback);
    ko.exportSymbol('utils.domNodeDisposal.removeDisposeCallback', ko.utils.domNodeDisposal.removeDisposeCallback);
    (function () {
        var none = [0, "", ""],
            table = [1, "<table>", "</table>"],
            tbody = [2, "<table><tbody>", "</tbody></table>"],
            tr = [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            select = [1, "<select multiple='multiple'>", "</select>"],
            lookup = {
                'thead': table,
                'tbody': table,
                'tfoot': table,
                'tr': tbody,
                'td': tr,
                'th': tr,
                'option': select,
                'optgroup': select
            },
    
            // This is needed for old IE if you're *not* using either jQuery or innerShiv. Doesn't affect other cases.
            mayRequireCreateElementHack = ko.utils.ieVersion <= 8;
    
        function getWrap(tags) {
            var m = tags.match(/^<([a-z]+)[ >]/);
            return (m && lookup[m[1]]) || none;
        }
    
        function simpleHtmlParse(html, documentContext) {
            documentContext || (documentContext = document);
            var windowContext = documentContext['parentWindow'] || documentContext['defaultView'] || window;
    
            // Based on jQuery's "clean" function, but only accounting for table-related elements.
            // If you have referenced jQuery, this won't be used anyway - KO will use jQuery's "clean" function directly
    
            // Note that there's still an issue in IE < 9 whereby it will discard comment nodes that are the first child of
            // a descendant node. For example: "<div><!-- mycomment -->abc</div>" will get parsed as "<div>abc</div>"
            // This won't affect anyone who has referenced jQuery, and there's always the workaround of inserting a dummy node
            // (possibly a text node) in front of the comment. So, KO does not attempt to workaround this IE issue automatically at present.
    
            // Trim whitespace, otherwise indexOf won't work as expected
            var tags = ko.utils.stringTrim(html).toLowerCase(), div = documentContext.createElement("div"),
                wrap = getWrap(tags),
                depth = wrap[0];
    
            // Go to html and back, then peel off extra wrappers
            // Note that we always prefix with some dummy text, because otherwise, IE<9 will strip out leading comment nodes in descendants. Total madness.
            var markup = "ignored<div>" + wrap[1] + html + wrap[2] + "</div>";
            if (typeof windowContext['innerShiv'] == "function") {
                // Note that innerShiv is deprecated in favour of html5shiv. We should consider adding
                // support for html5shiv (except if no explicit support is needed, e.g., if html5shiv
                // somehow shims the native APIs so it just works anyway)
                div.appendChild(windowContext['innerShiv'](markup));
            } else {
                if (mayRequireCreateElementHack) {
                    // The document.createElement('my-element') trick to enable custom elements in IE6-8
                    // only works if we assign innerHTML on an element associated with that document.
                    documentContext.appendChild(div);
                }
    
                div.innerHTML = markup;
    
                if (mayRequireCreateElementHack) {
                    div.parentNode.removeChild(div);
                }
            }
    
            // Move to the right depth
            while (depth--)
                div = div.lastChild;
    
            return ko.utils.makeArray(div.lastChild.childNodes);
        }
    
        function jQueryHtmlParse(html, documentContext) {
            // jQuery's "parseHTML" function was introduced in jQuery 1.8.0 and is a documented public API.
            if (jQueryInstance['parseHTML']) {
                return jQueryInstance['parseHTML'](html, documentContext) || []; // Ensure we always return an array and never null
            } else {
                // For jQuery < 1.8.0, we fall back on the undocumented internal "clean" function.
                var elems = jQueryInstance['clean']([html], documentContext);
    
                // As of jQuery 1.7.1, jQuery parses the HTML by appending it to some dummy parent nodes held in an in-memory document fragment.
                // Unfortunately, it never clears the dummy parent nodes from the document fragment, so it leaks memory over time.
                // Fix this by finding the top-most dummy parent element, and detaching it from its owner fragment.
                if (elems && elems[0]) {
                    // Find the top-most parent element that's a direct child of a document fragment
                    var elem = elems[0];
                    while (elem.parentNode && elem.parentNode.nodeType !== 11 /* i.e., DocumentFragment */)
                        elem = elem.parentNode;
                    // ... then detach it
                    if (elem.parentNode)
                        elem.parentNode.removeChild(elem);
                }
    
                return elems;
            }
        }
    
        ko.utils.parseHtmlFragment = function(html, documentContext) {
            return jQueryInstance ?
                jQueryHtmlParse(html, documentContext) :   // As below, benefit from jQuery's optimisations where possible
                simpleHtmlParse(html, documentContext);  // ... otherwise, this simple logic will do in most common cases.
        };
    
        ko.utils.setHtml = function(node, html) {
            ko.utils.emptyDomNode(node);
    
            // There's no legitimate reason to display a stringified observable without unwrapping it, so we'll unwrap it
            html = ko.utils.unwrapObservable(html);
    
            if ((html !== null) && (html !== undefined)) {
                if (typeof html != 'string')
                    html = html.toString();
    
                // jQuery contains a lot of sophisticated code to parse arbitrary HTML fragments,
                // for example <tr> elements which are not normally allowed to exist on their own.
                // If you've referenced jQuery we'll use that rather than duplicating its code.
                if (jQueryInstance) {
                    jQueryInstance(node)['html'](html);
                } else {
                    // ... otherwise, use KO's own parsing logic.
                    var parsedNodes = ko.utils.parseHtmlFragment(html, node.ownerDocument);
                    for (var i = 0; i < parsedNodes.length; i++)
                        node.appendChild(parsedNodes[i]);
                }
            }
        };
    })();
    
    ko.exportSymbol('utils.parseHtmlFragment', ko.utils.parseHtmlFragment);
    ko.exportSymbol('utils.setHtml', ko.utils.setHtml);
    
    ko.memoization = (function () {
        var memos = {};
    
        function randomMax8HexChars() {
            return (((1 + Math.random()) * 0x100000000) | 0).toString(16).substring(1);
        }
        function generateRandomId() {
            return randomMax8HexChars() + randomMax8HexChars();
        }
        function findMemoNodes(rootNode, appendToArray) {
            if (!rootNode)
                return;
            if (rootNode.nodeType == 8) {
                var memoId = ko.memoization.parseMemoText(rootNode.nodeValue);
                if (memoId != null)
                    appendToArray.push({ domNode: rootNode, memoId: memoId });
            } else if (rootNode.nodeType == 1) {
                for (var i = 0, childNodes = rootNode.childNodes, j = childNodes.length; i < j; i++)
                    findMemoNodes(childNodes[i], appendToArray);
            }
        }
    
        return {
            memoize: function (callback) {
                if (typeof callback != "function")
                    throw new Error("You can only pass a function to ko.memoization.memoize()");
                var memoId = generateRandomId();
                memos[memoId] = callback;
                return "<!--[ko_memo:" + memoId + "]-->";
            },
    
            unmemoize: function (memoId, callbackParams) {
                var callback = memos[memoId];
                if (callback === undefined)
                    throw new Error("Couldn't find any memo with ID " + memoId + ". Perhaps it's already been unmemoized.");
                try {
                    callback.apply(null, callbackParams || []);
                    return true;
                }
                finally { delete memos[memoId]; }
            },
    
            unmemoizeDomNodeAndDescendants: function (domNode, extraCallbackParamsArray) {
                var memos = [];
                findMemoNodes(domNode, memos);
                for (var i = 0, j = memos.length; i < j; i++) {
                    var node = memos[i].domNode;
                    var combinedParams = [node];
                    if (extraCallbackParamsArray)
                        ko.utils.arrayPushAll(combinedParams, extraCallbackParamsArray);
                    ko.memoization.unmemoize(memos[i].memoId, combinedParams);
                    node.nodeValue = ""; // Neuter this node so we don't try to unmemoize it again
                    if (node.parentNode)
                        node.parentNode.removeChild(node); // If possible, erase it totally (not always possible - someone else might just hold a reference to it then call unmemoizeDomNodeAndDescendants again)
                }
            },
    
            parseMemoText: function (memoText) {
                var match = memoText.match(/^\[ko_memo\:(.*?)\]$/);
                return match ? match[1] : null;
            }
        };
    })();
    
    ko.exportSymbol('memoization', ko.memoization);
    ko.exportSymbol('memoization.memoize', ko.memoization.memoize);
    ko.exportSymbol('memoization.unmemoize', ko.memoization.unmemoize);
    ko.exportSymbol('memoization.parseMemoText', ko.memoization.parseMemoText);
    ko.exportSymbol('memoization.unmemoizeDomNodeAndDescendants', ko.memoization.unmemoizeDomNodeAndDescendants);
    ko.tasks = (function () {
        var scheduler,
            taskQueue = [],
            taskQueueLength = 0,
            nextHandle = 1,
            nextIndexToProcess = 0;
    
        if (window['MutationObserver']) {
            // Chrome 27+, Firefox 14+, IE 11+, Opera 15+, Safari 6.1+
            // From https://github.com/petkaantonov/bluebird * Copyright (c) 2014 Petka Antonov * License: MIT
            scheduler = (function (callback) {
                var div = document.createElement("div");
                new MutationObserver(callback).observe(div, {attributes: true});
                return function () { div.classList.toggle("foo"); };
            })(scheduledProcess);
        } else if (document && "onreadystatechange" in document.createElement("script")) {
            // IE 6-10
            // From https://github.com/YuzuJS/setImmediate * Copyright (c) 2012 Barnesandnoble.com, llc, Donavon West, and Domenic Denicola * License: MIT
            scheduler = function (callback) {
                var script = document.createElement("script");
                script.onreadystatechange = function () {
                    script.onreadystatechange = null;
                    document.documentElement.removeChild(script);
                    script = null;
                    callback();
                };
                document.documentElement.appendChild(script);
            };
        } else {
            scheduler = function (callback) {
                setTimeout(callback, 0);
            };
        }
    
        function processTasks() {
            if (taskQueueLength) {
                // Each mark represents the end of a logical group of tasks and the number of these groups is
                // limited to prevent unchecked recursion.
                var mark = taskQueueLength, countMarks = 0;
    
                // nextIndexToProcess keeps track of where we are in the queue; processTasks can be called recursively without issue
                for (var task; nextIndexToProcess < taskQueueLength; ) {
                    if (task = taskQueue[nextIndexToProcess++]) {
                        if (nextIndexToProcess > mark) {
                            if (++countMarks >= 5000) {
                                nextIndexToProcess = taskQueueLength;   // skip all tasks remaining in the queue since any of them could be causing the recursion
                                ko.utils.deferError(Error("'Too much recursion' after processing " + countMarks + " task groups."));
                                break;
                            }
                            mark = taskQueueLength;
                        }
                        try {
                            task();
                        } catch (ex) {
                            ko.utils.deferError(ex);
                        }
                    }
                }
            }
        }
    
        function scheduledProcess() {
            processTasks();
    
            // Reset the queue
            nextIndexToProcess = taskQueueLength = taskQueue.length = 0;
        }
    
        function scheduleTaskProcessing() {
            ko.tasks['scheduler'](scheduledProcess);
        }
    
        var tasks = {
            'scheduler': scheduler,     // Allow overriding the scheduler
    
            schedule: function (func) {
                if (!taskQueueLength) {
                    scheduleTaskProcessing();
                }
    
                taskQueue[taskQueueLength++] = func;
                return nextHandle++;
            },
    
            cancel: function (handle) {
                var index = handle - (nextHandle - taskQueueLength);
                if (index >= nextIndexToProcess && index < taskQueueLength) {
                    taskQueue[index] = null;
                }
            },
    
            // For testing only: reset the queue and return the previous queue length
            'resetForTesting': function () {
                var length = taskQueueLength - nextIndexToProcess;
                nextIndexToProcess = taskQueueLength = taskQueue.length = 0;
                return length;
            },
    
            runEarly: processTasks
        };
    
        return tasks;
    })();
    
    ko.exportSymbol('tasks', ko.tasks);
    ko.exportSymbol('tasks.schedule', ko.tasks.schedule);
    //ko.exportSymbol('tasks.cancel', ko.tasks.cancel);  "cancel" isn't minified
    ko.exportSymbol('tasks.runEarly', ko.tasks.runEarly);
    ko.extenders = {
        'throttle': function(target, timeout) {
            // Throttling means two things:
    
            // (1) For dependent observables, we throttle *evaluations* so that, no matter how fast its dependencies
            //     notify updates, the target doesn't re-evaluate (and hence doesn't notify) faster than a certain rate
            target['throttleEvaluation'] = timeout;
    
            // (2) For writable targets (observables, or writable dependent observables), we throttle *writes*
            //     so the target cannot change value synchronously or faster than a certain rate
            var writeTimeoutInstance = null;
            return ko.dependentObservable({
                'read': target,
                'write': function(value) {
                    clearTimeout(writeTimeoutInstance);
                    writeTimeoutInstance = ko.utils.setTimeout(function() {
                        target(value);
                    }, timeout);
                }
            });
        },
    
        'rateLimit': function(target, options) {
            var timeout, method, limitFunction;
    
            if (typeof options == 'number') {
                timeout = options;
            } else {
                timeout = options['timeout'];
                method = options['method'];
            }
    
            // rateLimit supersedes deferred updates
            target._deferUpdates = false;
    
            limitFunction = method == 'notifyWhenChangesStop' ?  debounce : throttle;
            target.limit(function(callback) {
                return limitFunction(callback, timeout);
            });
        },
    
        'deferred': function(target, options) {
            if (options !== true) {
                throw new Error('The \'deferred\' extender only accepts the value \'true\', because it is not supported to turn deferral off once enabled.')
            }
    
            if (!target._deferUpdates) {
                target._deferUpdates = true;
                target.limit(function (callback) {
                    var handle,
                        ignoreUpdates = false;
                    return function () {
                        if (!ignoreUpdates) {
                            ko.tasks.cancel(handle);
                            handle = ko.tasks.schedule(callback);
    
                            try {
                                ignoreUpdates = true;
                                target['notifySubscribers'](undefined, 'dirty');
                            } finally {
                                ignoreUpdates = false;
                            }
                        }
                    };
                });
            }
        },
    
        'notify': function(target, notifyWhen) {
            target["equalityComparer"] = notifyWhen == "always" ?
                null :  // null equalityComparer means to always notify
                valuesArePrimitiveAndEqual;
        }
    };
    
    var primitiveTypes = { 'undefined':1, 'boolean':1, 'number':1, 'string':1 };
    function valuesArePrimitiveAndEqual(a, b) {
        var oldValueIsPrimitive = (a === null) || (typeof(a) in primitiveTypes);
        return oldValueIsPrimitive ? (a === b) : false;
    }
    
    function throttle(callback, timeout) {
        var timeoutInstance;
        return function () {
            if (!timeoutInstance) {
                timeoutInstance = ko.utils.setTimeout(function () {
                    timeoutInstance = undefined;
                    callback();
                }, timeout);
            }
        };
    }
    
    function debounce(callback, timeout) {
        var timeoutInstance;
        return function () {
            clearTimeout(timeoutInstance);
            timeoutInstance = ko.utils.setTimeout(callback, timeout);
        };
    }
    
    function applyExtenders(requestedExtenders) {
        var target = this;
        if (requestedExtenders) {
            ko.utils.objectForEach(requestedExtenders, function(key, value) {
                var extenderHandler = ko.extenders[key];
                if (typeof extenderHandler == 'function') {
                    target = extenderHandler(target, value) || target;
                }
            });
        }
        return target;
    }
    
    ko.exportSymbol('extenders', ko.extenders);
    
    ko.subscription = function (target, callback, disposeCallback) {
        this._target = target;
        this.callback = callback;
        this.disposeCallback = disposeCallback;
        this.isDisposed = false;
        ko.exportProperty(this, 'dispose', this.dispose);
    };
    ko.subscription.prototype.dispose = function () {
        this.isDisposed = true;
        this.disposeCallback();
    };
    
    ko.subscribable = function () {
        ko.utils.setPrototypeOfOrExtend(this, ko_subscribable_fn);
        ko_subscribable_fn.init(this);
    }
    
    var defaultEvent = "change";
    
    // Moved out of "limit" to avoid the extra closure
    function limitNotifySubscribers(value, event) {
        if (!event || event === defaultEvent) {
            this._limitChange(value);
        } else if (event === 'beforeChange') {
            this._limitBeforeChange(value);
        } else {
            this._origNotifySubscribers(value, event);
        }
    }
    
    var ko_subscribable_fn = {
        init: function(instance) {
            instance._subscriptions = { "change": [] };
            instance._versionNumber = 1;
        },
    
        subscribe: function (callback, callbackTarget, event) {
            var self = this;
    
            event = event || defaultEvent;
            var boundCallback = callbackTarget ? callback.bind(callbackTarget) : callback;
    
            var subscription = new ko.subscription(self, boundCallback, function () {
                ko.utils.arrayRemoveItem(self._subscriptions[event], subscription);
                if (self.afterSubscriptionRemove)
                    self.afterSubscriptionRemove(event);
            });
    
            if (self.beforeSubscriptionAdd)
                self.beforeSubscriptionAdd(event);
    
            if (!self._subscriptions[event])
                self._subscriptions[event] = [];
            self._subscriptions[event].push(subscription);
    
            return subscription;
        },
    
        "notifySubscribers": function (valueToNotify, event) {
            event = event || defaultEvent;
            if (event === defaultEvent) {
                this.updateVersion();
            }
            if (this.hasSubscriptionsForEvent(event)) {
                var subs = event === defaultEvent && this._changeSubscriptions || this._subscriptions[event].slice(0);
                try {
                    ko.dependencyDetection.begin(); // Begin suppressing dependency detection (by setting the top frame to undefined)
                    for (var i = 0, subscription; subscription = subs[i]; ++i) {
                        // In case a subscription was disposed during the arrayForEach cycle, check
                        // for isDisposed on each subscription before invoking its callback
                        if (!subscription.isDisposed)
                            subscription.callback(valueToNotify);
                    }
                } finally {
                    ko.dependencyDetection.end(); // End suppressing dependency detection
                }
            }
        },
    
        getVersion: function () {
            return this._versionNumber;
        },
    
        hasChanged: function (versionToCheck) {
            return this.getVersion() !== versionToCheck;
        },
    
        updateVersion: function () {
            ++this._versionNumber;
        },
    
        limit: function(limitFunction) {
            var self = this, selfIsObservable = ko.isObservable(self),
                ignoreBeforeChange, notifyNextChange, previousValue, pendingValue, beforeChange = 'beforeChange';
    
            if (!self._origNotifySubscribers) {
                self._origNotifySubscribers = self["notifySubscribers"];
                self["notifySubscribers"] = limitNotifySubscribers;
            }
    
            var finish = limitFunction(function() {
                self._notificationIsPending = false;
    
                // If an observable provided a reference to itself, access it to get the latest value.
                // This allows computed observables to delay calculating their value until needed.
                if (selfIsObservable && pendingValue === self) {
                    pendingValue = self._evalIfChanged ? self._evalIfChanged() : self();
                }
                var shouldNotify = notifyNextChange || self.isDifferent(previousValue, pendingValue);
    
                notifyNextChange = ignoreBeforeChange = false;
    
                if (shouldNotify) {
                    self._origNotifySubscribers(previousValue = pendingValue);
                }
            });
    
            self._limitChange = function(value) {
                self._changeSubscriptions = self._subscriptions[defaultEvent].slice(0);
                self._notificationIsPending = ignoreBeforeChange = true;
                pendingValue = value;
                finish();
            };
            self._limitBeforeChange = function(value) {
                if (!ignoreBeforeChange) {
                    previousValue = value;
                    self._origNotifySubscribers(value, beforeChange);
                }
            };
            self._notifyNextChangeIfValueIsDifferent = function() {
                if (self.isDifferent(previousValue, self.peek(true /*evaluate*/))) {
                    notifyNextChange = true;
                }
            };
        },
    
        hasSubscriptionsForEvent: function(event) {
            return this._subscriptions[event] && this._subscriptions[event].length;
        },
    
        getSubscriptionsCount: function (event) {
            if (event) {
                return this._subscriptions[event] && this._subscriptions[event].length || 0;
            } else {
                var total = 0;
                ko.utils.objectForEach(this._subscriptions, function(eventName, subscriptions) {
                    if (eventName !== 'dirty')
                        total += subscriptions.length;
                });
                return total;
            }
        },
    
        isDifferent: function(oldValue, newValue) {
            return !this['equalityComparer'] || !this['equalityComparer'](oldValue, newValue);
        },
    
        extend: applyExtenders
    };
    
    ko.exportProperty(ko_subscribable_fn, 'subscribe', ko_subscribable_fn.subscribe);
    ko.exportProperty(ko_subscribable_fn, 'extend', ko_subscribable_fn.extend);
    ko.exportProperty(ko_subscribable_fn, 'getSubscriptionsCount', ko_subscribable_fn.getSubscriptionsCount);
    
    // For browsers that support proto assignment, we overwrite the prototype of each
    // observable instance. Since observables are functions, we need Function.prototype
    // to still be in the prototype chain.
    if (ko.utils.canSetPrototype) {
        ko.utils.setPrototypeOf(ko_subscribable_fn, Function.prototype);
    }
    
    ko.subscribable['fn'] = ko_subscribable_fn;
    
    
    ko.isSubscribable = function (instance) {
        return instance != null && typeof instance.subscribe == "function" && typeof instance["notifySubscribers"] == "function";
    };
    
    ko.exportSymbol('subscribable', ko.subscribable);
    ko.exportSymbol('isSubscribable', ko.isSubscribable);
    
    ko.computedContext = ko.dependencyDetection = (function () {
        var outerFrames = [],
            currentFrame,
            lastId = 0;
    
        // Return a unique ID that can be assigned to an observable for dependency tracking.
        // Theoretically, you could eventually overflow the number storage size, resulting
        // in duplicate IDs. But in JavaScript, the largest exact integral value is 2^53
        // or 9,007,199,254,740,992. If you created 1,000,000 IDs per second, it would
        // take over 285 years to reach that number.
        // Reference http://blog.vjeux.com/2010/javascript/javascript-max_int-number-limits.html
        function getId() {
            return ++lastId;
        }
    
        function begin(options) {
            outerFrames.push(currentFrame);
            currentFrame = options;
        }
    
        function end() {
            currentFrame = outerFrames.pop();
        }
    
        return {
            begin: begin,
    
            end: end,
    
            registerDependency: function (subscribable) {
                if (currentFrame) {
                    if (!ko.isSubscribable(subscribable))
                        throw new Error("Only subscribable things can act as dependencies");
                    currentFrame.callback.call(currentFrame.callbackTarget, subscribable, subscribable._id || (subscribable._id = getId()));
                }
            },
    
            ignore: function (callback, callbackTarget, callbackArgs) {
                try {
                    begin();
                    return callback.apply(callbackTarget, callbackArgs || []);
                } finally {
                    end();
                }
            },
    
            getDependenciesCount: function () {
                if (currentFrame)
                    return currentFrame.computed.getDependenciesCount();
            },
    
            isInitial: function() {
                if (currentFrame)
                    return currentFrame.isInitial;
            }
        };
    })();
    
    ko.exportSymbol('computedContext', ko.computedContext);
    ko.exportSymbol('computedContext.getDependenciesCount', ko.computedContext.getDependenciesCount);
    ko.exportSymbol('computedContext.isInitial', ko.computedContext.isInitial);
    
    ko.exportSymbol('ignoreDependencies', ko.ignoreDependencies = ko.dependencyDetection.ignore);
    var observableLatestValue = ko.utils.createSymbolOrString('_latestValue');
    
    ko.observable = function (initialValue) {
        function observable() {
            if (arguments.length > 0) {
                // Write
    
                // Ignore writes if the value hasn't changed
                if (observable.isDifferent(observable[observableLatestValue], arguments[0])) {
                    observable.valueWillMutate();
                    observable[observableLatestValue] = arguments[0];
                    observable.valueHasMutated();
                }
                return this; // Permits chained assignments
            }
            else {
                // Read
                ko.dependencyDetection.registerDependency(observable); // The caller only needs to be notified of changes if they did a "read" operation
                return observable[observableLatestValue];
            }
        }
    
        observable[observableLatestValue] = initialValue;
    
        // Inherit from 'subscribable'
        if (!ko.utils.canSetPrototype) {
            // 'subscribable' won't be on the prototype chain unless we put it there directly
            ko.utils.extend(observable, ko.subscribable['fn']);
        }
        ko.subscribable['fn'].init(observable);
    
        // Inherit from 'observable'
        ko.utils.setPrototypeOfOrExtend(observable, observableFn);
    
        if (ko.options['deferUpdates']) {
            ko.extenders['deferred'](observable, true);
        }
    
        return observable;
    }
    
    // Define prototype for observables
    var observableFn = {
        'equalityComparer': valuesArePrimitiveAndEqual,
        peek: function() { return this[observableLatestValue]; },
        valueHasMutated: function () { this['notifySubscribers'](this[observableLatestValue]); },
        valueWillMutate: function () { this['notifySubscribers'](this[observableLatestValue], 'beforeChange'); }
    };
    
    // Note that for browsers that don't support proto assignment, the
    // inheritance chain is created manually in the ko.observable constructor
    if (ko.utils.canSetPrototype) {
        ko.utils.setPrototypeOf(observableFn, ko.subscribable['fn']);
    }
    
    var protoProperty = ko.observable.protoProperty = '__ko_proto__';
    observableFn[protoProperty] = ko.observable;
    
    ko.hasPrototype = function(instance, prototype) {
        if ((instance === null) || (instance === undefined) || (instance[protoProperty] === undefined)) return false;
        if (instance[protoProperty] === prototype) return true;
        return ko.hasPrototype(instance[protoProperty], prototype); // Walk the prototype chain
    };
    
    ko.isObservable = function (instance) {
        return ko.hasPrototype(instance, ko.observable);
    }
    ko.isWriteableObservable = function (instance) {
        // Observable
        if ((typeof instance == 'function') && instance[protoProperty] === ko.observable)
            return true;
        // Writeable dependent observable
        if ((typeof instance == 'function') && (instance[protoProperty] === ko.dependentObservable) && (instance.hasWriteFunction))
            return true;
        // Anything else
        return false;
    }
    
    ko.exportSymbol('observable', ko.observable);
    ko.exportSymbol('isObservable', ko.isObservable);
    ko.exportSymbol('isWriteableObservable', ko.isWriteableObservable);
    ko.exportSymbol('isWritableObservable', ko.isWriteableObservable);
    ko.exportSymbol('observable.fn', observableFn);
    ko.exportProperty(observableFn, 'peek', observableFn.peek);
    ko.exportProperty(observableFn, 'valueHasMutated', observableFn.valueHasMutated);
    ko.exportProperty(observableFn, 'valueWillMutate', observableFn.valueWillMutate);
    ko.observableArray = function (initialValues) {
        initialValues = initialValues || [];
    
        if (typeof initialValues != 'object' || !('length' in initialValues))
            throw new Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");
    
        var result = ko.observable(initialValues);
        ko.utils.setPrototypeOfOrExtend(result, ko.observableArray['fn']);
        return result.extend({'trackArrayChanges':true});
    };
    
    ko.observableArray['fn'] = {
        'remove': function (valueOrPredicate) {
            var underlyingArray = this.peek();
            var removedValues = [];
            var predicate = typeof valueOrPredicate == "function" && !ko.isObservable(valueOrPredicate) ? valueOrPredicate : function (value) { return value === valueOrPredicate; };
            for (var i = 0; i < underlyingArray.length; i++) {
                var value = underlyingArray[i];
                if (predicate(value)) {
                    if (removedValues.length === 0) {
                        this.valueWillMutate();
                    }
                    removedValues.push(value);
                    underlyingArray.splice(i, 1);
                    i--;
                }
            }
            if (removedValues.length) {
                this.valueHasMutated();
            }
            return removedValues;
        },
    
        'removeAll': function (arrayOfValues) {
            // If you passed zero args, we remove everything
            if (arrayOfValues === undefined) {
                var underlyingArray = this.peek();
                var allValues = underlyingArray.slice(0);
                this.valueWillMutate();
                underlyingArray.splice(0, underlyingArray.length);
                this.valueHasMutated();
                return allValues;
            }
            // If you passed an arg, we interpret it as an array of entries to remove
            if (!arrayOfValues)
                return [];
            return this['remove'](function (value) {
                return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0;
            });
        },
    
        'destroy': function (valueOrPredicate) {
            var underlyingArray = this.peek();
            var predicate = typeof valueOrPredicate == "function" && !ko.isObservable(valueOrPredicate) ? valueOrPredicate : function (value) { return value === valueOrPredicate; };
            this.valueWillMutate();
            for (var i = underlyingArray.length - 1; i >= 0; i--) {
                var value = underlyingArray[i];
                if (predicate(value))
                    underlyingArray[i]["_destroy"] = true;
            }
            this.valueHasMutated();
        },
    
        'destroyAll': function (arrayOfValues) {
            // If you passed zero args, we destroy everything
            if (arrayOfValues === undefined)
                return this['destroy'](function() { return true });
    
            // If you passed an arg, we interpret it as an array of entries to destroy
            if (!arrayOfValues)
                return [];
            return this['destroy'](function (value) {
                return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0;
            });
        },
    
        'indexOf': function (item) {
            var underlyingArray = this();
            return ko.utils.arrayIndexOf(underlyingArray, item);
        },
    
        'replace': function(oldItem, newItem) {
            var index = this['indexOf'](oldItem);
            if (index >= 0) {
                this.valueWillMutate();
                this.peek()[index] = newItem;
                this.valueHasMutated();
            }
        }
    };
    
    // Note that for browsers that don't support proto assignment, the
    // inheritance chain is created manually in the ko.observableArray constructor
    if (ko.utils.canSetPrototype) {
        ko.utils.setPrototypeOf(ko.observableArray['fn'], ko.observable['fn']);
    }
    
    // Populate ko.observableArray.fn with read/write functions from native arrays
    // Important: Do not add any additional functions here that may reasonably be used to *read* data from the array
    // because we'll eval them without causing subscriptions, so ko.computed output could end up getting stale
    ko.utils.arrayForEach(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function (methodName) {
        ko.observableArray['fn'][methodName] = function () {
            // Use "peek" to avoid creating a subscription in any computed that we're executing in the context of
            // (for consistency with mutating regular observables)
            var underlyingArray = this.peek();
            this.valueWillMutate();
            this.cacheDiffForKnownOperation(underlyingArray, methodName, arguments);
            var methodCallResult = underlyingArray[methodName].apply(underlyingArray, arguments);
            this.valueHasMutated();
            // The native sort and reverse methods return a reference to the array, but it makes more sense to return the observable array instead.
            return methodCallResult === underlyingArray ? this : methodCallResult;
        };
    });
    
    // Populate ko.observableArray.fn with read-only functions from native arrays
    ko.utils.arrayForEach(["slice"], function (methodName) {
        ko.observableArray['fn'][methodName] = function () {
            var underlyingArray = this();
            return underlyingArray[methodName].apply(underlyingArray, arguments);
        };
    });
    
    ko.exportSymbol('observableArray', ko.observableArray);
    var arrayChangeEventName = 'arrayChange';
    ko.extenders['trackArrayChanges'] = function(target, options) {
        // Use the provided options--each call to trackArrayChanges overwrites the previously set options
        target.compareArrayOptions = {};
        if (options && typeof options == "object") {
            ko.utils.extend(target.compareArrayOptions, options);
        }
        target.compareArrayOptions['sparse'] = true;
    
        // Only modify the target observable once
        if (target.cacheDiffForKnownOperation) {
            return;
        }
        var trackingChanges = false,
            cachedDiff = null,
            arrayChangeSubscription,
            pendingNotifications = 0,
            underlyingNotifySubscribersFunction,
            underlyingBeforeSubscriptionAddFunction = target.beforeSubscriptionAdd,
            underlyingAfterSubscriptionRemoveFunction = target.afterSubscriptionRemove;
    
        // Watch "subscribe" calls, and for array change events, ensure change tracking is enabled
        target.beforeSubscriptionAdd = function (event) {
            if (underlyingBeforeSubscriptionAddFunction)
                underlyingBeforeSubscriptionAddFunction.call(target, event);
            if (event === arrayChangeEventName) {
                trackChanges();
            }
        };
        // Watch "dispose" calls, and for array change events, ensure change tracking is disabled when all are disposed
        target.afterSubscriptionRemove = function (event) {
            if (underlyingAfterSubscriptionRemoveFunction)
                underlyingAfterSubscriptionRemoveFunction.call(target, event);
            if (event === arrayChangeEventName && !target.hasSubscriptionsForEvent(arrayChangeEventName)) {
                if (underlyingNotifySubscribersFunction) {
                    target['notifySubscribers'] = underlyingNotifySubscribersFunction;
                    underlyingNotifySubscribersFunction = undefined;
                }
                arrayChangeSubscription.dispose();
                trackingChanges = false;
            }
        };
    
        function trackChanges() {
            // Calling 'trackChanges' multiple times is the same as calling it once
            if (trackingChanges) {
                return;
            }
    
            trackingChanges = true;
    
            // Intercept "notifySubscribers" to track how many times it was called.
            underlyingNotifySubscribersFunction = target['notifySubscribers'];
            target['notifySubscribers'] = function(valueToNotify, event) {
                if (!event || event === defaultEvent) {
                    ++pendingNotifications;
                }
                return underlyingNotifySubscribersFunction.apply(this, arguments);
            };
    
            // Each time the array changes value, capture a clone so that on the next
            // change it's possible to produce a diff
            var previousContents = [].concat(target.peek() || []);
            cachedDiff = null;
            arrayChangeSubscription = target.subscribe(function(currentContents) {
                // Make a copy of the current contents and ensure it's an array
                currentContents = [].concat(currentContents || []);
    
                // Compute the diff and issue notifications, but only if someone is listening
                if (target.hasSubscriptionsForEvent(arrayChangeEventName)) {
                    var changes = getChanges(previousContents, currentContents);
                }
    
                // Eliminate references to the old, removed items, so they can be GCed
                previousContents = currentContents;
                cachedDiff = null;
                pendingNotifications = 0;
    
                if (changes && changes.length) {
                    target['notifySubscribers'](changes, arrayChangeEventName);
                }
            });
        }
    
        function getChanges(previousContents, currentContents) {
            // We try to re-use cached diffs.
            // The scenarios where pendingNotifications > 1 are when using rate-limiting or the Deferred Updates
            // plugin, which without this check would not be compatible with arrayChange notifications. Normally,
            // notifications are issued immediately so we wouldn't be queueing up more than one.
            if (!cachedDiff || pendingNotifications > 1) {
                cachedDiff = ko.utils.compareArrays(previousContents, currentContents, target.compareArrayOptions);
            }
    
            return cachedDiff;
        }
    
        target.cacheDiffForKnownOperation = function(rawArray, operationName, args) {
            // Only run if we're currently tracking changes for this observable array
            // and there aren't any pending deferred notifications.
            if (!trackingChanges || pendingNotifications) {
                return;
            }
            var diff = [],
                arrayLength = rawArray.length,
                argsLength = args.length,
                offset = 0;
    
            function pushDiff(status, value, index) {
                return diff[diff.length] = { 'status': status, 'value': value, 'index': index };
            }
            switch (operationName) {
                case 'push':
                    offset = arrayLength;
                case 'unshift':
                    for (var index = 0; index < argsLength; index++) {
                        pushDiff('added', args[index], offset + index);
                    }
                    break;
    
                case 'pop':
                    offset = arrayLength - 1;
                case 'shift':
                    if (arrayLength) {
                        pushDiff('deleted', rawArray[offset], offset);
                    }
                    break;
    
                case 'splice':
                    // Negative start index means 'from end of array'. After that we clamp to [0...arrayLength].
                    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice
                    var startIndex = Math.min(Math.max(0, args[0] < 0 ? arrayLength + args[0] : args[0]), arrayLength),
                        endDeleteIndex = argsLength === 1 ? arrayLength : Math.min(startIndex + (args[1] || 0), arrayLength),
                        endAddIndex = startIndex + argsLength - 2,
                        endIndex = Math.max(endDeleteIndex, endAddIndex),
                        additions = [], deletions = [];
                    for (var index = startIndex, argsIndex = 2; index < endIndex; ++index, ++argsIndex) {
                        if (index < endDeleteIndex)
                            deletions.push(pushDiff('deleted', rawArray[index], index));
                        if (index < endAddIndex)
                            additions.push(pushDiff('added', args[argsIndex], index));
                    }
                    ko.utils.findMovesInArrayComparison(deletions, additions);
                    break;
    
                default:
                    return;
            }
            cachedDiff = diff;
        };
    };
    var computedState = ko.utils.createSymbolOrString('_state');
    
    ko.computed = ko.dependentObservable = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget, options) {
        if (typeof evaluatorFunctionOrOptions === "object") {
            // Single-parameter syntax - everything is on this "options" param
            options = evaluatorFunctionOrOptions;
        } else {
            // Multi-parameter syntax - construct the options according to the params passed
            options = options || {};
            if (evaluatorFunctionOrOptions) {
                options["read"] = evaluatorFunctionOrOptions;
            }
        }
        if (typeof options["read"] != "function")
            throw Error("Pass a function that returns the value of the ko.computed");
    
        var writeFunction = options["write"];
        var state = {
            latestValue: undefined,
            isStale: true,
            isDirty: true,
            isBeingEvaluated: false,
            suppressDisposalUntilDisposeWhenReturnsFalse: false,
            isDisposed: false,
            pure: false,
            isSleeping: false,
            readFunction: options["read"],
            evaluatorFunctionTarget: evaluatorFunctionTarget || options["owner"],
            disposeWhenNodeIsRemoved: options["disposeWhenNodeIsRemoved"] || options.disposeWhenNodeIsRemoved || null,
            disposeWhen: options["disposeWhen"] || options.disposeWhen,
            domNodeDisposalCallback: null,
            dependencyTracking: {},
            dependenciesCount: 0,
            evaluationTimeoutInstance: null
        };
    
        function computedObservable() {
            if (arguments.length > 0) {
                if (typeof writeFunction === "function") {
                    // Writing a value
                    writeFunction.apply(state.evaluatorFunctionTarget, arguments);
                } else {
                    throw new Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.");
                }
                return this; // Permits chained assignments
            } else {
                // Reading the value
                ko.dependencyDetection.registerDependency(computedObservable);
                if (state.isDirty || (state.isSleeping && computedObservable.haveDependenciesChanged())) {
                    computedObservable.evaluateImmediate();
                }
                return state.latestValue;
            }
        }
    
        computedObservable[computedState] = state;
        computedObservable.hasWriteFunction = typeof writeFunction === "function";
    
        // Inherit from 'subscribable'
        if (!ko.utils.canSetPrototype) {
            // 'subscribable' won't be on the prototype chain unless we put it there directly
            ko.utils.extend(computedObservable, ko.subscribable['fn']);
        }
        ko.subscribable['fn'].init(computedObservable);
    
        // Inherit from 'computed'
        ko.utils.setPrototypeOfOrExtend(computedObservable, computedFn);
    
        if (options['pure']) {
            state.pure = true;
            state.isSleeping = true;     // Starts off sleeping; will awake on the first subscription
            ko.utils.extend(computedObservable, pureComputedOverrides);
        } else if (options['deferEvaluation']) {
            ko.utils.extend(computedObservable, deferEvaluationOverrides);
        }
    
        if (ko.options['deferUpdates']) {
            ko.extenders['deferred'](computedObservable, true);
        }
    
        if (DEBUG) {
            // #1731 - Aid debugging by exposing the computed's options
            computedObservable["_options"] = options;
        }
    
        if (state.disposeWhenNodeIsRemoved) {
            // Since this computed is associated with a DOM node, and we don't want to dispose the computed
            // until the DOM node is *removed* from the document (as opposed to never having been in the document),
            // we'll prevent disposal until "disposeWhen" first returns false.
            state.suppressDisposalUntilDisposeWhenReturnsFalse = true;
    
            // disposeWhenNodeIsRemoved: true can be used to opt into the "only dispose after first false result"
            // behaviour even if there's no specific node to watch. In that case, clear the option so we don't try
            // to watch for a non-node's disposal. This technique is intended for KO's internal use only and shouldn't
            // be documented or used by application code, as it's likely to change in a future version of KO.
            if (!state.disposeWhenNodeIsRemoved.nodeType) {
                state.disposeWhenNodeIsRemoved = null;
            }
        }
    
        // Evaluate, unless sleeping or deferEvaluation is true
        if (!state.isSleeping && !options['deferEvaluation']) {
            computedObservable.evaluateImmediate();
        }
    
        // Attach a DOM node disposal callback so that the computed will be proactively disposed as soon as the node is
        // removed using ko.removeNode. But skip if isActive is false (there will never be any dependencies to dispose).
        if (state.disposeWhenNodeIsRemoved && computedObservable.isActive()) {
            ko.utils.domNodeDisposal.addDisposeCallback(state.disposeWhenNodeIsRemoved, state.domNodeDisposalCallback = function () {
                computedObservable.dispose();
            });
        }
    
        return computedObservable;
    };
    
    // Utility function that disposes a given dependencyTracking entry
    function computedDisposeDependencyCallback(id, entryToDispose) {
        if (entryToDispose !== null && entryToDispose.dispose) {
            entryToDispose.dispose();
        }
    }
    
    // This function gets called each time a dependency is detected while evaluating a computed.
    // It's factored out as a shared function to avoid creating unnecessary function instances during evaluation.
    function computedBeginDependencyDetectionCallback(subscribable, id) {
        var computedObservable = this.computedObservable,
            state = computedObservable[computedState];
        if (!state.isDisposed) {
            if (this.disposalCount && this.disposalCandidates[id]) {
                // Don't want to dispose this subscription, as it's still being used
                computedObservable.addDependencyTracking(id, subscribable, this.disposalCandidates[id]);
                this.disposalCandidates[id] = null; // No need to actually delete the property - disposalCandidates is a transient object anyway
                --this.disposalCount;
            } else if (!state.dependencyTracking[id]) {
                // Brand new subscription - add it
                computedObservable.addDependencyTracking(id, subscribable, state.isSleeping ? { _target: subscribable } : computedObservable.subscribeToDependency(subscribable));
            }
            // If the observable we've accessed has a pending notification, ensure we get notified of the actual final value (bypass equality checks)
            if (subscribable._notificationIsPending) {
                subscribable._notifyNextChangeIfValueIsDifferent();
            }
        }
    }
    
    var computedFn = {
        "equalityComparer": valuesArePrimitiveAndEqual,
        getDependenciesCount: function () {
            return this[computedState].dependenciesCount;
        },
        addDependencyTracking: function (id, target, trackingObj) {
            if (this[computedState].pure && target === this) {
                throw Error("A 'pure' computed must not be called recursively");
            }
    
            this[computedState].dependencyTracking[id] = trackingObj;
            trackingObj._order = this[computedState].dependenciesCount++;
            trackingObj._version = target.getVersion();
        },
        haveDependenciesChanged: function () {
            var id, dependency, dependencyTracking = this[computedState].dependencyTracking;
            for (id in dependencyTracking) {
                if (dependencyTracking.hasOwnProperty(id)) {
                    dependency = dependencyTracking[id];
                    if ((this._evalDelayed && dependency._target._notificationIsPending) || dependency._target.hasChanged(dependency._version)) {
                        return true;
                    }
                }
            }
        },
        markDirty: function () {
            // Process "dirty" events if we can handle delayed notifications
            if (this._evalDelayed && !this[computedState].isBeingEvaluated) {
                this._evalDelayed(false /*isChange*/);
            }
        },
        isActive: function () {
            var state = this[computedState];
            return state.isDirty || state.dependenciesCount > 0;
        },
        respondToChange: function () {
            // Ignore "change" events if we've already scheduled a delayed notification
            if (!this._notificationIsPending) {
                this.evaluatePossiblyAsync();
            } else if (this[computedState].isDirty) {
                this[computedState].isStale = true;
            }
        },
        subscribeToDependency: function (target) {
            if (target._deferUpdates && !this[computedState].disposeWhenNodeIsRemoved) {
                var dirtySub = target.subscribe(this.markDirty, this, 'dirty'),
                    changeSub = target.subscribe(this.respondToChange, this);
                return {
                    _target: target,
                    dispose: function () {
                        dirtySub.dispose();
                        changeSub.dispose();
                    }
                };
            } else {
                return target.subscribe(this.evaluatePossiblyAsync, this);
            }
        },
        evaluatePossiblyAsync: function () {
            var computedObservable = this,
                throttleEvaluationTimeout = computedObservable['throttleEvaluation'];
            if (throttleEvaluationTimeout && throttleEvaluationTimeout >= 0) {
                clearTimeout(this[computedState].evaluationTimeoutInstance);
                this[computedState].evaluationTimeoutInstance = ko.utils.setTimeout(function () {
                    computedObservable.evaluateImmediate(true /*notifyChange*/);
                }, throttleEvaluationTimeout);
            } else if (computedObservable._evalDelayed) {
                computedObservable._evalDelayed(true /*isChange*/);
            } else {
                computedObservable.evaluateImmediate(true /*notifyChange*/);
            }
        },
        evaluateImmediate: function (notifyChange) {
            var computedObservable = this,
                state = computedObservable[computedState],
                disposeWhen = state.disposeWhen,
                changed = false;
    
            if (state.isBeingEvaluated) {
                // If the evaluation of a ko.computed causes side effects, it's possible that it will trigger its own re-evaluation.
                // This is not desirable (it's hard for a developer to realise a chain of dependencies might cause this, and they almost
                // certainly didn't intend infinite re-evaluations). So, for predictability, we simply prevent ko.computeds from causing
                // their own re-evaluation. Further discussion at https://github.com/SteveSanderson/knockout/pull/387
                return;
            }
    
            // Do not evaluate (and possibly capture new dependencies) if disposed
            if (state.isDisposed) {
                return;
            }
    
            if (state.disposeWhenNodeIsRemoved && !ko.utils.domNodeIsAttachedToDocument(state.disposeWhenNodeIsRemoved) || disposeWhen && disposeWhen()) {
                // See comment above about suppressDisposalUntilDisposeWhenReturnsFalse
                if (!state.suppressDisposalUntilDisposeWhenReturnsFalse) {
                    computedObservable.dispose();
                    return;
                }
            } else {
                // It just did return false, so we can stop suppressing now
                state.suppressDisposalUntilDisposeWhenReturnsFalse = false;
            }
    
            state.isBeingEvaluated = true;
            try {
                changed = this.evaluateImmediate_CallReadWithDependencyDetection(notifyChange);
            } finally {
                state.isBeingEvaluated = false;
            }
    
            if (!state.dependenciesCount) {
                computedObservable.dispose();
            }
    
            return changed;
        },
        evaluateImmediate_CallReadWithDependencyDetection: function (notifyChange) {
            // This function is really just part of the evaluateImmediate logic. You would never call it from anywhere else.
            // Factoring it out into a separate function means it can be independent of the try/catch block in evaluateImmediate,
            // which contributes to saving about 40% off the CPU overhead of computed evaluation (on V8 at least).
    
            var computedObservable = this,
                state = computedObservable[computedState],
                changed = false;
    
            // Initially, we assume that none of the subscriptions are still being used (i.e., all are candidates for disposal).
            // Then, during evaluation, we cross off any that are in fact still being used.
            var isInitial = state.pure ? undefined : !state.dependenciesCount,   // If we're evaluating when there are no previous dependencies, it must be the first time
                dependencyDetectionContext = {
                    computedObservable: computedObservable,
                    disposalCandidates: state.dependencyTracking,
                    disposalCount: state.dependenciesCount
                };
    
            ko.dependencyDetection.begin({
                callbackTarget: dependencyDetectionContext,
                callback: computedBeginDependencyDetectionCallback,
                computed: computedObservable,
                isInitial: isInitial
            });
    
            state.dependencyTracking = {};
            state.dependenciesCount = 0;
    
            var newValue = this.evaluateImmediate_CallReadThenEndDependencyDetection(state, dependencyDetectionContext);
    
            if (computedObservable.isDifferent(state.latestValue, newValue)) {
                if (!state.isSleeping) {
                    computedObservable["notifySubscribers"](state.latestValue, "beforeChange");
                }
    
                state.latestValue = newValue;
                if (DEBUG) computedObservable._latestValue = newValue;
    
                if (state.isSleeping) {
                    computedObservable.updateVersion();
                } else if (notifyChange) {
                    computedObservable["notifySubscribers"](state.latestValue);
                }
    
                changed = true;
            }
    
            if (isInitial) {
                computedObservable["notifySubscribers"](state.latestValue, "awake");
            }
    
            return changed;
        },
        evaluateImmediate_CallReadThenEndDependencyDetection: function (state, dependencyDetectionContext) {
            // This function is really part of the evaluateImmediate_CallReadWithDependencyDetection logic.
            // You'd never call it from anywhere else. Factoring it out means that evaluateImmediate_CallReadWithDependencyDetection
            // can be independent of try/finally blocks, which contributes to saving about 40% off the CPU
            // overhead of computed evaluation (on V8 at least).
    
            try {
                var readFunction = state.readFunction;
                return state.evaluatorFunctionTarget ? readFunction.call(state.evaluatorFunctionTarget) : readFunction();
            } finally {
                ko.dependencyDetection.end();
    
                // For each subscription no longer being used, remove it from the active subscriptions list and dispose it
                if (dependencyDetectionContext.disposalCount && !state.isSleeping) {
                    ko.utils.objectForEach(dependencyDetectionContext.disposalCandidates, computedDisposeDependencyCallback);
                }
    
                state.isStale = state.isDirty = false;
            }
        },
        peek: function (evaluate) {
            // By default, peek won't re-evaluate, except while the computed is sleeping or to get the initial value when "deferEvaluation" is set.
            // Pass in true to evaluate if needed.
            var state = this[computedState];
            if ((state.isDirty && (evaluate || !state.dependenciesCount)) || (state.isSleeping && this.haveDependenciesChanged())) {
                this.evaluateImmediate();
            }
            return state.latestValue;
        },
        limit: function (limitFunction) {
            // Override the limit function with one that delays evaluation as well
            ko.subscribable['fn'].limit.call(this, limitFunction);
            this._evalIfChanged = function () {
                if (this[computedState].isStale) {
                    this.evaluateImmediate();
                } else {
                    this[computedState].isDirty = false;
                }
                return this[computedState].latestValue;
            };
            this._evalDelayed = function (isChange) {
                this._limitBeforeChange(this[computedState].latestValue);
    
                // Mark as dirty
                this[computedState].isDirty = true;
                if (isChange) {
                    this[computedState].isStale = true;
                }
    
                // Pass the observable to the "limit" code, which will evaluate it when
                // it's time to do the notification.
                this._limitChange(this);
            };
        },
        dispose: function () {
            var state = this[computedState];
            if (!state.isSleeping && state.dependencyTracking) {
                ko.utils.objectForEach(state.dependencyTracking, function (id, dependency) {
                    if (dependency.dispose)
                        dependency.dispose();
                });
            }
            if (state.disposeWhenNodeIsRemoved && state.domNodeDisposalCallback) {
                ko.utils.domNodeDisposal.removeDisposeCallback(state.disposeWhenNodeIsRemoved, state.domNodeDisposalCallback);
            }
            state.dependencyTracking = null;
            state.dependenciesCount = 0;
            state.isDisposed = true;
            state.isStale = false;
            state.isDirty = false;
            state.isSleeping = false;
            state.disposeWhenNodeIsRemoved = null;
        }
    };
    
    var pureComputedOverrides = {
        beforeSubscriptionAdd: function (event) {
            // If asleep, wake up the computed by subscribing to any dependencies.
            var computedObservable = this,
                state = computedObservable[computedState];
            if (!state.isDisposed && state.isSleeping && event == 'change') {
                state.isSleeping = false;
                if (state.isStale || computedObservable.haveDependenciesChanged()) {
                    state.dependencyTracking = null;
                    state.dependenciesCount = 0;
                    if (computedObservable.evaluateImmediate()) {
                        computedObservable.updateVersion();
                    }
                } else {
                    // First put the dependencies in order
                    var dependeciesOrder = [];
                    ko.utils.objectForEach(state.dependencyTracking, function (id, dependency) {
                        dependeciesOrder[dependency._order] = id;
                    });
                    // Next, subscribe to each one
                    ko.utils.arrayForEach(dependeciesOrder, function (id, order) {
                        var dependency = state.dependencyTracking[id],
                            subscription = computedObservable.subscribeToDependency(dependency._target);
                        subscription._order = order;
                        subscription._version = dependency._version;
                        state.dependencyTracking[id] = subscription;
                    });
                }
                if (!state.isDisposed) {     // test since evaluating could trigger disposal
                    computedObservable["notifySubscribers"](state.latestValue, "awake");
                }
            }
        },
        afterSubscriptionRemove: function (event) {
            var state = this[computedState];
            if (!state.isDisposed && event == 'change' && !this.hasSubscriptionsForEvent('change')) {
                ko.utils.objectForEach(state.dependencyTracking, function (id, dependency) {
                    if (dependency.dispose) {
                        state.dependencyTracking[id] = {
                            _target: dependency._target,
                            _order: dependency._order,
                            _version: dependency._version
                        };
                        dependency.dispose();
                    }
                });
                state.isSleeping = true;
                this["notifySubscribers"](undefined, "asleep");
            }
        },
        getVersion: function () {
            // Because a pure computed is not automatically updated while it is sleeping, we can't
            // simply return the version number. Instead, we check if any of the dependencies have
            // changed and conditionally re-evaluate the computed observable.
            var state = this[computedState];
            if (state.isSleeping && (state.isStale || this.haveDependenciesChanged())) {
                this.evaluateImmediate();
            }
            return ko.subscribable['fn'].getVersion.call(this);
        }
    };
    
    var deferEvaluationOverrides = {
        beforeSubscriptionAdd: function (event) {
            // This will force a computed with deferEvaluation to evaluate when the first subscription is registered.
            if (event == 'change' || event == 'beforeChange') {
                this.peek();
            }
        }
    };
    
    // Note that for browsers that don't support proto assignment, the
    // inheritance chain is created manually in the ko.computed constructor
    if (ko.utils.canSetPrototype) {
        ko.utils.setPrototypeOf(computedFn, ko.subscribable['fn']);
    }
    
    // Set the proto chain values for ko.hasPrototype
    var protoProp = ko.observable.protoProperty; // == "__ko_proto__"
    ko.computed[protoProp] = ko.observable;
    computedFn[protoProp] = ko.computed;
    
    ko.isComputed = function (instance) {
        return ko.hasPrototype(instance, ko.computed);
    };
    
    ko.isPureComputed = function (instance) {
        return ko.hasPrototype(instance, ko.computed)
            && instance[computedState] && instance[computedState].pure;
    };
    
    ko.exportSymbol('computed', ko.computed);
    ko.exportSymbol('dependentObservable', ko.computed);    // export ko.dependentObservable for backwards compatibility (1.x)
    ko.exportSymbol('isComputed', ko.isComputed);
    ko.exportSymbol('isPureComputed', ko.isPureComputed);
    ko.exportSymbol('computed.fn', computedFn);
    ko.exportProperty(computedFn, 'peek', computedFn.peek);
    ko.exportProperty(computedFn, 'dispose', computedFn.dispose);
    ko.exportProperty(computedFn, 'isActive', computedFn.isActive);
    ko.exportProperty(computedFn, 'getDependenciesCount', computedFn.getDependenciesCount);
    
    ko.pureComputed = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget) {
        if (typeof evaluatorFunctionOrOptions === 'function') {
            return ko.computed(evaluatorFunctionOrOptions, evaluatorFunctionTarget, {'pure':true});
        } else {
            evaluatorFunctionOrOptions = ko.utils.extend({}, evaluatorFunctionOrOptions);   // make a copy of the parameter object
            evaluatorFunctionOrOptions['pure'] = true;
            return ko.computed(evaluatorFunctionOrOptions, evaluatorFunctionTarget);
        }
    }
    ko.exportSymbol('pureComputed', ko.pureComputed);
    
    (function() {
        var maxNestedObservableDepth = 10; // Escape the (unlikely) pathalogical case where an observable's current value is itself (or similar reference cycle)
    
        ko.toJS = function(rootObject) {
            if (arguments.length == 0)
                throw new Error("When calling ko.toJS, pass the object you want to convert.");
    
            // We just unwrap everything at every level in the object graph
            return mapJsObjectGraph(rootObject, function(valueToMap) {
                // Loop because an observable's value might in turn be another observable wrapper
                for (var i = 0; ko.isObservable(valueToMap) && (i < maxNestedObservableDepth); i++)
                    valueToMap = valueToMap();
                return valueToMap;
            });
        };
    
        ko.toJSON = function(rootObject, replacer, space) {     // replacer and space are optional
            var plainJavaScriptObject = ko.toJS(rootObject);
            return ko.utils.stringifyJson(plainJavaScriptObject, replacer, space);
        };
    
        function mapJsObjectGraph(rootObject, mapInputCallback, visitedObjects) {
            visitedObjects = visitedObjects || new objectLookup();
    
            rootObject = mapInputCallback(rootObject);
            var canHaveProperties = (typeof rootObject == "object") && (rootObject !== null) && (rootObject !== undefined) && (!(rootObject instanceof RegExp)) && (!(rootObject instanceof Date)) && (!(rootObject instanceof String)) && (!(rootObject instanceof Number)) && (!(rootObject instanceof Boolean));
            if (!canHaveProperties)
                return rootObject;
    
            var outputProperties = rootObject instanceof Array ? [] : {};
            visitedObjects.save(rootObject, outputProperties);
    
            visitPropertiesOrArrayEntries(rootObject, function(indexer) {
                var propertyValue = mapInputCallback(rootObject[indexer]);
    
                switch (typeof propertyValue) {
                    case "boolean":
                    case "number":
                    case "string":
                    case "function":
                        outputProperties[indexer] = propertyValue;
                        break;
                    case "object":
                    case "undefined":
                        var previouslyMappedValue = visitedObjects.get(propertyValue);
                        outputProperties[indexer] = (previouslyMappedValue !== undefined)
                            ? previouslyMappedValue
                            : mapJsObjectGraph(propertyValue, mapInputCallback, visitedObjects);
                        break;
                }
            });
    
            return outputProperties;
        }
    
        function visitPropertiesOrArrayEntries(rootObject, visitorCallback) {
            if (rootObject instanceof Array) {
                for (var i = 0; i < rootObject.length; i++)
                    visitorCallback(i);
    
                // For arrays, also respect toJSON property for custom mappings (fixes #278)
                if (typeof rootObject['toJSON'] == 'function')
                    visitorCallback('toJSON');
            } else {
                for (var propertyName in rootObject) {
                    visitorCallback(propertyName);
                }
            }
        };
    
        function objectLookup() {
            this.keys = [];
            this.values = [];
        };
    
        objectLookup.prototype = {
            constructor: objectLookup,
            save: function(key, value) {
                var existingIndex = ko.utils.arrayIndexOf(this.keys, key);
                if (existingIndex >= 0)
                    this.values[existingIndex] = value;
                else {
                    this.keys.push(key);
                    this.values.push(value);
                }
            },
            get: function(key) {
                var existingIndex = ko.utils.arrayIndexOf(this.keys, key);
                return (existingIndex >= 0) ? this.values[existingIndex] : undefined;
            }
        };
    })();
    
    ko.exportSymbol('toJS', ko.toJS);
    ko.exportSymbol('toJSON', ko.toJSON);
    (function () {
        var hasDomDataExpandoProperty = '__ko__hasDomDataOptionValue__';
    
        // Normally, SELECT elements and their OPTIONs can only take value of type 'string' (because the values
        // are stored on DOM attributes). ko.selectExtensions provides a way for SELECTs/OPTIONs to have values
        // that are arbitrary objects. This is very convenient when implementing things like cascading dropdowns.
        ko.selectExtensions = {
            readValue : function(element) {
                switch (ko.utils.tagNameLower(element)) {
                    case 'option':
                        if (element[hasDomDataExpandoProperty] === true)
                            return ko.utils.domData.get(element, ko.bindingHandlers.options.optionValueDomDataKey);
                        return ko.utils.ieVersion <= 7
                            ? (element.getAttributeNode('value') && element.getAttributeNode('value').specified ? element.value : element.text)
                            : element.value;
                    case 'select':
                        return element.selectedIndex >= 0 ? ko.selectExtensions.readValue(element.options[element.selectedIndex]) : undefined;
                    default:
                        return element.value;
                }
            },
    
            writeValue: function(element, value, allowUnset) {
                switch (ko.utils.tagNameLower(element)) {
                    case 'option':
                        switch(typeof value) {
                            case "string":
                                ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, undefined);
                                if (hasDomDataExpandoProperty in element) { // IE <= 8 throws errors if you delete non-existent properties from a DOM node
                                    delete element[hasDomDataExpandoProperty];
                                }
                                element.value = value;
                                break;
                            default:
                                // Store arbitrary object using DomData
                                ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, value);
                                element[hasDomDataExpandoProperty] = true;
    
                                // Special treatment of numbers is just for backward compatibility. KO 1.2.1 wrote numerical values to element.value.
                                element.value = typeof value === "number" ? value : "";
                                break;
                        }
                        break;
                    case 'select':
                        if (value === "" || value === null)       // A blank string or null value will select the caption
                            value = undefined;
                        var selection = -1;
                        for (var i = 0, n = element.options.length, optionValue; i < n; ++i) {
                            optionValue = ko.selectExtensions.readValue(element.options[i]);
                            // Include special check to handle selecting a caption with a blank string value
                            if (optionValue == value || (optionValue == "" && value === undefined)) {
                                selection = i;
                                break;
                            }
                        }
                        if (allowUnset || selection >= 0 || (value === undefined && element.size > 1)) {
                            element.selectedIndex = selection;
                        }
                        break;
                    default:
                        if ((value === null) || (value === undefined))
                            value = "";
                        element.value = value;
                        break;
                }
            }
        };
    })();
    
    ko.exportSymbol('selectExtensions', ko.selectExtensions);
    ko.exportSymbol('selectExtensions.readValue', ko.selectExtensions.readValue);
    ko.exportSymbol('selectExtensions.writeValue', ko.selectExtensions.writeValue);
    ko.expressionRewriting = (function () {
        var javaScriptReservedWords = ["true", "false", "null", "undefined"];
    
        // Matches something that can be assigned to--either an isolated identifier or something ending with a property accessor
        // This is designed to be simple and avoid false negatives, but could produce false positives (e.g., a+b.c).
        // This also will not properly handle nested brackets (e.g., obj1[obj2['prop']]; see #911).
        var javaScriptAssignmentTarget = /^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i;
    
        function getWriteableValue(expression) {
            if (ko.utils.arrayIndexOf(javaScriptReservedWords, expression) >= 0)
                return false;
            var match = expression.match(javaScriptAssignmentTarget);
            return match === null ? false : match[1] ? ('Object(' + match[1] + ')' + match[2]) : expression;
        }
    
        // The following regular expressions will be used to split an object-literal string into tokens
    
            // These two match strings, either with double quotes or single quotes
        var stringDouble = '"(?:[^"\\\\]|\\\\.)*"',
            stringSingle = "'(?:[^'\\\\]|\\\\.)*'",
            // Matches a regular expression (text enclosed by slashes), but will also match sets of divisions
            // as a regular expression (this is handled by the parsing loop below).
            stringRegexp = '/(?:[^/\\\\]|\\\\.)*/\w*',
            // These characters have special meaning to the parser and must not appear in the middle of a
            // token, except as part of a string.
            specials = ',"\'{}()/:[\\]',
            // Match text (at least two characters) that does not contain any of the above special characters,
            // although some of the special characters are allowed to start it (all but the colon and comma).
            // The text can contain spaces, but leading or trailing spaces are skipped.
            everyThingElse = '[^\\s:,/][^' + specials + ']*[^\\s' + specials + ']',
            // Match any non-space character not matched already. This will match colons and commas, since they're
            // not matched by "everyThingElse", but will also match any other single character that wasn't already
            // matched (for example: in "a: 1, b: 2", each of the non-space characters will be matched by oneNotSpace).
            oneNotSpace = '[^\\s]',
    
            // Create the actual regular expression by or-ing the above strings. The order is important.
            bindingToken = RegExp(stringDouble + '|' + stringSingle + '|' + stringRegexp + '|' + everyThingElse + '|' + oneNotSpace, 'g'),
    
            // Match end of previous token to determine whether a slash is a division or regex.
            divisionLookBehind = /[\])"'A-Za-z0-9_$]+$/,
            keywordRegexLookBehind = {'in':1,'return':1,'typeof':1};
    
        function parseObjectLiteral(objectLiteralString) {
            // Trim leading and trailing spaces from the string
            var str = ko.utils.stringTrim(objectLiteralString);
    
            // Trim braces '{' surrounding the whole object literal
            if (str.charCodeAt(0) === 123) str = str.slice(1, -1);
    
            // Split into tokens
            var result = [], toks = str.match(bindingToken), key, values = [], depth = 0;
    
            if (toks) {
                // Append a comma so that we don't need a separate code block to deal with the last item
                toks.push(',');
    
                for (var i = 0, tok; tok = toks[i]; ++i) {
                    var c = tok.charCodeAt(0);
                    // A comma signals the end of a key/value pair if depth is zero
                    if (c === 44) { // ","
                        if (depth <= 0) {
                            result.push((key && values.length) ? {key: key, value: values.join('')} : {'unknown': key || values.join('')});
                            key = depth = 0;
                            values = [];
                            continue;
                        }
                    // Simply skip the colon that separates the name and value
                    } else if (c === 58) { // ":"
                        if (!depth && !key && values.length === 1) {
                            key = values.pop();
                            continue;
                        }
                    // A set of slashes is initially matched as a regular expression, but could be division
                    } else if (c === 47 && i && tok.length > 1) {  // "/"
                        // Look at the end of the previous token to determine if the slash is actually division
                        var match = toks[i-1].match(divisionLookBehind);
                        if (match && !keywordRegexLookBehind[match[0]]) {
                            // The slash is actually a division punctuator; re-parse the remainder of the string (not including the slash)
                            str = str.substr(str.indexOf(tok) + 1);
                            toks = str.match(bindingToken);
                            toks.push(',');
                            i = -1;
                            // Continue with just the slash
                            tok = '/';
                        }
                    // Increment depth for parentheses, braces, and brackets so that interior commas are ignored
                    } else if (c === 40 || c === 123 || c === 91) { // '(', '{', '['
                        ++depth;
                    } else if (c === 41 || c === 125 || c === 93) { // ')', '}', ']'
                        --depth;
                    // The key will be the first token; if it's a string, trim the quotes
                    } else if (!key && !values.length && (c === 34 || c === 39)) { // '"', "'"
                        tok = tok.slice(1, -1);
                    }
                    values.push(tok);
                }
            }
            return result;
        }
    
        // Two-way bindings include a write function that allow the handler to update the value even if it's not an observable.
        var twoWayBindings = {};
    
        function preProcessBindings(bindingsStringOrKeyValueArray, bindingOptions) {
            bindingOptions = bindingOptions || {};
    
            function processKeyValue(key, val) {
                var writableVal;
                function callPreprocessHook(obj) {
                    return (obj && obj['preprocess']) ? (val = obj['preprocess'](val, key, processKeyValue)) : true;
                }
                if (!bindingParams) {
                    if (!callPreprocessHook(ko['getBindingHandler'](key)))
                        return;
    
                    if (twoWayBindings[key] && (writableVal = getWriteableValue(val))) {
                        // For two-way bindings, provide a write method in case the value
                        // isn't a writable observable.
                        propertyAccessorResultStrings.push("'" + key + "':function(_z){" + writableVal + "=_z}");
                    }
                }
                // Values are wrapped in a function so that each value can be accessed independently
                if (makeValueAccessors) {
                    val = 'function(){return ' + val + ' }';
                }
                resultStrings.push("'" + key + "':" + val);
            }
    
            var resultStrings = [],
                propertyAccessorResultStrings = [],
                makeValueAccessors = bindingOptions['valueAccessors'],
                bindingParams = bindingOptions['bindingParams'],
                keyValueArray = typeof bindingsStringOrKeyValueArray === "string" ?
                    parseObjectLiteral(bindingsStringOrKeyValueArray) : bindingsStringOrKeyValueArray;
    
            ko.utils.arrayForEach(keyValueArray, function(keyValue) {
                processKeyValue(keyValue.key || keyValue['unknown'], keyValue.value);
            });
    
            if (propertyAccessorResultStrings.length)
                processKeyValue('_ko_property_writers', "{" + propertyAccessorResultStrings.join(",") + " }");
    
            return resultStrings.join(",");
        }
    
        return {
            bindingRewriteValidators: [],
    
            twoWayBindings: twoWayBindings,
    
            parseObjectLiteral: parseObjectLiteral,
    
            preProcessBindings: preProcessBindings,
    
            keyValueArrayContainsKey: function(keyValueArray, key) {
                for (var i = 0; i < keyValueArray.length; i++)
                    if (keyValueArray[i]['key'] == key)
                        return true;
                return false;
            },
    
            // Internal, private KO utility for updating model properties from within bindings
            // property:            If the property being updated is (or might be) an observable, pass it here
            //                      If it turns out to be a writable observable, it will be written to directly
            // allBindings:         An object with a get method to retrieve bindings in the current execution context.
            //                      This will be searched for a '_ko_property_writers' property in case you're writing to a non-observable
            // key:                 The key identifying the property to be written. Example: for { hasFocus: myValue }, write to 'myValue' by specifying the key 'hasFocus'
            // value:               The value to be written
            // checkIfDifferent:    If true, and if the property being written is a writable observable, the value will only be written if
            //                      it is !== existing value on that writable observable
            writeValueToProperty: function(property, allBindings, key, value, checkIfDifferent) {
                if (!property || !ko.isObservable(property)) {
                    var propWriters = allBindings.get('_ko_property_writers');
                    if (propWriters && propWriters[key])
                        propWriters[key](value);
                } else if (ko.isWriteableObservable(property) && (!checkIfDifferent || property.peek() !== value)) {
                    property(value);
                }
            }
        };
    })();
    
    ko.exportSymbol('expressionRewriting', ko.expressionRewriting);
    ko.exportSymbol('expressionRewriting.bindingRewriteValidators', ko.expressionRewriting.bindingRewriteValidators);
    ko.exportSymbol('expressionRewriting.parseObjectLiteral', ko.expressionRewriting.parseObjectLiteral);
    ko.exportSymbol('expressionRewriting.preProcessBindings', ko.expressionRewriting.preProcessBindings);
    
    // Making bindings explicitly declare themselves as "two way" isn't ideal in the long term (it would be better if
    // all bindings could use an official 'property writer' API without needing to declare that they might). However,
    // since this is not, and has never been, a public API (_ko_property_writers was never documented), it's acceptable
    // as an internal implementation detail in the short term.
    // For those developers who rely on _ko_property_writers in their custom bindings, we expose _twoWayBindings as an
    // undocumented feature that makes it relatively easy to upgrade to KO 3.0. However, this is still not an official
    // public API, and we reserve the right to remove it at any time if we create a real public property writers API.
    ko.exportSymbol('expressionRewriting._twoWayBindings', ko.expressionRewriting.twoWayBindings);
    
    // For backward compatibility, define the following aliases. (Previously, these function names were misleading because
    // they referred to JSON specifically, even though they actually work with arbitrary JavaScript object literal expressions.)
    ko.exportSymbol('jsonExpressionRewriting', ko.expressionRewriting);
    ko.exportSymbol('jsonExpressionRewriting.insertPropertyAccessorsIntoJson', ko.expressionRewriting.preProcessBindings);
    (function() {
        // "Virtual elements" is an abstraction on top of the usual DOM API which understands the notion that comment nodes
        // may be used to represent hierarchy (in addition to the DOM's natural hierarchy).
        // If you call the DOM-manipulating functions on ko.virtualElements, you will be able to read and write the state
        // of that virtual hierarchy
        //
        // The point of all this is to support containerless templates (e.g., <!-- ko foreach:someCollection -->blah<!-- /ko -->)
        // without having to scatter special cases all over the binding and templating code.
    
        // IE 9 cannot reliably read the "nodeValue" property of a comment node (see https://github.com/SteveSanderson/knockout/issues/186)
        // but it does give them a nonstandard alternative property called "text" that it can read reliably. Other browsers don't have that property.
        // So, use node.text where available, and node.nodeValue elsewhere
        var commentNodesHaveTextProperty = document && document.createComment("test").text === "<!--test-->";
    
        var startCommentRegex = commentNodesHaveTextProperty ? /^<!--\s*ko(?:\s+([\s\S]+))?\s*-->$/ : /^\s*ko(?:\s+([\s\S]+))?\s*$/;
        var endCommentRegex =   commentNodesHaveTextProperty ? /^<!--\s*\/ko\s*-->$/ : /^\s*\/ko\s*$/;
        var htmlTagsWithOptionallyClosingChildren = { 'ul': true, 'ol': true };
    
        function isStartComment(node) {
            return (node.nodeType == 8) && startCommentRegex.test(commentNodesHaveTextProperty ? node.text : node.nodeValue);
        }
    
        function isEndComment(node) {
            return (node.nodeType == 8) && endCommentRegex.test(commentNodesHaveTextProperty ? node.text : node.nodeValue);
        }
    
        function getVirtualChildren(startComment, allowUnbalanced) {
            var currentNode = startComment;
            var depth = 1;
            var children = [];
            while (currentNode = currentNode.nextSibling) {
                if (isEndComment(currentNode)) {
                    depth--;
                    if (depth === 0)
                        return children;
                }
    
                children.push(currentNode);
    
                if (isStartComment(currentNode))
                    depth++;
            }
            if (!allowUnbalanced)
                throw new Error("Cannot find closing comment tag to match: " + startComment.nodeValue);
            return null;
        }
    
        function getMatchingEndComment(startComment, allowUnbalanced) {
            var allVirtualChildren = getVirtualChildren(startComment, allowUnbalanced);
            if (allVirtualChildren) {
                if (allVirtualChildren.length > 0)
                    return allVirtualChildren[allVirtualChildren.length - 1].nextSibling;
                return startComment.nextSibling;
            } else
                return null; // Must have no matching end comment, and allowUnbalanced is true
        }
    
        function getUnbalancedChildTags(node) {
            // e.g., from <div>OK</div><!-- ko blah --><span>Another</span>, returns: <!-- ko blah --><span>Another</span>
            //       from <div>OK</div><!-- /ko --><!-- /ko -->,             returns: <!-- /ko --><!-- /ko -->
            var childNode = node.firstChild, captureRemaining = null;
            if (childNode) {
                do {
                    if (captureRemaining)                   // We already hit an unbalanced node and are now just scooping up all subsequent nodes
                        captureRemaining.push(childNode);
                    else if (isStartComment(childNode)) {
                        var matchingEndComment = getMatchingEndComment(childNode, /* allowUnbalanced: */ true);
                        if (matchingEndComment)             // It's a balanced tag, so skip immediately to the end of this virtual set
                            childNode = matchingEndComment;
                        else
                            captureRemaining = [childNode]; // It's unbalanced, so start capturing from this point
                    } else if (isEndComment(childNode)) {
                        captureRemaining = [childNode];     // It's unbalanced (if it wasn't, we'd have skipped over it already), so start capturing
                    }
                } while (childNode = childNode.nextSibling);
            }
            return captureRemaining;
        }
    
        ko.virtualElements = {
            allowedBindings: {},
    
            childNodes: function(node) {
                return isStartComment(node) ? getVirtualChildren(node) : node.childNodes;
            },
    
            emptyNode: function(node) {
                if (!isStartComment(node))
                    ko.utils.emptyDomNode(node);
                else {
                    var virtualChildren = ko.virtualElements.childNodes(node);
                    for (var i = 0, j = virtualChildren.length; i < j; i++)
                        ko.removeNode(virtualChildren[i]);
                }
            },
    
            setDomNodeChildren: function(node, childNodes) {
                if (!isStartComment(node))
                    ko.utils.setDomNodeChildren(node, childNodes);
                else {
                    ko.virtualElements.emptyNode(node);
                    var endCommentNode = node.nextSibling; // Must be the next sibling, as we just emptied the children
                    for (var i = 0, j = childNodes.length; i < j; i++)
                        endCommentNode.parentNode.insertBefore(childNodes[i], endCommentNode);
                }
            },
    
            prepend: function(containerNode, nodeToPrepend) {
                if (!isStartComment(containerNode)) {
                    if (containerNode.firstChild)
                        containerNode.insertBefore(nodeToPrepend, containerNode.firstChild);
                    else
                        containerNode.appendChild(nodeToPrepend);
                } else {
                    // Start comments must always have a parent and at least one following sibling (the end comment)
                    containerNode.parentNode.insertBefore(nodeToPrepend, containerNode.nextSibling);
                }
            },
    
            insertAfter: function(containerNode, nodeToInsert, insertAfterNode) {
                if (!insertAfterNode) {
                    ko.virtualElements.prepend(containerNode, nodeToInsert);
                } else if (!isStartComment(containerNode)) {
                    // Insert after insertion point
                    if (insertAfterNode.nextSibling)
                        containerNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);
                    else
                        containerNode.appendChild(nodeToInsert);
                } else {
                    // Children of start comments must always have a parent and at least one following sibling (the end comment)
                    containerNode.parentNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);
                }
            },
    
            firstChild: function(node) {
                if (!isStartComment(node))
                    return node.firstChild;
                if (!node.nextSibling || isEndComment(node.nextSibling))
                    return null;
                return node.nextSibling;
            },
    
            nextSibling: function(node) {
                if (isStartComment(node))
                    node = getMatchingEndComment(node);
                if (node.nextSibling && isEndComment(node.nextSibling))
                    return null;
                return node.nextSibling;
            },
    
            hasBindingValue: isStartComment,
    
            virtualNodeBindingValue: function(node) {
                var regexMatch = (commentNodesHaveTextProperty ? node.text : node.nodeValue).match(startCommentRegex);
                return regexMatch ? regexMatch[1] : null;
            },
    
            normaliseVirtualElementDomStructure: function(elementVerified) {
                // Workaround for https://github.com/SteveSanderson/knockout/issues/155
                // (IE <= 8 or IE 9 quirks mode parses your HTML weirdly, treating closing </li> tags as if they don't exist, thereby moving comment nodes
                // that are direct descendants of <ul> into the preceding <li>)
                if (!htmlTagsWithOptionallyClosingChildren[ko.utils.tagNameLower(elementVerified)])
                    return;
    
                // Scan immediate children to see if they contain unbalanced comment tags. If they do, those comment tags
                // must be intended to appear *after* that child, so move them there.
                var childNode = elementVerified.firstChild;
                if (childNode) {
                    do {
                        if (childNode.nodeType === 1) {
                            var unbalancedTags = getUnbalancedChildTags(childNode);
                            if (unbalancedTags) {
                                // Fix up the DOM by moving the unbalanced tags to where they most likely were intended to be placed - *after* the child
                                var nodeToInsertBefore = childNode.nextSibling;
                                for (var i = 0; i < unbalancedTags.length; i++) {
                                    if (nodeToInsertBefore)
                                        elementVerified.insertBefore(unbalancedTags[i], nodeToInsertBefore);
                                    else
                                        elementVerified.appendChild(unbalancedTags[i]);
                                }
                            }
                        }
                    } while (childNode = childNode.nextSibling);
                }
            }
        };
    })();
    ko.exportSymbol('virtualElements', ko.virtualElements);
    ko.exportSymbol('virtualElements.allowedBindings', ko.virtualElements.allowedBindings);
    ko.exportSymbol('virtualElements.emptyNode', ko.virtualElements.emptyNode);
    //ko.exportSymbol('virtualElements.firstChild', ko.virtualElements.firstChild);     // firstChild is not minified
    ko.exportSymbol('virtualElements.insertAfter', ko.virtualElements.insertAfter);
    //ko.exportSymbol('virtualElements.nextSibling', ko.virtualElements.nextSibling);   // nextSibling is not minified
    ko.exportSymbol('virtualElements.prepend', ko.virtualElements.prepend);
    ko.exportSymbol('virtualElements.setDomNodeChildren', ko.virtualElements.setDomNodeChildren);
    (function() {
        var defaultBindingAttributeName = "data-bind";
    
        ko.bindingProvider = function() {
            this.bindingCache = {};
        };
    
        ko.utils.extend(ko.bindingProvider.prototype, {
            'nodeHasBindings': function(node) {
                switch (node.nodeType) {
                    case 1: // Element
                        return node.getAttribute(defaultBindingAttributeName) != null
                            || ko.components['getComponentNameForNode'](node);
                    case 8: // Comment node
                        return ko.virtualElements.hasBindingValue(node);
                    default: return false;
                }
            },
    
            'getBindings': function(node, bindingContext) {
                var bindingsString = this['getBindingsString'](node, bindingContext),
                    parsedBindings = bindingsString ? this['parseBindingsString'](bindingsString, bindingContext, node) : null;
                return ko.components.addBindingsForCustomElement(parsedBindings, node, bindingContext, /* valueAccessors */ false);
            },
    
            'getBindingAccessors': function(node, bindingContext) {
                var bindingsString = this['getBindingsString'](node, bindingContext),
                    parsedBindings = bindingsString ? this['parseBindingsString'](bindingsString, bindingContext, node, { 'valueAccessors': true }) : null;
                return ko.components.addBindingsForCustomElement(parsedBindings, node, bindingContext, /* valueAccessors */ true);
            },
    
            // The following function is only used internally by this default provider.
            // It's not part of the interface definition for a general binding provider.
            'getBindingsString': function(node, bindingContext) {
                switch (node.nodeType) {
                    case 1: return node.getAttribute(defaultBindingAttributeName);   // Element
                    case 8: return ko.virtualElements.virtualNodeBindingValue(node); // Comment node
                    default: return null;
                }
            },
    
            // The following function is only used internally by this default provider.
            // It's not part of the interface definition for a general binding provider.
            'parseBindingsString': function(bindingsString, bindingContext, node, options) {
                try {
                    var bindingFunction = createBindingsStringEvaluatorViaCache(bindingsString, this.bindingCache, options);
                    return bindingFunction(bindingContext, node);
                } catch (ex) {
                    ex.message = "Unable to parse bindings.\nBindings value: " + bindingsString + "\nMessage: " + ex.message;
                    throw ex;
                }
            }
        });
    
        ko.bindingProvider['instance'] = new ko.bindingProvider();
    
        function createBindingsStringEvaluatorViaCache(bindingsString, cache, options) {
            var cacheKey = bindingsString + (options && options['valueAccessors'] || '');
            return cache[cacheKey]
                || (cache[cacheKey] = createBindingsStringEvaluator(bindingsString, options));
        }
    
        function createBindingsStringEvaluator(bindingsString, options) {
            // Build the source for a function that evaluates "expression"
            // For each scope variable, add an extra level of "with" nesting
            // Example result: with(sc1) { with(sc0) { return (expression) } }
            var rewrittenBindings = ko.expressionRewriting.preProcessBindings(bindingsString, options),
                functionBody = "with($context){with($data||{}){return{" + rewrittenBindings + "}}}";
            return new Function("$context", "$element", functionBody);
        }
    })();
    
    ko.exportSymbol('bindingProvider', ko.bindingProvider);
    (function () {
        ko.bindingHandlers = {};
    
        // The following element types will not be recursed into during binding.
        var bindingDoesNotRecurseIntoElementTypes = {
            // Don't want bindings that operate on text nodes to mutate <script> and <textarea> contents,
            // because it's unexpected and a potential XSS issue.
            // Also bindings should not operate on <template> elements since this breaks in Internet Explorer
            // and because such elements' contents are always intended to be bound in a different context
            // from where they appear in the document.
            'script': true,
            'textarea': true,
            'template': true
        };
    
        // Use an overridable method for retrieving binding handlers so that a plugins may support dynamically created handlers
        ko['getBindingHandler'] = function(bindingKey) {
            return ko.bindingHandlers[bindingKey];
        };
    
        // The ko.bindingContext constructor is only called directly to create the root context. For child
        // contexts, use bindingContext.createChildContext or bindingContext.extend.
        ko.bindingContext = function(dataItemOrAccessor, parentContext, dataItemAlias, extendCallback, options) {
    
            // The binding context object includes static properties for the current, parent, and root view models.
            // If a view model is actually stored in an observable, the corresponding binding context object, and
            // any child contexts, must be updated when the view model is changed.
            function updateContext() {
                // Most of the time, the context will directly get a view model object, but if a function is given,
                // we call the function to retrieve the view model. If the function accesses any observables or returns
                // an observable, the dependency is tracked, and those observables can later cause the binding
                // context to be updated.
                var dataItemOrObservable = isFunc ? dataItemOrAccessor() : dataItemOrAccessor,
                    dataItem = ko.utils.unwrapObservable(dataItemOrObservable);
    
                if (parentContext) {
                    // When a "parent" context is given, register a dependency on the parent context. Thus whenever the
                    // parent context is updated, this context will also be updated.
                    if (parentContext._subscribable)
                        parentContext._subscribable();
    
                    // Copy $root and any custom properties from the parent context
                    ko.utils.extend(self, parentContext);
    
                    // Because the above copy overwrites our own properties, we need to reset them.
                    self._subscribable = subscribable;
                } else {
                    self['$parents'] = [];
                    self['$root'] = dataItem;
    
                    // Export 'ko' in the binding context so it will be available in bindings and templates
                    // even if 'ko' isn't exported as a global, such as when using an AMD loader.
                    // See https://github.com/SteveSanderson/knockout/issues/490
                    self['ko'] = ko;
                }
                self['$rawData'] = dataItemOrObservable;
                self['$data'] = dataItem;
                if (dataItemAlias)
                    self[dataItemAlias] = dataItem;
    
                // The extendCallback function is provided when creating a child context or extending a context.
                // It handles the specific actions needed to finish setting up the binding context. Actions in this
                // function could also add dependencies to this binding context.
                if (extendCallback)
                    extendCallback(self, parentContext, dataItem);
    
                return self['$data'];
            }
            function disposeWhen() {
                return nodes && !ko.utils.anyDomNodeIsAttachedToDocument(nodes);
            }
    
            var self = this,
                isFunc = typeof(dataItemOrAccessor) == "function" && !ko.isObservable(dataItemOrAccessor),
                nodes,
                subscribable;
    
            if (options && options['exportDependencies']) {
                // The "exportDependencies" option means that the calling code will track any dependencies and re-create
                // the binding context when they change.
                updateContext();
            } else {
                subscribable = ko.dependentObservable(updateContext, null, { disposeWhen: disposeWhen, disposeWhenNodeIsRemoved: true });
    
                // At this point, the binding context has been initialized, and the "subscribable" computed observable is
                // subscribed to any observables that were accessed in the process. If there is nothing to track, the
                // computed will be inactive, and we can safely throw it away. If it's active, the computed is stored in
                // the context object.
                if (subscribable.isActive()) {
                    self._subscribable = subscribable;
    
                    // Always notify because even if the model ($data) hasn't changed, other context properties might have changed
                    subscribable['equalityComparer'] = null;
    
                    // We need to be able to dispose of this computed observable when it's no longer needed. This would be
                    // easy if we had a single node to watch, but binding contexts can be used by many different nodes, and
                    // we cannot assume that those nodes have any relation to each other. So instead we track any node that
                    // the context is attached to, and dispose the computed when all of those nodes have been cleaned.
    
                    // Add properties to *subscribable* instead of *self* because any properties added to *self* may be overwritten on updates
                    nodes = [];
                    subscribable._addNode = function(node) {
                        nodes.push(node);
                        ko.utils.domNodeDisposal.addDisposeCallback(node, function(node) {
                            ko.utils.arrayRemoveItem(nodes, node);
                            if (!nodes.length) {
                                subscribable.dispose();
                                self._subscribable = subscribable = undefined;
                            }
                        });
                    };
                }
            }
        }
    
        // Extend the binding context hierarchy with a new view model object. If the parent context is watching
        // any observables, the new child context will automatically get a dependency on the parent context.
        // But this does not mean that the $data value of the child context will also get updated. If the child
        // view model also depends on the parent view model, you must provide a function that returns the correct
        // view model on each update.
        ko.bindingContext.prototype['createChildContext'] = function (dataItemOrAccessor, dataItemAlias, extendCallback, options) {
            return new ko.bindingContext(dataItemOrAccessor, this, dataItemAlias, function(self, parentContext) {
                // Extend the context hierarchy by setting the appropriate pointers
                self['$parentContext'] = parentContext;
                self['$parent'] = parentContext['$data'];
                self['$parents'] = (parentContext['$parents'] || []).slice(0);
                self['$parents'].unshift(self['$parent']);
                if (extendCallback)
                    extendCallback(self);
            }, options);
        };
    
        // Extend the binding context with new custom properties. This doesn't change the context hierarchy.
        // Similarly to "child" contexts, provide a function here to make sure that the correct values are set
        // when an observable view model is updated.
        ko.bindingContext.prototype['extend'] = function(properties) {
            // If the parent context references an observable view model, "_subscribable" will always be the
            // latest view model object. If not, "_subscribable" isn't set, and we can use the static "$data" value.
            return new ko.bindingContext(this._subscribable || this['$data'], this, null, function(self, parentContext) {
                // This "child" context doesn't directly track a parent observable view model,
                // so we need to manually set the $rawData value to match the parent.
                self['$rawData'] = parentContext['$rawData'];
                ko.utils.extend(self, typeof(properties) == "function" ? properties() : properties);
            });
        };
    
        ko.bindingContext.prototype.createStaticChildContext = function (dataItemOrAccessor, dataItemAlias) {
            return this['createChildContext'](dataItemOrAccessor, dataItemAlias, null, { "exportDependencies": true });
        };
    
        // Returns the valueAccesor function for a binding value
        function makeValueAccessor(value) {
            return function() {
                return value;
            };
        }
    
        // Returns the value of a valueAccessor function
        function evaluateValueAccessor(valueAccessor) {
            return valueAccessor();
        }
    
        // Given a function that returns bindings, create and return a new object that contains
        // binding value-accessors functions. Each accessor function calls the original function
        // so that it always gets the latest value and all dependencies are captured. This is used
        // by ko.applyBindingsToNode and getBindingsAndMakeAccessors.
        function makeAccessorsFromFunction(callback) {
            return ko.utils.objectMap(ko.dependencyDetection.ignore(callback), function(value, key) {
                return function() {
                    return callback()[key];
                };
            });
        }
    
        // Given a bindings function or object, create and return a new object that contains
        // binding value-accessors functions. This is used by ko.applyBindingsToNode.
        function makeBindingAccessors(bindings, context, node) {
            if (typeof bindings === 'function') {
                return makeAccessorsFromFunction(bindings.bind(null, context, node));
            } else {
                return ko.utils.objectMap(bindings, makeValueAccessor);
            }
        }
    
        // This function is used if the binding provider doesn't include a getBindingAccessors function.
        // It must be called with 'this' set to the provider instance.
        function getBindingsAndMakeAccessors(node, context) {
            return makeAccessorsFromFunction(this['getBindings'].bind(this, node, context));
        }
    
        function validateThatBindingIsAllowedForVirtualElements(bindingName) {
            var validator = ko.virtualElements.allowedBindings[bindingName];
            if (!validator)
                throw new Error("The binding '" + bindingName + "' cannot be used with virtual elements")
        }
    
        function applyBindingsToDescendantsInternal (bindingContext, elementOrVirtualElement, bindingContextsMayDifferFromDomParentElement) {
            var currentChild,
                nextInQueue = ko.virtualElements.firstChild(elementOrVirtualElement),
                provider = ko.bindingProvider['instance'],
                preprocessNode = provider['preprocessNode'];
    
            // Preprocessing allows a binding provider to mutate a node before bindings are applied to it. For example it's
            // possible to insert new siblings after it, and/or replace the node with a different one. This can be used to
            // implement custom binding syntaxes, such as {{ value }} for string interpolation, or custom element types that
            // trigger insertion of <template> contents at that point in the document.
            if (preprocessNode) {
                while (currentChild = nextInQueue) {
                    nextInQueue = ko.virtualElements.nextSibling(currentChild);
                    preprocessNode.call(provider, currentChild);
                }
                // Reset nextInQueue for the next loop
                nextInQueue = ko.virtualElements.firstChild(elementOrVirtualElement);
            }
    
            while (currentChild = nextInQueue) {
                // Keep a record of the next child *before* applying bindings, in case the binding removes the current child from its position
                nextInQueue = ko.virtualElements.nextSibling(currentChild);
                applyBindingsToNodeAndDescendantsInternal(bindingContext, currentChild, bindingContextsMayDifferFromDomParentElement);
            }
        }
    
        function applyBindingsToNodeAndDescendantsInternal (bindingContext, nodeVerified, bindingContextMayDifferFromDomParentElement) {
            var shouldBindDescendants = true;
    
            // Perf optimisation: Apply bindings only if...
            // (1) We need to store the binding context on this node (because it may differ from the DOM parent node's binding context)
            //     Note that we can't store binding contexts on non-elements (e.g., text nodes), as IE doesn't allow expando properties for those
            // (2) It might have bindings (e.g., it has a data-bind attribute, or it's a marker for a containerless template)
            var isElement = (nodeVerified.nodeType === 1);
            if (isElement) // Workaround IE <= 8 HTML parsing weirdness
                ko.virtualElements.normaliseVirtualElementDomStructure(nodeVerified);
    
            var shouldApplyBindings = (isElement && bindingContextMayDifferFromDomParentElement)             // Case (1)
                                   || ko.bindingProvider['instance']['nodeHasBindings'](nodeVerified);       // Case (2)
            if (shouldApplyBindings)
                shouldBindDescendants = applyBindingsToNodeInternal(nodeVerified, null, bindingContext, bindingContextMayDifferFromDomParentElement)['shouldBindDescendants'];
    
            if (shouldBindDescendants && !bindingDoesNotRecurseIntoElementTypes[ko.utils.tagNameLower(nodeVerified)]) {
                // We're recursing automatically into (real or virtual) child nodes without changing binding contexts. So,
                //  * For children of a *real* element, the binding context is certainly the same as on their DOM .parentNode,
                //    hence bindingContextsMayDifferFromDomParentElement is false
                //  * For children of a *virtual* element, we can't be sure. Evaluating .parentNode on those children may
                //    skip over any number of intermediate virtual elements, any of which might define a custom binding context,
                //    hence bindingContextsMayDifferFromDomParentElement is true
                applyBindingsToDescendantsInternal(bindingContext, nodeVerified, /* bindingContextsMayDifferFromDomParentElement: */ !isElement);
            }
        }
    
        var boundElementDomDataKey = ko.utils.domData.nextKey();
    
    
        function topologicalSortBindings(bindings) {
            // Depth-first sort
            var result = [],                // The list of key/handler pairs that we will return
                bindingsConsidered = {},    // A temporary record of which bindings are already in 'result'
                cyclicDependencyStack = []; // Keeps track of a depth-search so that, if there's a cycle, we know which bindings caused it
            ko.utils.objectForEach(bindings, function pushBinding(bindingKey) {
                if (!bindingsConsidered[bindingKey]) {
                    var binding = ko['getBindingHandler'](bindingKey);
                    if (binding) {
                        // First add dependencies (if any) of the current binding
                        if (binding['after']) {
                            cyclicDependencyStack.push(bindingKey);
                            ko.utils.arrayForEach(binding['after'], function(bindingDependencyKey) {
                                if (bindings[bindingDependencyKey]) {
                                    if (ko.utils.arrayIndexOf(cyclicDependencyStack, bindingDependencyKey) !== -1) {
                                        throw Error("Cannot combine the following bindings, because they have a cyclic dependency: " + cyclicDependencyStack.join(", "));
                                    } else {
                                        pushBinding(bindingDependencyKey);
                                    }
                                }
                            });
                            cyclicDependencyStack.length--;
                        }
                        // Next add the current binding
                        result.push({ key: bindingKey, handler: binding });
                    }
                    bindingsConsidered[bindingKey] = true;
                }
            });
    
            return result;
        }
    
        function applyBindingsToNodeInternal(node, sourceBindings, bindingContext, bindingContextMayDifferFromDomParentElement) {
            // Prevent multiple applyBindings calls for the same node, except when a binding value is specified
            var alreadyBound = ko.utils.domData.get(node, boundElementDomDataKey);
            if (!sourceBindings) {
                if (alreadyBound) {
                    throw Error("You cannot apply bindings multiple times to the same element.");
                }
                ko.utils.domData.set(node, boundElementDomDataKey, true);
            }
    
            // Optimization: Don't store the binding context on this node if it's definitely the same as on node.parentNode, because
            // we can easily recover it just by scanning up the node's ancestors in the DOM
            // (note: here, parent node means "real DOM parent" not "virtual parent", as there's no O(1) way to find the virtual parent)
            if (!alreadyBound && bindingContextMayDifferFromDomParentElement)
                ko.storedBindingContextForNode(node, bindingContext);
    
            // Use bindings if given, otherwise fall back on asking the bindings provider to give us some bindings
            var bindings;
            if (sourceBindings && typeof sourceBindings !== 'function') {
                bindings = sourceBindings;
            } else {
                var provider = ko.bindingProvider['instance'],
                    getBindings = provider['getBindingAccessors'] || getBindingsAndMakeAccessors;
    
                // Get the binding from the provider within a computed observable so that we can update the bindings whenever
                // the binding context is updated or if the binding provider accesses observables.
                var bindingsUpdater = ko.dependentObservable(
                    function() {
                        bindings = sourceBindings ? sourceBindings(bindingContext, node) : getBindings.call(provider, node, bindingContext);
                        // Register a dependency on the binding context to support observable view models.
                        if (bindings && bindingContext._subscribable)
                            bindingContext._subscribable();
                        return bindings;
                    },
                    null, { disposeWhenNodeIsRemoved: node }
                );
    
                if (!bindings || !bindingsUpdater.isActive())
                    bindingsUpdater = null;
            }
    
            var bindingHandlerThatControlsDescendantBindings;
            if (bindings) {
                // Return the value accessor for a given binding. When bindings are static (won't be updated because of a binding
                // context update), just return the value accessor from the binding. Otherwise, return a function that always gets
                // the latest binding value and registers a dependency on the binding updater.
                var getValueAccessor = bindingsUpdater
                    ? function(bindingKey) {
                        return function() {
                            return evaluateValueAccessor(bindingsUpdater()[bindingKey]);
                        };
                    } : function(bindingKey) {
                        return bindings[bindingKey];
                    };
    
                // Use of allBindings as a function is maintained for backwards compatibility, but its use is deprecated
                function allBindings() {
                    return ko.utils.objectMap(bindingsUpdater ? bindingsUpdater() : bindings, evaluateValueAccessor);
                }
                // The following is the 3.x allBindings API
                allBindings['get'] = function(key) {
                    return bindings[key] && evaluateValueAccessor(getValueAccessor(key));
                };
                allBindings['has'] = function(key) {
                    return key in bindings;
                };
    
                // First put the bindings into the right order
                var orderedBindings = topologicalSortBindings(bindings);
    
                // Go through the sorted bindings, calling init and update for each
                ko.utils.arrayForEach(orderedBindings, function(bindingKeyAndHandler) {
                    // Note that topologicalSortBindings has already filtered out any nonexistent binding handlers,
                    // so bindingKeyAndHandler.handler will always be nonnull.
                    var handlerInitFn = bindingKeyAndHandler.handler["init"],
                        handlerUpdateFn = bindingKeyAndHandler.handler["update"],
                        bindingKey = bindingKeyAndHandler.key;
    
                    if (node.nodeType === 8) {
                        validateThatBindingIsAllowedForVirtualElements(bindingKey);
                    }
    
                    try {
                        // Run init, ignoring any dependencies
                        if (typeof handlerInitFn == "function") {
                            ko.dependencyDetection.ignore(function() {
                                var initResult = handlerInitFn(node, getValueAccessor(bindingKey), allBindings, bindingContext['$data'], bindingContext);
    
                                // If this binding handler claims to control descendant bindings, make a note of this
                                if (initResult && initResult['controlsDescendantBindings']) {
                                    if (bindingHandlerThatControlsDescendantBindings !== undefined)
                                        throw new Error("Multiple bindings (" + bindingHandlerThatControlsDescendantBindings + " and " + bindingKey + ") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");
                                    bindingHandlerThatControlsDescendantBindings = bindingKey;
                                }
                            });
                        }
    
                        // Run update in its own computed wrapper
                        if (typeof handlerUpdateFn == "function") {
                            ko.dependentObservable(
                                function() {
                                    handlerUpdateFn(node, getValueAccessor(bindingKey), allBindings, bindingContext['$data'], bindingContext);
                                },
                                null,
                                { disposeWhenNodeIsRemoved: node }
                            );
                        }
                    } catch (ex) {
                        ex.message = "Unable to process binding \"" + bindingKey + ": " + bindings[bindingKey] + "\"\nMessage: " + ex.message;
                        throw ex;
                    }
                });
            }
    
            return {
                'shouldBindDescendants': bindingHandlerThatControlsDescendantBindings === undefined
            };
        };
    
        var storedBindingContextDomDataKey = ko.utils.domData.nextKey();
        ko.storedBindingContextForNode = function (node, bindingContext) {
            if (arguments.length == 2) {
                ko.utils.domData.set(node, storedBindingContextDomDataKey, bindingContext);
                if (bindingContext._subscribable)
                    bindingContext._subscribable._addNode(node);
            } else {
                return ko.utils.domData.get(node, storedBindingContextDomDataKey);
            }
        }
    
        function getBindingContext(viewModelOrBindingContext) {
            return viewModelOrBindingContext && (viewModelOrBindingContext instanceof ko.bindingContext)
                ? viewModelOrBindingContext
                : new ko.bindingContext(viewModelOrBindingContext);
        }
    
        ko.applyBindingAccessorsToNode = function (node, bindings, viewModelOrBindingContext) {
            if (node.nodeType === 1) // If it's an element, workaround IE <= 8 HTML parsing weirdness
                ko.virtualElements.normaliseVirtualElementDomStructure(node);
            return applyBindingsToNodeInternal(node, bindings, getBindingContext(viewModelOrBindingContext), true);
        };
    
        ko.applyBindingsToNode = function (node, bindings, viewModelOrBindingContext) {
            var context = getBindingContext(viewModelOrBindingContext);
            return ko.applyBindingAccessorsToNode(node, makeBindingAccessors(bindings, context, node), context);
        };
    
        ko.applyBindingsToDescendants = function(viewModelOrBindingContext, rootNode) {
            if (rootNode.nodeType === 1 || rootNode.nodeType === 8)
                applyBindingsToDescendantsInternal(getBindingContext(viewModelOrBindingContext), rootNode, true);
        };
    
        ko.applyBindings = function (viewModelOrBindingContext, rootNode) {
            // If jQuery is loaded after Knockout, we won't initially have access to it. So save it here.
            if (!jQueryInstance && window['jQuery']) {
                jQueryInstance = window['jQuery'];
            }
    
            if (rootNode && (rootNode.nodeType !== 1) && (rootNode.nodeType !== 8))
                throw new Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");
            rootNode = rootNode || window.document.body; // Make "rootNode" parameter optional
    
            applyBindingsToNodeAndDescendantsInternal(getBindingContext(viewModelOrBindingContext), rootNode, true);
        };
    
        // Retrieving binding context from arbitrary nodes
        ko.contextFor = function(node) {
            // We can only do something meaningful for elements and comment nodes (in particular, not text nodes, as IE can't store domdata for them)
            switch (node.nodeType) {
                case 1:
                case 8:
                    var context = ko.storedBindingContextForNode(node);
                    if (context) return context;
                    if (node.parentNode) return ko.contextFor(node.parentNode);
                    break;
            }
            return undefined;
        };
        ko.dataFor = function(node) {
            var context = ko.contextFor(node);
            return context ? context['$data'] : undefined;
        };
    
        ko.exportSymbol('bindingHandlers', ko.bindingHandlers);
        ko.exportSymbol('applyBindings', ko.applyBindings);
        ko.exportSymbol('applyBindingsToDescendants', ko.applyBindingsToDescendants);
        ko.exportSymbol('applyBindingAccessorsToNode', ko.applyBindingAccessorsToNode);
        ko.exportSymbol('applyBindingsToNode', ko.applyBindingsToNode);
        ko.exportSymbol('contextFor', ko.contextFor);
        ko.exportSymbol('dataFor', ko.dataFor);
    })();
    (function(undefined) {
        var loadingSubscribablesCache = {}, // Tracks component loads that are currently in flight
            loadedDefinitionsCache = {};    // Tracks component loads that have already completed
    
        ko.components = {
            get: function(componentName, callback) {
                var cachedDefinition = getObjectOwnProperty(loadedDefinitionsCache, componentName);
                if (cachedDefinition) {
                    // It's already loaded and cached. Reuse the same definition object.
                    // Note that for API consistency, even cache hits complete asynchronously by default.
                    // You can bypass this by putting synchronous:true on your component config.
                    if (cachedDefinition.isSynchronousComponent) {
                        ko.dependencyDetection.ignore(function() { // See comment in loaderRegistryBehaviors.js for reasoning
                            callback(cachedDefinition.definition);
                        });
                    } else {
                        ko.tasks.schedule(function() { callback(cachedDefinition.definition); });
                    }
                } else {
                    // Join the loading process that is already underway, or start a new one.
                    loadComponentAndNotify(componentName, callback);
                }
            },
    
            clearCachedDefinition: function(componentName) {
                delete loadedDefinitionsCache[componentName];
            },
    
            _getFirstResultFromLoaders: getFirstResultFromLoaders
        };
    
        function getObjectOwnProperty(obj, propName) {
            return obj.hasOwnProperty(propName) ? obj[propName] : undefined;
        }
    
        function loadComponentAndNotify(componentName, callback) {
            var subscribable = getObjectOwnProperty(loadingSubscribablesCache, componentName),
                completedAsync;
            if (!subscribable) {
                // It's not started loading yet. Start loading, and when it's done, move it to loadedDefinitionsCache.
                subscribable = loadingSubscribablesCache[componentName] = new ko.subscribable();
                subscribable.subscribe(callback);
    
                beginLoadingComponent(componentName, function(definition, config) {
                    var isSynchronousComponent = !!(config && config['synchronous']);
                    loadedDefinitionsCache[componentName] = { definition: definition, isSynchronousComponent: isSynchronousComponent };
                    delete loadingSubscribablesCache[componentName];
    
                    // For API consistency, all loads complete asynchronously. However we want to avoid
                    // adding an extra task schedule if it's unnecessary (i.e., the completion is already
                    // async).
                    //
                    // You can bypass the 'always asynchronous' feature by putting the synchronous:true
                    // flag on your component configuration when you register it.
                    if (completedAsync || isSynchronousComponent) {
                        // Note that notifySubscribers ignores any dependencies read within the callback.
                        // See comment in loaderRegistryBehaviors.js for reasoning
                        subscribable['notifySubscribers'](definition);
                    } else {
                        ko.tasks.schedule(function() {
                            subscribable['notifySubscribers'](definition);
                        });
                    }
                });
                completedAsync = true;
            } else {
                subscribable.subscribe(callback);
            }
        }
    
        function beginLoadingComponent(componentName, callback) {
            getFirstResultFromLoaders('getConfig', [componentName], function(config) {
                if (config) {
                    // We have a config, so now load its definition
                    getFirstResultFromLoaders('loadComponent', [componentName, config], function(definition) {
                        callback(definition, config);
                    });
                } else {
                    // The component has no config - it's unknown to all the loaders.
                    // Note that this is not an error (e.g., a module loading error) - that would abort the
                    // process and this callback would not run. For this callback to run, all loaders must
                    // have confirmed they don't know about this component.
                    callback(null, null);
                }
            });
        }
    
        function getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders) {
            // On the first call in the stack, start with the full set of loaders
            if (!candidateLoaders) {
                candidateLoaders = ko.components['loaders'].slice(0); // Use a copy, because we'll be mutating this array
            }
    
            // Try the next candidate
            var currentCandidateLoader = candidateLoaders.shift();
            if (currentCandidateLoader) {
                var methodInstance = currentCandidateLoader[methodName];
                if (methodInstance) {
                    var wasAborted = false,
                        synchronousReturnValue = methodInstance.apply(currentCandidateLoader, argsExceptCallback.concat(function(result) {
                            if (wasAborted) {
                                callback(null);
                            } else if (result !== null) {
                                // This candidate returned a value. Use it.
                                callback(result);
                            } else {
                                // Try the next candidate
                                getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders);
                            }
                        }));
    
                    // Currently, loaders may not return anything synchronously. This leaves open the possibility
                    // that we'll extend the API to support synchronous return values in the future. It won't be
                    // a breaking change, because currently no loader is allowed to return anything except undefined.
                    if (synchronousReturnValue !== undefined) {
                        wasAborted = true;
    
                        // Method to suppress exceptions will remain undocumented. This is only to keep
                        // KO's specs running tidily, since we can observe the loading got aborted without
                        // having exceptions cluttering up the console too.
                        if (!currentCandidateLoader['suppressLoaderExceptions']) {
                            throw new Error('Component loaders must supply values by invoking the callback, not by returning values synchronously.');
                        }
                    }
                } else {
                    // This candidate doesn't have the relevant handler. Synchronously move on to the next one.
                    getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders);
                }
            } else {
                // No candidates returned a value
                callback(null);
            }
        }
    
        // Reference the loaders via string name so it's possible for developers
        // to replace the whole array by assigning to ko.components.loaders
        ko.components['loaders'] = [];
    
        ko.exportSymbol('components', ko.components);
        ko.exportSymbol('components.get', ko.components.get);
        ko.exportSymbol('components.clearCachedDefinition', ko.components.clearCachedDefinition);
    })();
    (function(undefined) {
    
        // The default loader is responsible for two things:
        // 1. Maintaining the default in-memory registry of component configuration objects
        //    (i.e., the thing you're writing to when you call ko.components.register(someName, ...))
        // 2. Answering requests for components by fetching configuration objects
        //    from that default in-memory registry and resolving them into standard
        //    component definition objects (of the form { createViewModel: ..., template: ... })
        // Custom loaders may override either of these facilities, i.e.,
        // 1. To supply configuration objects from some other source (e.g., conventions)
        // 2. Or, to resolve configuration objects by loading viewmodels/templates via arbitrary logic.
    
        var defaultConfigRegistry = {};
    
        ko.components.register = function(componentName, config) {
            if (!config) {
                throw new Error('Invalid configuration for ' + componentName);
            }
    
            if (ko.components.isRegistered(componentName)) {
                throw new Error('Component ' + componentName + ' is already registered');
            }
    
            defaultConfigRegistry[componentName] = config;
        };
    
        ko.components.isRegistered = function(componentName) {
            return defaultConfigRegistry.hasOwnProperty(componentName);
        };
    
        ko.components.unregister = function(componentName) {
            delete defaultConfigRegistry[componentName];
            ko.components.clearCachedDefinition(componentName);
        };
    
        ko.components.defaultLoader = {
            'getConfig': function(componentName, callback) {
                var result = defaultConfigRegistry.hasOwnProperty(componentName)
                    ? defaultConfigRegistry[componentName]
                    : null;
                callback(result);
            },
    
            'loadComponent': function(componentName, config, callback) {
                var errorCallback = makeErrorCallback(componentName);
                possiblyGetConfigFromAmd(errorCallback, config, function(loadedConfig) {
                    resolveConfig(componentName, errorCallback, loadedConfig, callback);
                });
            },
    
            'loadTemplate': function(componentName, templateConfig, callback) {
                resolveTemplate(makeErrorCallback(componentName), templateConfig, callback);
            },
    
            'loadViewModel': function(componentName, viewModelConfig, callback) {
                resolveViewModel(makeErrorCallback(componentName), viewModelConfig, callback);
            }
        };
    
        var createViewModelKey = 'createViewModel';
    
        // Takes a config object of the form { template: ..., viewModel: ... }, and asynchronously convert it
        // into the standard component definition format:
        //    { template: <ArrayOfDomNodes>, createViewModel: function(params, componentInfo) { ... } }.
        // Since both template and viewModel may need to be resolved asynchronously, both tasks are performed
        // in parallel, and the results joined when both are ready. We don't depend on any promises infrastructure,
        // so this is implemented manually below.
        function resolveConfig(componentName, errorCallback, config, callback) {
            var result = {},
                makeCallBackWhenZero = 2,
                tryIssueCallback = function() {
                    if (--makeCallBackWhenZero === 0) {
                        callback(result);
                    }
                },
                templateConfig = config['template'],
                viewModelConfig = config['viewModel'];
    
            if (templateConfig) {
                possiblyGetConfigFromAmd(errorCallback, templateConfig, function(loadedConfig) {
                    ko.components._getFirstResultFromLoaders('loadTemplate', [componentName, loadedConfig], function(resolvedTemplate) {
                        result['template'] = resolvedTemplate;
                        tryIssueCallback();
                    });
                });
            } else {
                tryIssueCallback();
            }
    
            if (viewModelConfig) {
                possiblyGetConfigFromAmd(errorCallback, viewModelConfig, function(loadedConfig) {
                    ko.components._getFirstResultFromLoaders('loadViewModel', [componentName, loadedConfig], function(resolvedViewModel) {
                        result[createViewModelKey] = resolvedViewModel;
                        tryIssueCallback();
                    });
                });
            } else {
                tryIssueCallback();
            }
        }
    
        function resolveTemplate(errorCallback, templateConfig, callback) {
            if (typeof templateConfig === 'string') {
                // Markup - parse it
                callback(ko.utils.parseHtmlFragment(templateConfig));
            } else if (templateConfig instanceof Array) {
                // Assume already an array of DOM nodes - pass through unchanged
                callback(templateConfig);
            } else if (isDocumentFragment(templateConfig)) {
                // Document fragment - use its child nodes
                callback(ko.utils.makeArray(templateConfig.childNodes));
            } else if (templateConfig['element']) {
                var element = templateConfig['element'];
                if (isDomElement(element)) {
                    // Element instance - copy its child nodes
                    callback(cloneNodesFromTemplateSourceElement(element));
                } else if (typeof element === 'string') {
                    // Element ID - find it, then copy its child nodes
                    var elemInstance = document.getElementById(element);
                    if (elemInstance) {
                        callback(cloneNodesFromTemplateSourceElement(elemInstance));
                    } else {
                        errorCallback('Cannot find element with ID ' + element);
                    }
                } else {
                    errorCallback('Unknown element type: ' + element);
                }
            } else {
                errorCallback('Unknown template value: ' + templateConfig);
            }
        }
    
        function resolveViewModel(errorCallback, viewModelConfig, callback) {
            if (typeof viewModelConfig === 'function') {
                // Constructor - convert to standard factory function format
                // By design, this does *not* supply componentInfo to the constructor, as the intent is that
                // componentInfo contains non-viewmodel data (e.g., the component's element) that should only
                // be used in factory functions, not viewmodel constructors.
                callback(function (params /*, componentInfo */) {
                    return new viewModelConfig(params);
                });
            } else if (typeof viewModelConfig[createViewModelKey] === 'function') {
                // Already a factory function - use it as-is
                callback(viewModelConfig[createViewModelKey]);
            } else if ('instance' in viewModelConfig) {
                // Fixed object instance - promote to createViewModel format for API consistency
                var fixedInstance = viewModelConfig['instance'];
                callback(function (params, componentInfo) {
                    return fixedInstance;
                });
            } else if ('viewModel' in viewModelConfig) {
                // Resolved AMD module whose value is of the form { viewModel: ... }
                resolveViewModel(errorCallback, viewModelConfig['viewModel'], callback);
            } else {
                errorCallback('Unknown viewModel value: ' + viewModelConfig);
            }
        }
    
        function cloneNodesFromTemplateSourceElement(elemInstance) {
            switch (ko.utils.tagNameLower(elemInstance)) {
                case 'script':
                    return ko.utils.parseHtmlFragment(elemInstance.text);
                case 'textarea':
                    return ko.utils.parseHtmlFragment(elemInstance.value);
                case 'template':
                    // For browsers with proper <template> element support (i.e., where the .content property
                    // gives a document fragment), use that document fragment.
                    if (isDocumentFragment(elemInstance.content)) {
                        return ko.utils.cloneNodes(elemInstance.content.childNodes);
                    }
            }
    
            // Regular elements such as <div>, and <template> elements on old browsers that don't really
            // understand <template> and just treat it as a regular container
            return ko.utils.cloneNodes(elemInstance.childNodes);
        }
    
        function isDomElement(obj) {
            if (window['HTMLElement']) {
                return obj instanceof HTMLElement;
            } else {
                return obj && obj.tagName && obj.nodeType === 1;
            }
        }
    
        function isDocumentFragment(obj) {
            if (window['DocumentFragment']) {
                return obj instanceof DocumentFragment;
            } else {
                return obj && obj.nodeType === 11;
            }
        }
    
        function possiblyGetConfigFromAmd(errorCallback, config, callback) {
            if (typeof config['require'] === 'string') {
                // The config is the value of an AMD module
                if (amdRequire || window['require']) {
                    (amdRequire || window['require'])([config['require']], callback);
                } else {
                    errorCallback('Uses require, but no AMD loader is present');
                }
            } else {
                callback(config);
            }
        }
    
        function makeErrorCallback(componentName) {
            return function (message) {
                throw new Error('Component \'' + componentName + '\': ' + message);
            };
        }
    
        ko.exportSymbol('components.register', ko.components.register);
        ko.exportSymbol('components.isRegistered', ko.components.isRegistered);
        ko.exportSymbol('components.unregister', ko.components.unregister);
    
        // Expose the default loader so that developers can directly ask it for configuration
        // or to resolve configuration
        ko.exportSymbol('components.defaultLoader', ko.components.defaultLoader);
    
        // By default, the default loader is the only registered component loader
        ko.components['loaders'].push(ko.components.defaultLoader);
    
        // Privately expose the underlying config registry for use in old-IE shim
        ko.components._allRegisteredComponents = defaultConfigRegistry;
    })();
    (function (undefined) {
        // Overridable API for determining which component name applies to a given node. By overriding this,
        // you can for example map specific tagNames to components that are not preregistered.
        ko.components['getComponentNameForNode'] = function(node) {
            var tagNameLower = ko.utils.tagNameLower(node);
            if (ko.components.isRegistered(tagNameLower)) {
                // Try to determine that this node can be considered a *custom* element; see https://github.com/knockout/knockout/issues/1603
                if (tagNameLower.indexOf('-') != -1 || ('' + node) == "[object HTMLUnknownElement]" || (ko.utils.ieVersion <= 8 && node.tagName === tagNameLower)) {
                    return tagNameLower;
                }
            }
        };
    
        ko.components.addBindingsForCustomElement = function(allBindings, node, bindingContext, valueAccessors) {
            // Determine if it's really a custom element matching a component
            if (node.nodeType === 1) {
                var componentName = ko.components['getComponentNameForNode'](node);
                if (componentName) {
                    // It does represent a component, so add a component binding for it
                    allBindings = allBindings || {};
    
                    if (allBindings['component']) {
                        // Avoid silently overwriting some other 'component' binding that may already be on the element
                        throw new Error('Cannot use the "component" binding on a custom element matching a component');
                    }
    
                    var componentBindingValue = { 'name': componentName, 'params': getComponentParamsFromCustomElement(node, bindingContext) };
    
                    allBindings['component'] = valueAccessors
                        ? function() { return componentBindingValue; }
                        : componentBindingValue;
                }
            }
    
            return allBindings;
        }
    
        var nativeBindingProviderInstance = new ko.bindingProvider();
    
        function getComponentParamsFromCustomElement(elem, bindingContext) {
            var paramsAttribute = elem.getAttribute('params');
    
            if (paramsAttribute) {
                var params = nativeBindingProviderInstance['parseBindingsString'](paramsAttribute, bindingContext, elem, { 'valueAccessors': true, 'bindingParams': true }),
                    rawParamComputedValues = ko.utils.objectMap(params, function(paramValue, paramName) {
                        return ko.computed(paramValue, null, { disposeWhenNodeIsRemoved: elem });
                    }),
                    result = ko.utils.objectMap(rawParamComputedValues, function(paramValueComputed, paramName) {
                        var paramValue = paramValueComputed.peek();
                        // Does the evaluation of the parameter value unwrap any observables?
                        if (!paramValueComputed.isActive()) {
                            // No it doesn't, so there's no need for any computed wrapper. Just pass through the supplied value directly.
                            // Example: "someVal: firstName, age: 123" (whether or not firstName is an observable/computed)
                            return paramValue;
                        } else {
                            // Yes it does. Supply a computed property that unwraps both the outer (binding expression)
                            // level of observability, and any inner (resulting model value) level of observability.
                            // This means the component doesn't have to worry about multiple unwrapping. If the value is a
                            // writable observable, the computed will also be writable and pass the value on to the observable.
                            return ko.computed({
                                'read': function() {
                                    return ko.utils.unwrapObservable(paramValueComputed());
                                },
                                'write': ko.isWriteableObservable(paramValue) && function(value) {
                                    paramValueComputed()(value);
                                },
                                disposeWhenNodeIsRemoved: elem
                            });
                        }
                    });
    
                // Give access to the raw computeds, as long as that wouldn't overwrite any custom param also called '$raw'
                // This is in case the developer wants to react to outer (binding) observability separately from inner
                // (model value) observability, or in case the model value observable has subobservables.
                if (!result.hasOwnProperty('$raw')) {
                    result['$raw'] = rawParamComputedValues;
                }
    
                return result;
            } else {
                // For consistency, absence of a "params" attribute is treated the same as the presence of
                // any empty one. Otherwise component viewmodels need special code to check whether or not
                // 'params' or 'params.$raw' is null/undefined before reading subproperties, which is annoying.
                return { '$raw': {} };
            }
        }
    
        // --------------------------------------------------------------------------------
        // Compatibility code for older (pre-HTML5) IE browsers
    
        if (ko.utils.ieVersion < 9) {
            // Whenever you preregister a component, enable it as a custom element in the current document
            ko.components['register'] = (function(originalFunction) {
                return function(componentName) {
                    document.createElement(componentName); // Allows IE<9 to parse markup containing the custom element
                    return originalFunction.apply(this, arguments);
                }
            })(ko.components['register']);
    
            // Whenever you create a document fragment, enable all preregistered component names as custom elements
            // This is needed to make innerShiv/jQuery HTML parsing correctly handle the custom elements
            document.createDocumentFragment = (function(originalFunction) {
                return function() {
                    var newDocFrag = originalFunction(),
                        allComponents = ko.components._allRegisteredComponents;
                    for (var componentName in allComponents) {
                        if (allComponents.hasOwnProperty(componentName)) {
                            newDocFrag.createElement(componentName);
                        }
                    }
                    return newDocFrag;
                };
            })(document.createDocumentFragment);
        }
    })();(function(undefined) {
    
        var componentLoadingOperationUniqueId = 0;
    
        ko.bindingHandlers['component'] = {
            'init': function(element, valueAccessor, ignored1, ignored2, bindingContext) {
                var currentViewModel,
                    currentLoadingOperationId,
                    disposeAssociatedComponentViewModel = function () {
                        var currentViewModelDispose = currentViewModel && currentViewModel['dispose'];
                        if (typeof currentViewModelDispose === 'function') {
                            currentViewModelDispose.call(currentViewModel);
                        }
                        currentViewModel = null;
                        // Any in-flight loading operation is no longer relevant, so make sure we ignore its completion
                        currentLoadingOperationId = null;
                    },
                    originalChildNodes = ko.utils.makeArray(ko.virtualElements.childNodes(element));
    
                ko.utils.domNodeDisposal.addDisposeCallback(element, disposeAssociatedComponentViewModel);
    
                ko.computed(function () {
                    var value = ko.utils.unwrapObservable(valueAccessor()),
                        componentName, componentParams;
    
                    if (typeof value === 'string') {
                        componentName = value;
                    } else {
                        componentName = ko.utils.unwrapObservable(value['name']);
                        componentParams = ko.utils.unwrapObservable(value['params']);
                    }
    
                    if (!componentName) {
                        throw new Error('No component name specified');
                    }
    
                    var loadingOperationId = currentLoadingOperationId = ++componentLoadingOperationUniqueId;
                    ko.components.get(componentName, function(componentDefinition) {
                        // If this is not the current load operation for this element, ignore it.
                        if (currentLoadingOperationId !== loadingOperationId) {
                            return;
                        }
    
                        // Clean up previous state
                        disposeAssociatedComponentViewModel();
    
                        // Instantiate and bind new component. Implicitly this cleans any old DOM nodes.
                        if (!componentDefinition) {
                            throw new Error('Unknown component \'' + componentName + '\'');
                        }
                        cloneTemplateIntoElement(componentName, componentDefinition, element);
                        var componentViewModel = createViewModel(componentDefinition, element, originalChildNodes, componentParams),
                            childBindingContext = bindingContext['createChildContext'](componentViewModel, /* dataItemAlias */ undefined, function(ctx) {
                                ctx['$component'] = componentViewModel;
                                ctx['$componentTemplateNodes'] = originalChildNodes;
                            });
                        currentViewModel = componentViewModel;
                        ko.applyBindingsToDescendants(childBindingContext, element);
                    });
                }, null, { disposeWhenNodeIsRemoved: element });
    
                return { 'controlsDescendantBindings': true };
            }
        };
    
        ko.virtualElements.allowedBindings['component'] = true;
    
        function cloneTemplateIntoElement(componentName, componentDefinition, element) {
            var template = componentDefinition['template'];
            if (!template) {
                throw new Error('Component \'' + componentName + '\' has no template');
            }
    
            var clonedNodesArray = ko.utils.cloneNodes(template);
            ko.virtualElements.setDomNodeChildren(element, clonedNodesArray);
        }
    
        function createViewModel(componentDefinition, element, originalChildNodes, componentParams) {
            var componentViewModelFactory = componentDefinition['createViewModel'];
            return componentViewModelFactory
                ? componentViewModelFactory.call(componentDefinition, componentParams, { 'element': element, 'templateNodes': originalChildNodes })
                : componentParams; // Template-only component
        }
    
    })();
    var attrHtmlToJavascriptMap = { 'class': 'className', 'for': 'htmlFor' };
    ko.bindingHandlers['attr'] = {
        'update': function(element, valueAccessor, allBindings) {
            var value = ko.utils.unwrapObservable(valueAccessor()) || {};
            ko.utils.objectForEach(value, function(attrName, attrValue) {
                attrValue = ko.utils.unwrapObservable(attrValue);
    
                // To cover cases like "attr: { checked:someProp }", we want to remove the attribute entirely
                // when someProp is a "no value"-like value (strictly null, false, or undefined)
                // (because the absence of the "checked" attr is how to mark an element as not checked, etc.)
                var toRemove = (attrValue === false) || (attrValue === null) || (attrValue === undefined);
                if (toRemove)
                    element.removeAttribute(attrName);
    
                // In IE <= 7 and IE8 Quirks Mode, you have to use the Javascript property name instead of the
                // HTML attribute name for certain attributes. IE8 Standards Mode supports the correct behavior,
                // but instead of figuring out the mode, we'll just set the attribute through the Javascript
                // property for IE <= 8.
                if (ko.utils.ieVersion <= 8 && attrName in attrHtmlToJavascriptMap) {
                    attrName = attrHtmlToJavascriptMap[attrName];
                    if (toRemove)
                        element.removeAttribute(attrName);
                    else
                        element[attrName] = attrValue;
                } else if (!toRemove) {
                    element.setAttribute(attrName, attrValue.toString());
                }
    
                // Treat "name" specially - although you can think of it as an attribute, it also needs
                // special handling on older versions of IE (https://github.com/SteveSanderson/knockout/pull/333)
                // Deliberately being case-sensitive here because XHTML would regard "Name" as a different thing
                // entirely, and there's no strong reason to allow for such casing in HTML.
                if (attrName === "name") {
                    ko.utils.setElementName(element, toRemove ? "" : attrValue.toString());
                }
            });
        }
    };
    (function() {
    
    ko.bindingHandlers['checked'] = {
        'after': ['value', 'attr'],
        'init': function (element, valueAccessor, allBindings) {
            var checkedValue = ko.pureComputed(function() {
                // Treat "value" like "checkedValue" when it is included with "checked" binding
                if (allBindings['has']('checkedValue')) {
                    return ko.utils.unwrapObservable(allBindings.get('checkedValue'));
                } else if (allBindings['has']('value')) {
                    return ko.utils.unwrapObservable(allBindings.get('value'));
                }
    
                return element.value;
            });
    
            function updateModel() {
                // This updates the model value from the view value.
                // It runs in response to DOM events (click) and changes in checkedValue.
                var isChecked = element.checked,
                    elemValue = useCheckedValue ? checkedValue() : isChecked;
    
                // When we're first setting up this computed, don't change any model state.
                if (ko.computedContext.isInitial()) {
                    return;
                }
    
                // We can ignore unchecked radio buttons, because some other radio
                // button will be getting checked, and that one can take care of updating state.
                if (isRadio && !isChecked) {
                    return;
                }
    
                var modelValue = ko.dependencyDetection.ignore(valueAccessor);
                if (valueIsArray) {
                    var writableValue = rawValueIsNonArrayObservable ? modelValue.peek() : modelValue;
                    if (oldElemValue !== elemValue) {
                        // When we're responding to the checkedValue changing, and the element is
                        // currently checked, replace the old elem value with the new elem value
                        // in the model array.
                        if (isChecked) {
                            ko.utils.addOrRemoveItem(writableValue, elemValue, true);
                            ko.utils.addOrRemoveItem(writableValue, oldElemValue, false);
                        }
    
                        oldElemValue = elemValue;
                    } else {
                        // When we're responding to the user having checked/unchecked a checkbox,
                        // add/remove the element value to the model array.
                        ko.utils.addOrRemoveItem(writableValue, elemValue, isChecked);
                    }
                    if (rawValueIsNonArrayObservable && ko.isWriteableObservable(modelValue)) {
                        modelValue(writableValue);
                    }
                } else {
                    ko.expressionRewriting.writeValueToProperty(modelValue, allBindings, 'checked', elemValue, true);
                }
            };
    
            function updateView() {
                // This updates the view value from the model value.
                // It runs in response to changes in the bound (checked) value.
                var modelValue = ko.utils.unwrapObservable(valueAccessor());
    
                if (valueIsArray) {
                    // When a checkbox is bound to an array, being checked represents its value being present in that array
                    element.checked = ko.utils.arrayIndexOf(modelValue, checkedValue()) >= 0;
                } else if (isCheckbox) {
                    // When a checkbox is bound to any other value (not an array), being checked represents the value being trueish
                    element.checked = modelValue;
                } else {
                    // For radio buttons, being checked means that the radio button's value corresponds to the model value
                    element.checked = (checkedValue() === modelValue);
                }
            };
    
            var isCheckbox = element.type == "checkbox",
                isRadio = element.type == "radio";
    
            // Only bind to check boxes and radio buttons
            if (!isCheckbox && !isRadio) {
                return;
            }
    
            var rawValue = valueAccessor(),
                valueIsArray = isCheckbox && (ko.utils.unwrapObservable(rawValue) instanceof Array),
                rawValueIsNonArrayObservable = !(valueIsArray && rawValue.push && rawValue.splice),
                oldElemValue = valueIsArray ? checkedValue() : undefined,
                useCheckedValue = isRadio || valueIsArray;
    
            // IE 6 won't allow radio buttons to be selected unless they have a name
            if (isRadio && !element.name)
                ko.bindingHandlers['uniqueName']['init'](element, function() { return true });
    
            // Set up two computeds to update the binding:
    
            // The first responds to changes in the checkedValue value and to element clicks
            ko.computed(updateModel, null, { disposeWhenNodeIsRemoved: element });
            ko.utils.registerEventHandler(element, "click", updateModel);
    
            // The second responds to changes in the model value (the one associated with the checked binding)
            ko.computed(updateView, null, { disposeWhenNodeIsRemoved: element });
    
            rawValue = undefined;
        }
    };
    ko.expressionRewriting.twoWayBindings['checked'] = true;
    
    ko.bindingHandlers['checkedValue'] = {
        'update': function (element, valueAccessor) {
            element.value = ko.utils.unwrapObservable(valueAccessor());
        }
    };
    
    })();var classesWrittenByBindingKey = '__ko__cssValue';
    ko.bindingHandlers['css'] = {
        'update': function (element, valueAccessor) {
            var value = ko.utils.unwrapObservable(valueAccessor());
            if (value !== null && typeof value == "object") {
                ko.utils.objectForEach(value, function(className, shouldHaveClass) {
                    shouldHaveClass = ko.utils.unwrapObservable(shouldHaveClass);
                    ko.utils.toggleDomNodeCssClass(element, className, shouldHaveClass);
                });
            } else {
                value = ko.utils.stringTrim(String(value || '')); // Make sure we don't try to store or set a non-string value
                ko.utils.toggleDomNodeCssClass(element, element[classesWrittenByBindingKey], false);
                element[classesWrittenByBindingKey] = value;
                ko.utils.toggleDomNodeCssClass(element, value, true);
            }
        }
    };
    ko.bindingHandlers['enable'] = {
        'update': function (element, valueAccessor) {
            var value = ko.utils.unwrapObservable(valueAccessor());
            if (value && element.disabled)
                element.removeAttribute("disabled");
            else if ((!value) && (!element.disabled))
                element.disabled = true;
        }
    };
    
    ko.bindingHandlers['disable'] = {
        'update': function (element, valueAccessor) {
            ko.bindingHandlers['enable']['update'](element, function() { return !ko.utils.unwrapObservable(valueAccessor()) });
        }
    };
    // For certain common events (currently just 'click'), allow a simplified data-binding syntax
    // e.g. click:handler instead of the usual full-length event:{click:handler}
    function makeEventHandlerShortcut(eventName) {
        ko.bindingHandlers[eventName] = {
            'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
                var newValueAccessor = function () {
                    var result = {};
                    result[eventName] = valueAccessor();
                    return result;
                };
                return ko.bindingHandlers['event']['init'].call(this, element, newValueAccessor, allBindings, viewModel, bindingContext);
            }
        }
    }
    
    ko.bindingHandlers['event'] = {
        'init' : function (element, valueAccessor, allBindings, viewModel, bindingContext) {
            var eventsToHandle = valueAccessor() || {};
            ko.utils.objectForEach(eventsToHandle, function(eventName) {
                if (typeof eventName == "string") {
                    ko.utils.registerEventHandler(element, eventName, function (event) {
                        var handlerReturnValue;
                        var handlerFunction = valueAccessor()[eventName];
                        if (!handlerFunction)
                            return;
    
                        try {
                            // Take all the event args, and prefix with the viewmodel
                            var argsForHandler = ko.utils.makeArray(arguments);
                            viewModel = bindingContext['$data'];
                            argsForHandler.unshift(viewModel);
                            handlerReturnValue = handlerFunction.apply(viewModel, argsForHandler);
                        } finally {
                            if (handlerReturnValue !== true) { // Normally we want to prevent default action. Developer can override this be explicitly returning true.
                                if (event.preventDefault)
                                    event.preventDefault();
                                else
                                    event.returnValue = false;
                            }
                        }
    
                        var bubble = allBindings.get(eventName + 'Bubble') !== false;
                        if (!bubble) {
                            event.cancelBubble = true;
                            if (event.stopPropagation)
                                event.stopPropagation();
                        }
                    });
                }
            });
        }
    };
    // "foreach: someExpression" is equivalent to "template: { foreach: someExpression }"
    // "foreach: { data: someExpression, afterAdd: myfn }" is equivalent to "template: { foreach: someExpression, afterAdd: myfn }"
    ko.bindingHandlers['foreach'] = {
        makeTemplateValueAccessor: function(valueAccessor) {
            return function() {
                var modelValue = valueAccessor(),
                    unwrappedValue = ko.utils.peekObservable(modelValue);    // Unwrap without setting a dependency here
    
                // If unwrappedValue is the array, pass in the wrapped value on its own
                // The value will be unwrapped and tracked within the template binding
                // (See https://github.com/SteveSanderson/knockout/issues/523)
                if ((!unwrappedValue) || typeof unwrappedValue.length == "number")
                    return { 'foreach': modelValue, 'templateEngine': ko.nativeTemplateEngine.instance };
    
                // If unwrappedValue.data is the array, preserve all relevant options and unwrap again value so we get updates
                ko.utils.unwrapObservable(modelValue);
                return {
                    'foreach': unwrappedValue['data'],
                    'as': unwrappedValue['as'],
                    'includeDestroyed': unwrappedValue['includeDestroyed'],
                    'afterAdd': unwrappedValue['afterAdd'],
                    'beforeRemove': unwrappedValue['beforeRemove'],
                    'afterRender': unwrappedValue['afterRender'],
                    'beforeMove': unwrappedValue['beforeMove'],
                    'afterMove': unwrappedValue['afterMove'],
                    'templateEngine': ko.nativeTemplateEngine.instance
                };
            };
        },
        'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
            return ko.bindingHandlers['template']['init'](element, ko.bindingHandlers['foreach'].makeTemplateValueAccessor(valueAccessor));
        },
        'update': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
            return ko.bindingHandlers['template']['update'](element, ko.bindingHandlers['foreach'].makeTemplateValueAccessor(valueAccessor), allBindings, viewModel, bindingContext);
        }
    };
    ko.expressionRewriting.bindingRewriteValidators['foreach'] = false; // Can't rewrite control flow bindings
    ko.virtualElements.allowedBindings['foreach'] = true;
    var hasfocusUpdatingProperty = '__ko_hasfocusUpdating';
    var hasfocusLastValue = '__ko_hasfocusLastValue';
    ko.bindingHandlers['hasfocus'] = {
        'init': function(element, valueAccessor, allBindings) {
            var handleElementFocusChange = function(isFocused) {
                // Where possible, ignore which event was raised and determine focus state using activeElement,
                // as this avoids phantom focus/blur events raised when changing tabs in modern browsers.
                // However, not all KO-targeted browsers (Firefox 2) support activeElement. For those browsers,
                // prevent a loss of focus when changing tabs/windows by setting a flag that prevents hasfocus
                // from calling 'blur()' on the element when it loses focus.
                // Discussion at https://github.com/SteveSanderson/knockout/pull/352
                element[hasfocusUpdatingProperty] = true;
                var ownerDoc = element.ownerDocument;
                if ("activeElement" in ownerDoc) {
                    var active;
                    try {
                        active = ownerDoc.activeElement;
                    } catch(e) {
                        // IE9 throws if you access activeElement during page load (see issue #703)
                        active = ownerDoc.body;
                    }
                    isFocused = (active === element);
                }
                var modelValue = valueAccessor();
                ko.expressionRewriting.writeValueToProperty(modelValue, allBindings, 'hasfocus', isFocused, true);
    
                //cache the latest value, so we can avoid unnecessarily calling focus/blur in the update function
                element[hasfocusLastValue] = isFocused;
                element[hasfocusUpdatingProperty] = false;
            };
            var handleElementFocusIn = handleElementFocusChange.bind(null, true);
            var handleElementFocusOut = handleElementFocusChange.bind(null, false);
    
            ko.utils.registerEventHandler(element, "focus", handleElementFocusIn);
            ko.utils.registerEventHandler(element, "focusin", handleElementFocusIn); // For IE
            ko.utils.registerEventHandler(element, "blur",  handleElementFocusOut);
            ko.utils.registerEventHandler(element, "focusout",  handleElementFocusOut); // For IE
        },
        'update': function(element, valueAccessor) {
            var value = !!ko.utils.unwrapObservable(valueAccessor());
    
            if (!element[hasfocusUpdatingProperty] && element[hasfocusLastValue] !== value) {
                value ? element.focus() : element.blur();
    
                // In IE, the blur method doesn't always cause the element to lose focus (for example, if the window is not in focus).
                // Setting focus to the body element does seem to be reliable in IE, but should only be used if we know that the current
                // element was focused already.
                if (!value && element[hasfocusLastValue]) {
                    element.ownerDocument.body.focus();
                }
    
                // For IE, which doesn't reliably fire "focus" or "blur" events synchronously
                ko.dependencyDetection.ignore(ko.utils.triggerEvent, null, [element, value ? "focusin" : "focusout"]);
            }
        }
    };
    ko.expressionRewriting.twoWayBindings['hasfocus'] = true;
    
    ko.bindingHandlers['hasFocus'] = ko.bindingHandlers['hasfocus']; // Make "hasFocus" an alias
    ko.expressionRewriting.twoWayBindings['hasFocus'] = true;
    ko.bindingHandlers['html'] = {
        'init': function() {
            // Prevent binding on the dynamically-injected HTML (as developers are unlikely to expect that, and it has security implications)
            return { 'controlsDescendantBindings': true };
        },
        'update': function (element, valueAccessor) {
            // setHtml will unwrap the value if needed
            ko.utils.setHtml(element, valueAccessor());
        }
    };
    // Makes a binding like with or if
    function makeWithIfBinding(bindingKey, isWith, isNot, makeContextCallback) {
        ko.bindingHandlers[bindingKey] = {
            'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
                var didDisplayOnLastUpdate,
                    savedNodes;
                ko.computed(function() {
                    var rawValue = valueAccessor(),
                        dataValue = ko.utils.unwrapObservable(rawValue),
                        shouldDisplay = !isNot !== !dataValue, // equivalent to isNot ? !dataValue : !!dataValue
                        isFirstRender = !savedNodes,
                        needsRefresh = isFirstRender || isWith || (shouldDisplay !== didDisplayOnLastUpdate);
    
                    if (needsRefresh) {
                        // Save a copy of the inner nodes on the initial update, but only if we have dependencies.
                        if (isFirstRender && ko.computedContext.getDependenciesCount()) {
                            savedNodes = ko.utils.cloneNodes(ko.virtualElements.childNodes(element), true /* shouldCleanNodes */);
                        }
    
                        if (shouldDisplay) {
                            if (!isFirstRender) {
                                ko.virtualElements.setDomNodeChildren(element, ko.utils.cloneNodes(savedNodes));
                            }
                            ko.applyBindingsToDescendants(makeContextCallback ? makeContextCallback(bindingContext, rawValue) : bindingContext, element);
                        } else {
                            ko.virtualElements.emptyNode(element);
                        }
    
                        didDisplayOnLastUpdate = shouldDisplay;
                    }
                }, null, { disposeWhenNodeIsRemoved: element });
                return { 'controlsDescendantBindings': true };
            }
        };
        ko.expressionRewriting.bindingRewriteValidators[bindingKey] = false; // Can't rewrite control flow bindings
        ko.virtualElements.allowedBindings[bindingKey] = true;
    }
    
    // Construct the actual binding handlers
    makeWithIfBinding('if');
    makeWithIfBinding('ifnot', false /* isWith */, true /* isNot */);
    makeWithIfBinding('with', true /* isWith */, false /* isNot */,
        function(bindingContext, dataValue) {
            return bindingContext.createStaticChildContext(dataValue);
        }
    );
    var captionPlaceholder = {};
    ko.bindingHandlers['options'] = {
        'init': function(element) {
            if (ko.utils.tagNameLower(element) !== "select")
                throw new Error("options binding applies only to SELECT elements");
    
            // Remove all existing <option>s.
            while (element.length > 0) {
                element.remove(0);
            }
    
            // Ensures that the binding processor doesn't try to bind the options
            return { 'controlsDescendantBindings': true };
        },
        'update': function (element, valueAccessor, allBindings) {
            function selectedOptions() {
                return ko.utils.arrayFilter(element.options, function (node) { return node.selected; });
            }
    
            var selectWasPreviouslyEmpty = element.length == 0,
                multiple = element.multiple,
                previousScrollTop = (!selectWasPreviouslyEmpty && multiple) ? element.scrollTop : null,
                unwrappedArray = ko.utils.unwrapObservable(valueAccessor()),
                valueAllowUnset = allBindings.get('valueAllowUnset') && allBindings['has']('value'),
                includeDestroyed = allBindings.get('optionsIncludeDestroyed'),
                arrayToDomNodeChildrenOptions = {},
                captionValue,
                filteredArray,
                previousSelectedValues = [];
    
            if (!valueAllowUnset) {
                if (multiple) {
                    previousSelectedValues = ko.utils.arrayMap(selectedOptions(), ko.selectExtensions.readValue);
                } else if (element.selectedIndex >= 0) {
                    previousSelectedValues.push(ko.selectExtensions.readValue(element.options[element.selectedIndex]));
                }
            }
    
            if (unwrappedArray) {
                if (typeof unwrappedArray.length == "undefined") // Coerce single value into array
                    unwrappedArray = [unwrappedArray];
    
                // Filter out any entries marked as destroyed
                filteredArray = ko.utils.arrayFilter(unwrappedArray, function(item) {
                    return includeDestroyed || item === undefined || item === null || !ko.utils.unwrapObservable(item['_destroy']);
                });
    
                // If caption is included, add it to the array
                if (allBindings['has']('optionsCaption')) {
                    captionValue = ko.utils.unwrapObservable(allBindings.get('optionsCaption'));
                    // If caption value is null or undefined, don't show a caption
                    if (captionValue !== null && captionValue !== undefined) {
                        filteredArray.unshift(captionPlaceholder);
                    }
                }
            } else {
                // If a falsy value is provided (e.g. null), we'll simply empty the select element
            }
    
            function applyToObject(object, predicate, defaultValue) {
                var predicateType = typeof predicate;
                if (predicateType == "function")    // Given a function; run it against the data value
                    return predicate(object);
                else if (predicateType == "string") // Given a string; treat it as a property name on the data value
                    return object[predicate];
                else                                // Given no optionsText arg; use the data value itself
                    return defaultValue;
            }
    
            // The following functions can run at two different times:
            // The first is when the whole array is being updated directly from this binding handler.
            // The second is when an observable value for a specific array entry is updated.
            // oldOptions will be empty in the first case, but will be filled with the previously generated option in the second.
            var itemUpdate = false;
            function optionForArrayItem(arrayEntry, index, oldOptions) {
                if (oldOptions.length) {
                    previousSelectedValues = !valueAllowUnset && oldOptions[0].selected ? [ ko.selectExtensions.readValue(oldOptions[0]) ] : [];
                    itemUpdate = true;
                }
                var option = element.ownerDocument.createElement("option");
                if (arrayEntry === captionPlaceholder) {
                    ko.utils.setTextContent(option, allBindings.get('optionsCaption'));
                    ko.selectExtensions.writeValue(option, undefined);
                } else {
                    // Apply a value to the option element
                    var optionValue = applyToObject(arrayEntry, allBindings.get('optionsValue'), arrayEntry);
                    ko.selectExtensions.writeValue(option, ko.utils.unwrapObservable(optionValue));
    
                    // Apply some text to the option element
                    var optionText = applyToObject(arrayEntry, allBindings.get('optionsText'), optionValue);
                    ko.utils.setTextContent(option, optionText);
                }
                return [option];
            }
    
            // By using a beforeRemove callback, we delay the removal until after new items are added. This fixes a selection
            // problem in IE<=8 and Firefox. See https://github.com/knockout/knockout/issues/1208
            arrayToDomNodeChildrenOptions['beforeRemove'] =
                function (option) {
                    element.removeChild(option);
                };
    
            function setSelectionCallback(arrayEntry, newOptions) {
                if (itemUpdate && valueAllowUnset) {
                    // The model value is authoritative, so make sure its value is the one selected
                    // There is no need to use dependencyDetection.ignore since setDomNodeChildrenFromArrayMapping does so already.
                    ko.selectExtensions.writeValue(element, ko.utils.unwrapObservable(allBindings.get('value')), true /* allowUnset */);
                } else if (previousSelectedValues.length) {
                    // IE6 doesn't like us to assign selection to OPTION nodes before they're added to the document.
                    // That's why we first added them without selection. Now it's time to set the selection.
                    var isSelected = ko.utils.arrayIndexOf(previousSelectedValues, ko.selectExtensions.readValue(newOptions[0])) >= 0;
                    ko.utils.setOptionNodeSelectionState(newOptions[0], isSelected);
    
                    // If this option was changed from being selected during a single-item update, notify the change
                    if (itemUpdate && !isSelected) {
                        ko.dependencyDetection.ignore(ko.utils.triggerEvent, null, [element, "change"]);
                    }
                }
            }
    
            var callback = setSelectionCallback;
            if (allBindings['has']('optionsAfterRender') && typeof allBindings.get('optionsAfterRender') == "function") {
                callback = function(arrayEntry, newOptions) {
                    setSelectionCallback(arrayEntry, newOptions);
                    ko.dependencyDetection.ignore(allBindings.get('optionsAfterRender'), null, [newOptions[0], arrayEntry !== captionPlaceholder ? arrayEntry : undefined]);
                }
            }
    
            ko.utils.setDomNodeChildrenFromArrayMapping(element, filteredArray, optionForArrayItem, arrayToDomNodeChildrenOptions, callback);
    
            ko.dependencyDetection.ignore(function () {
                if (valueAllowUnset) {
                    // The model value is authoritative, so make sure its value is the one selected
                    ko.selectExtensions.writeValue(element, ko.utils.unwrapObservable(allBindings.get('value')), true /* allowUnset */);
                } else {
                    // Determine if the selection has changed as a result of updating the options list
                    var selectionChanged;
                    if (multiple) {
                        // For a multiple-select box, compare the new selection count to the previous one
                        // But if nothing was selected before, the selection can't have changed
                        selectionChanged = previousSelectedValues.length && selectedOptions().length < previousSelectedValues.length;
                    } else {
                        // For a single-select box, compare the current value to the previous value
                        // But if nothing was selected before or nothing is selected now, just look for a change in selection
                        selectionChanged = (previousSelectedValues.length && element.selectedIndex >= 0)
                            ? (ko.selectExtensions.readValue(element.options[element.selectedIndex]) !== previousSelectedValues[0])
                            : (previousSelectedValues.length || element.selectedIndex >= 0);
                    }
    
                    // Ensure consistency between model value and selected option.
                    // If the dropdown was changed so that selection is no longer the same,
                    // notify the value or selectedOptions binding.
                    if (selectionChanged) {
                        ko.utils.triggerEvent(element, "change");
                    }
                }
            });
    
            // Workaround for IE bug
            ko.utils.ensureSelectElementIsRenderedCorrectly(element);
    
            if (previousScrollTop && Math.abs(previousScrollTop - element.scrollTop) > 20)
                element.scrollTop = previousScrollTop;
        }
    };
    ko.bindingHandlers['options'].optionValueDomDataKey = ko.utils.domData.nextKey();
    ko.bindingHandlers['selectedOptions'] = {
        'after': ['options', 'foreach'],
        'init': function (element, valueAccessor, allBindings) {
            ko.utils.registerEventHandler(element, "change", function () {
                var value = valueAccessor(), valueToWrite = [];
                ko.utils.arrayForEach(element.getElementsByTagName("option"), function(node) {
                    if (node.selected)
                        valueToWrite.push(ko.selectExtensions.readValue(node));
                });
                ko.expressionRewriting.writeValueToProperty(value, allBindings, 'selectedOptions', valueToWrite);
            });
        },
        'update': function (element, valueAccessor) {
            if (ko.utils.tagNameLower(element) != "select")
                throw new Error("values binding applies only to SELECT elements");
    
            var newValue = ko.utils.unwrapObservable(valueAccessor()),
                previousScrollTop = element.scrollTop;
    
            if (newValue && typeof newValue.length == "number") {
                ko.utils.arrayForEach(element.getElementsByTagName("option"), function(node) {
                    var isSelected = ko.utils.arrayIndexOf(newValue, ko.selectExtensions.readValue(node)) >= 0;
                    if (node.selected != isSelected) {      // This check prevents flashing of the select element in IE
                        ko.utils.setOptionNodeSelectionState(node, isSelected);
                    }
                });
            }
    
            element.scrollTop = previousScrollTop;
        }
    };
    ko.expressionRewriting.twoWayBindings['selectedOptions'] = true;
    ko.bindingHandlers['style'] = {
        'update': function (element, valueAccessor) {
            var value = ko.utils.unwrapObservable(valueAccessor() || {});
            ko.utils.objectForEach(value, function(styleName, styleValue) {
                styleValue = ko.utils.unwrapObservable(styleValue);
    
                if (styleValue === null || styleValue === undefined || styleValue === false) {
                    // Empty string removes the value, whereas null/undefined have no effect
                    styleValue = "";
                }
    
                element.style[styleName] = styleValue;
            });
        }
    };
    ko.bindingHandlers['submit'] = {
        'init': function (element, valueAccessor, allBindings, viewModel, bindingContext) {
            if (typeof valueAccessor() != "function")
                throw new Error("The value for a submit binding must be a function");
            ko.utils.registerEventHandler(element, "submit", function (event) {
                var handlerReturnValue;
                var value = valueAccessor();
                try { handlerReturnValue = value.call(bindingContext['$data'], element); }
                finally {
                    if (handlerReturnValue !== true) { // Normally we want to prevent default action. Developer can override this be explicitly returning true.
                        if (event.preventDefault)
                            event.preventDefault();
                        else
                            event.returnValue = false;
                    }
                }
            });
        }
    };
    ko.bindingHandlers['text'] = {
        'init': function() {
            // Prevent binding on the dynamically-injected text node (as developers are unlikely to expect that, and it has security implications).
            // It should also make things faster, as we no longer have to consider whether the text node might be bindable.
            return { 'controlsDescendantBindings': true };
        },
        'update': function (element, valueAccessor) {
            ko.utils.setTextContent(element, valueAccessor());
        }
    };
    ko.virtualElements.allowedBindings['text'] = true;
    (function () {
    
    if (window && window.navigator) {
        var parseVersion = function (matches) {
            if (matches) {
                return parseFloat(matches[1]);
            }
        };
    
        // Detect various browser versions because some old versions don't fully support the 'input' event
        var operaVersion = window.opera && window.opera.version && parseInt(window.opera.version()),
            userAgent = window.navigator.userAgent,
            safariVersion = parseVersion(userAgent.match(/^(?:(?!chrome).)*version\/([^ ]*) safari/i)),
            firefoxVersion = parseVersion(userAgent.match(/Firefox\/([^ ]*)/));
    }
    
    // IE 8 and 9 have bugs that prevent the normal events from firing when the value changes.
    // But it does fire the 'selectionchange' event on many of those, presumably because the
    // cursor is moving and that counts as the selection changing. The 'selectionchange' event is
    // fired at the document level only and doesn't directly indicate which element changed. We
    // set up just one event handler for the document and use 'activeElement' to determine which
    // element was changed.
    if (ko.utils.ieVersion < 10) {
        var selectionChangeRegisteredName = ko.utils.domData.nextKey(),
            selectionChangeHandlerName = ko.utils.domData.nextKey();
        var selectionChangeHandler = function(event) {
            var target = this.activeElement,
                handler = target && ko.utils.domData.get(target, selectionChangeHandlerName);
            if (handler) {
                handler(event);
            }
        };
        var registerForSelectionChangeEvent = function (element, handler) {
            var ownerDoc = element.ownerDocument;
            if (!ko.utils.domData.get(ownerDoc, selectionChangeRegisteredName)) {
                ko.utils.domData.set(ownerDoc, selectionChangeRegisteredName, true);
                ko.utils.registerEventHandler(ownerDoc, 'selectionchange', selectionChangeHandler);
            }
            ko.utils.domData.set(element, selectionChangeHandlerName, handler);
        };
    }
    
    ko.bindingHandlers['textInput'] = {
        'init': function (element, valueAccessor, allBindings) {
    
            var previousElementValue = element.value,
                timeoutHandle,
                elementValueBeforeEvent;
    
            var updateModel = function (event) {
                clearTimeout(timeoutHandle);
                elementValueBeforeEvent = timeoutHandle = undefined;
    
                var elementValue = element.value;
                if (previousElementValue !== elementValue) {
                    // Provide a way for tests to know exactly which event was processed
                    if (DEBUG && event) element['_ko_textInputProcessedEvent'] = event.type;
                    previousElementValue = elementValue;
                    ko.expressionRewriting.writeValueToProperty(valueAccessor(), allBindings, 'textInput', elementValue);
                }
            };
    
            var deferUpdateModel = function (event) {
                if (!timeoutHandle) {
                    // The elementValueBeforeEvent variable is set *only* during the brief gap between an
                    // event firing and the updateModel function running. This allows us to ignore model
                    // updates that are from the previous state of the element, usually due to techniques
                    // such as rateLimit. Such updates, if not ignored, can cause keystrokes to be lost.
                    elementValueBeforeEvent = element.value;
                    var handler = DEBUG ? updateModel.bind(element, {type: event.type}) : updateModel;
                    timeoutHandle = ko.utils.setTimeout(handler, 4);
                }
            };
    
            // IE9 will mess up the DOM if you handle events synchronously which results in DOM changes (such as other bindings);
            // so we'll make sure all updates are asynchronous
            var ieUpdateModel = ko.utils.ieVersion == 9 ? deferUpdateModel : updateModel;
    
            var updateView = function () {
                var modelValue = ko.utils.unwrapObservable(valueAccessor());
    
                if (modelValue === null || modelValue === undefined) {
                    modelValue = '';
                }
    
                if (elementValueBeforeEvent !== undefined && modelValue === elementValueBeforeEvent) {
                    ko.utils.setTimeout(updateView, 4);
                    return;
                }
    
                // Update the element only if the element and model are different. On some browsers, updating the value
                // will move the cursor to the end of the input, which would be bad while the user is typing.
                if (element.value !== modelValue) {
                    previousElementValue = modelValue;  // Make sure we ignore events (propertychange) that result from updating the value
                    element.value = modelValue;
                }
            };
    
            var onEvent = function (event, handler) {
                ko.utils.registerEventHandler(element, event, handler);
            };
    
            if (DEBUG && ko.bindingHandlers['textInput']['_forceUpdateOn']) {
                // Provide a way for tests to specify exactly which events are bound
                ko.utils.arrayForEach(ko.bindingHandlers['textInput']['_forceUpdateOn'], function(eventName) {
                    if (eventName.slice(0,5) == 'after') {
                        onEvent(eventName.slice(5), deferUpdateModel);
                    } else {
                        onEvent(eventName, updateModel);
                    }
                });
            } else {
                if (ko.utils.ieVersion < 10) {
                    // Internet Explorer <= 8 doesn't support the 'input' event, but does include 'propertychange' that fires whenever
                    // any property of an element changes. Unlike 'input', it also fires if a property is changed from JavaScript code,
                    // but that's an acceptable compromise for this binding. IE 9 does support 'input', but since it doesn't fire it
                    // when using autocomplete, we'll use 'propertychange' for it also.
                    onEvent('propertychange', function(event) {
                        if (event.propertyName === 'value') {
                            ieUpdateModel(event);
                        }
                    });
    
                    if (ko.utils.ieVersion == 8) {
                        // IE 8 has a bug where it fails to fire 'propertychange' on the first update following a value change from
                        // JavaScript code. It also doesn't fire if you clear the entire value. To fix this, we bind to the following
                        // events too.
                        onEvent('keyup', updateModel);      // A single keystoke
                        onEvent('keydown', updateModel);    // The first character when a key is held down
                    }
                    if (ko.utils.ieVersion >= 8) {
                        // Internet Explorer 9 doesn't fire the 'input' event when deleting text, including using
                        // the backspace, delete, or ctrl-x keys, clicking the 'x' to clear the input, dragging text
                        // out of the field, and cutting or deleting text using the context menu. 'selectionchange'
                        // can detect all of those except dragging text out of the field, for which we use 'dragend'.
                        // These are also needed in IE8 because of the bug described above.
                        registerForSelectionChangeEvent(element, ieUpdateModel);  // 'selectionchange' covers cut, paste, drop, delete, etc.
                        onEvent('dragend', deferUpdateModel);
                    }
                } else {
                    // All other supported browsers support the 'input' event, which fires whenever the content of the element is changed
                    // through the user interface.
                    onEvent('input', updateModel);
    
                    if (safariVersion < 5 && ko.utils.tagNameLower(element) === "textarea") {
                        // Safari <5 doesn't fire the 'input' event for <textarea> elements (it does fire 'textInput'
                        // but only when typing). So we'll just catch as much as we can with keydown, cut, and paste.
                        onEvent('keydown', deferUpdateModel);
                        onEvent('paste', deferUpdateModel);
                        onEvent('cut', deferUpdateModel);
                    } else if (operaVersion < 11) {
                        // Opera 10 doesn't always fire the 'input' event for cut, paste, undo & drop operations.
                        // We can try to catch some of those using 'keydown'.
                        onEvent('keydown', deferUpdateModel);
                    } else if (firefoxVersion < 4.0) {
                        // Firefox <= 3.6 doesn't fire the 'input' event when text is filled in through autocomplete
                        onEvent('DOMAutoComplete', updateModel);
    
                        // Firefox <=3.5 doesn't fire the 'input' event when text is dropped into the input.
                        onEvent('dragdrop', updateModel);       // <3.5
                        onEvent('drop', updateModel);           // 3.5
                    }
                }
            }
    
            // Bind to the change event so that we can catch programmatic updates of the value that fire this event.
            onEvent('change', updateModel);
    
            ko.computed(updateView, null, { disposeWhenNodeIsRemoved: element });
        }
    };
    ko.expressionRewriting.twoWayBindings['textInput'] = true;
    
    // textinput is an alias for textInput
    ko.bindingHandlers['textinput'] = {
        // preprocess is the only way to set up a full alias
        'preprocess': function (value, name, addBinding) {
            addBinding('textInput', value);
        }
    };
    
    })();ko.bindingHandlers['uniqueName'] = {
        'init': function (element, valueAccessor) {
            if (valueAccessor()) {
                var name = "ko_unique_" + (++ko.bindingHandlers['uniqueName'].currentIndex);
                ko.utils.setElementName(element, name);
            }
        }
    };
    ko.bindingHandlers['uniqueName'].currentIndex = 0;
    ko.bindingHandlers['value'] = {
        'after': ['options', 'foreach'],
        'init': function (element, valueAccessor, allBindings) {
            // If the value binding is placed on a radio/checkbox, then just pass through to checkedValue and quit
            if (element.tagName.toLowerCase() == "input" && (element.type == "checkbox" || element.type == "radio")) {
                ko.applyBindingAccessorsToNode(element, { 'checkedValue': valueAccessor });
                return;
            }
    
            // Always catch "change" event; possibly other events too if asked
            var eventsToCatch = ["change"];
            var requestedEventsToCatch = allBindings.get("valueUpdate");
            var propertyChangedFired = false;
            var elementValueBeforeEvent = null;
    
            if (requestedEventsToCatch) {
                if (typeof requestedEventsToCatch == "string") // Allow both individual event names, and arrays of event names
                    requestedEventsToCatch = [requestedEventsToCatch];
                ko.utils.arrayPushAll(eventsToCatch, requestedEventsToCatch);
                eventsToCatch = ko.utils.arrayGetDistinctValues(eventsToCatch);
            }
    
            var valueUpdateHandler = function() {
                elementValueBeforeEvent = null;
                propertyChangedFired = false;
                var modelValue = valueAccessor();
                var elementValue = ko.selectExtensions.readValue(element);
                ko.expressionRewriting.writeValueToProperty(modelValue, allBindings, 'value', elementValue);
            }
    
            // Workaround for https://github.com/SteveSanderson/knockout/issues/122
            // IE doesn't fire "change" events on textboxes if the user selects a value from its autocomplete list
            var ieAutoCompleteHackNeeded = ko.utils.ieVersion && element.tagName.toLowerCase() == "input" && element.type == "text"
                                           && element.autocomplete != "off" && (!element.form || element.form.autocomplete != "off");
            if (ieAutoCompleteHackNeeded && ko.utils.arrayIndexOf(eventsToCatch, "propertychange") == -1) {
                ko.utils.registerEventHandler(element, "propertychange", function () { propertyChangedFired = true });
                ko.utils.registerEventHandler(element, "focus", function () { propertyChangedFired = false });
                ko.utils.registerEventHandler(element, "blur", function() {
                    if (propertyChangedFired) {
                        valueUpdateHandler();
                    }
                });
            }
    
            ko.utils.arrayForEach(eventsToCatch, function(eventName) {
                // The syntax "after<eventname>" means "run the handler asynchronously after the event"
                // This is useful, for example, to catch "keydown" events after the browser has updated the control
                // (otherwise, ko.selectExtensions.readValue(this) will receive the control's value *before* the key event)
                var handler = valueUpdateHandler;
                if (ko.utils.stringStartsWith(eventName, "after")) {
                    handler = function() {
                        // The elementValueBeforeEvent variable is non-null *only* during the brief gap between
                        // a keyX event firing and the valueUpdateHandler running, which is scheduled to happen
                        // at the earliest asynchronous opportunity. We store this temporary information so that
                        // if, between keyX and valueUpdateHandler, the underlying model value changes separately,
                        // we can overwrite that model value change with the value the user just typed. Otherwise,
                        // techniques like rateLimit can trigger model changes at critical moments that will
                        // override the user's inputs, causing keystrokes to be lost.
                        elementValueBeforeEvent = ko.selectExtensions.readValue(element);
                        ko.utils.setTimeout(valueUpdateHandler, 0);
                    };
                    eventName = eventName.substring("after".length);
                }
                ko.utils.registerEventHandler(element, eventName, handler);
            });
    
            var updateFromModel = function () {
                var newValue = ko.utils.unwrapObservable(valueAccessor());
                var elementValue = ko.selectExtensions.readValue(element);
    
                if (elementValueBeforeEvent !== null && newValue === elementValueBeforeEvent) {
                    ko.utils.setTimeout(updateFromModel, 0);
                    return;
                }
    
                var valueHasChanged = (newValue !== elementValue);
    
                if (valueHasChanged) {
                    if (ko.utils.tagNameLower(element) === "select") {
                        var allowUnset = allBindings.get('valueAllowUnset');
                        var applyValueAction = function () {
                            ko.selectExtensions.writeValue(element, newValue, allowUnset);
                        };
                        applyValueAction();
    
                        if (!allowUnset && newValue !== ko.selectExtensions.readValue(element)) {
                            // If you try to set a model value that can't be represented in an already-populated dropdown, reject that change,
                            // because you're not allowed to have a model value that disagrees with a visible UI selection.
                            ko.dependencyDetection.ignore(ko.utils.triggerEvent, null, [element, "change"]);
                        } else {
                            // Workaround for IE6 bug: It won't reliably apply values to SELECT nodes during the same execution thread
                            // right after you've changed the set of OPTION nodes on it. So for that node type, we'll schedule a second thread
                            // to apply the value as well.
                            ko.utils.setTimeout(applyValueAction, 0);
                        }
                    } else {
                        ko.selectExtensions.writeValue(element, newValue);
                    }
                }
            };
    
            ko.computed(updateFromModel, null, { disposeWhenNodeIsRemoved: element });
        },
        'update': function() {} // Keep for backwards compatibility with code that may have wrapped value binding
    };
    ko.expressionRewriting.twoWayBindings['value'] = true;
    ko.bindingHandlers['visible'] = {
        'update': function (element, valueAccessor) {
            var value = ko.utils.unwrapObservable(valueAccessor());
            var isCurrentlyVisible = !(element.style.display == "none");
            if (value && !isCurrentlyVisible)
                element.style.display = "";
            else if ((!value) && isCurrentlyVisible)
                element.style.display = "none";
        }
    };
    // 'click' is just a shorthand for the usual full-length event:{click:handler}
    makeEventHandlerShortcut('click');
    // If you want to make a custom template engine,
    //
    // [1] Inherit from this class (like ko.nativeTemplateEngine does)
    // [2] Override 'renderTemplateSource', supplying a function with this signature:
    //
    //        function (templateSource, bindingContext, options) {
    //            // - templateSource.text() is the text of the template you should render
    //            // - bindingContext.$data is the data you should pass into the template
    //            //   - you might also want to make bindingContext.$parent, bindingContext.$parents,
    //            //     and bindingContext.$root available in the template too
    //            // - options gives you access to any other properties set on "data-bind: { template: options }"
    //            // - templateDocument is the document object of the template
    //            //
    //            // Return value: an array of DOM nodes
    //        }
    //
    // [3] Override 'createJavaScriptEvaluatorBlock', supplying a function with this signature:
    //
    //        function (script) {
    //            // Return value: Whatever syntax means "Evaluate the JavaScript statement 'script' and output the result"
    //            //               For example, the jquery.tmpl template engine converts 'someScript' to '${ someScript }'
    //        }
    //
    //     This is only necessary if you want to allow data-bind attributes to reference arbitrary template variables.
    //     If you don't want to allow that, you can set the property 'allowTemplateRewriting' to false (like ko.nativeTemplateEngine does)
    //     and then you don't need to override 'createJavaScriptEvaluatorBlock'.
    
    ko.templateEngine = function () { };
    
    ko.templateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options, templateDocument) {
        throw new Error("Override renderTemplateSource");
    };
    
    ko.templateEngine.prototype['createJavaScriptEvaluatorBlock'] = function (script) {
        throw new Error("Override createJavaScriptEvaluatorBlock");
    };
    
    ko.templateEngine.prototype['makeTemplateSource'] = function(template, templateDocument) {
        // Named template
        if (typeof template == "string") {
            templateDocument = templateDocument || document;
            var elem = templateDocument.getElementById(template);
            if (!elem)
                throw new Error("Cannot find template with ID " + template);
            return new ko.templateSources.domElement(elem);
        } else if ((template.nodeType == 1) || (template.nodeType == 8)) {
            // Anonymous template
            return new ko.templateSources.anonymousTemplate(template);
        } else
            throw new Error("Unknown template type: " + template);
    };
    
    ko.templateEngine.prototype['renderTemplate'] = function (template, bindingContext, options, templateDocument) {
        var templateSource = this['makeTemplateSource'](template, templateDocument);
        return this['renderTemplateSource'](templateSource, bindingContext, options, templateDocument);
    };
    
    ko.templateEngine.prototype['isTemplateRewritten'] = function (template, templateDocument) {
        // Skip rewriting if requested
        if (this['allowTemplateRewriting'] === false)
            return true;
        return this['makeTemplateSource'](template, templateDocument)['data']("isRewritten");
    };
    
    ko.templateEngine.prototype['rewriteTemplate'] = function (template, rewriterCallback, templateDocument) {
        var templateSource = this['makeTemplateSource'](template, templateDocument);
        var rewritten = rewriterCallback(templateSource['text']());
        templateSource['text'](rewritten);
        templateSource['data']("isRewritten", true);
    };
    
    ko.exportSymbol('templateEngine', ko.templateEngine);
    
    ko.templateRewriting = (function () {
        var memoizeDataBindingAttributeSyntaxRegex = /(<([a-z]+\d*)(?:\s+(?!data-bind\s*=\s*)[a-z0-9\-]+(?:=(?:\"[^\"]*\"|\'[^\']*\'|[^>]*))?)*\s+)data-bind\s*=\s*(["'])([\s\S]*?)\3/gi;
        var memoizeVirtualContainerBindingSyntaxRegex = /<!--\s*ko\b\s*([\s\S]*?)\s*-->/g;
    
        function validateDataBindValuesForRewriting(keyValueArray) {
            var allValidators = ko.expressionRewriting.bindingRewriteValidators;
            for (var i = 0; i < keyValueArray.length; i++) {
                var key = keyValueArray[i]['key'];
                if (allValidators.hasOwnProperty(key)) {
                    var validator = allValidators[key];
    
                    if (typeof validator === "function") {
                        var possibleErrorMessage = validator(keyValueArray[i]['value']);
                        if (possibleErrorMessage)
                            throw new Error(possibleErrorMessage);
                    } else if (!validator) {
                        throw new Error("This template engine does not support the '" + key + "' binding within its templates");
                    }
                }
            }
        }
    
        function constructMemoizedTagReplacement(dataBindAttributeValue, tagToRetain, nodeName, templateEngine) {
            var dataBindKeyValueArray = ko.expressionRewriting.parseObjectLiteral(dataBindAttributeValue);
            validateDataBindValuesForRewriting(dataBindKeyValueArray);
            var rewrittenDataBindAttributeValue = ko.expressionRewriting.preProcessBindings(dataBindKeyValueArray, {'valueAccessors':true});
    
            // For no obvious reason, Opera fails to evaluate rewrittenDataBindAttributeValue unless it's wrapped in an additional
            // anonymous function, even though Opera's built-in debugger can evaluate it anyway. No other browser requires this
            // extra indirection.
            var applyBindingsToNextSiblingScript =
                "ko.__tr_ambtns(function($context,$element){return(function(){return{ " + rewrittenDataBindAttributeValue + " } })()},'" + nodeName.toLowerCase() + "')";
            return templateEngine['createJavaScriptEvaluatorBlock'](applyBindingsToNextSiblingScript) + tagToRetain;
        }
    
        return {
            ensureTemplateIsRewritten: function (template, templateEngine, templateDocument) {
                if (!templateEngine['isTemplateRewritten'](template, templateDocument))
                    templateEngine['rewriteTemplate'](template, function (htmlString) {
                        return ko.templateRewriting.memoizeBindingAttributeSyntax(htmlString, templateEngine);
                    }, templateDocument);
            },
    
            memoizeBindingAttributeSyntax: function (htmlString, templateEngine) {
                return htmlString.replace(memoizeDataBindingAttributeSyntaxRegex, function () {
                    return constructMemoizedTagReplacement(/* dataBindAttributeValue: */ arguments[4], /* tagToRetain: */ arguments[1], /* nodeName: */ arguments[2], templateEngine);
                }).replace(memoizeVirtualContainerBindingSyntaxRegex, function() {
                    return constructMemoizedTagReplacement(/* dataBindAttributeValue: */ arguments[1], /* tagToRetain: */ "<!-- ko -->", /* nodeName: */ "#comment", templateEngine);
                });
            },
    
            applyMemoizedBindingsToNextSibling: function (bindings, nodeName) {
                return ko.memoization.memoize(function (domNode, bindingContext) {
                    var nodeToBind = domNode.nextSibling;
                    if (nodeToBind && nodeToBind.nodeName.toLowerCase() === nodeName) {
                        ko.applyBindingAccessorsToNode(nodeToBind, bindings, bindingContext);
                    }
                });
            }
        }
    })();
    
    
    // Exported only because it has to be referenced by string lookup from within rewritten template
    ko.exportSymbol('__tr_ambtns', ko.templateRewriting.applyMemoizedBindingsToNextSibling);
    (function() {
        // A template source represents a read/write way of accessing a template. This is to eliminate the need for template loading/saving
        // logic to be duplicated in every template engine (and means they can all work with anonymous templates, etc.)
        //
        // Two are provided by default:
        //  1. ko.templateSources.domElement       - reads/writes the text content of an arbitrary DOM element
        //  2. ko.templateSources.anonymousElement - uses ko.utils.domData to read/write text *associated* with the DOM element, but
        //                                           without reading/writing the actual element text content, since it will be overwritten
        //                                           with the rendered template output.
        // You can implement your own template source if you want to fetch/store templates somewhere other than in DOM elements.
        // Template sources need to have the following functions:
        //   text() 			- returns the template text from your storage location
        //   text(value)		- writes the supplied template text to your storage location
        //   data(key)			- reads values stored using data(key, value) - see below
        //   data(key, value)	- associates "value" with this template and the key "key". Is used to store information like "isRewritten".
        //
        // Optionally, template sources can also have the following functions:
        //   nodes()            - returns a DOM element containing the nodes of this template, where available
        //   nodes(value)       - writes the given DOM element to your storage location
        // If a DOM element is available for a given template source, template engines are encouraged to use it in preference over text()
        // for improved speed. However, all templateSources must supply text() even if they don't supply nodes().
        //
        // Once you've implemented a templateSource, make your template engine use it by subclassing whatever template engine you were
        // using and overriding "makeTemplateSource" to return an instance of your custom template source.
    
        ko.templateSources = {};
    
        // ---- ko.templateSources.domElement -----
    
        // template types
        var templateScript = 1,
            templateTextArea = 2,
            templateTemplate = 3,
            templateElement = 4;
    
        ko.templateSources.domElement = function(element) {
            this.domElement = element;
    
            if (element) {
                var tagNameLower = ko.utils.tagNameLower(element);
                this.templateType =
                    tagNameLower === "script" ? templateScript :
                    tagNameLower === "textarea" ? templateTextArea :
                        // For browsers with proper <template> element support, where the .content property gives a document fragment
                    tagNameLower == "template" && element.content && element.content.nodeType === 11 ? templateTemplate :
                    templateElement;
            }
        }
    
        ko.templateSources.domElement.prototype['text'] = function(/* valueToWrite */) {
            var elemContentsProperty = this.templateType === templateScript ? "text"
                                     : this.templateType === templateTextArea ? "value"
                                     : "innerHTML";
    
            if (arguments.length == 0) {
                return this.domElement[elemContentsProperty];
            } else {
                var valueToWrite = arguments[0];
                if (elemContentsProperty === "innerHTML")
                    ko.utils.setHtml(this.domElement, valueToWrite);
                else
                    this.domElement[elemContentsProperty] = valueToWrite;
            }
        };
    
        var dataDomDataPrefix = ko.utils.domData.nextKey() + "_";
        ko.templateSources.domElement.prototype['data'] = function(key /*, valueToWrite */) {
            if (arguments.length === 1) {
                return ko.utils.domData.get(this.domElement, dataDomDataPrefix + key);
            } else {
                ko.utils.domData.set(this.domElement, dataDomDataPrefix + key, arguments[1]);
            }
        };
    
        var templatesDomDataKey = ko.utils.domData.nextKey();
        function getTemplateDomData(element) {
            return ko.utils.domData.get(element, templatesDomDataKey) || {};
        }
        function setTemplateDomData(element, data) {
            ko.utils.domData.set(element, templatesDomDataKey, data);
        }
    
        ko.templateSources.domElement.prototype['nodes'] = function(/* valueToWrite */) {
            var element = this.domElement;
            if (arguments.length == 0) {
                var templateData = getTemplateDomData(element),
                    containerData = templateData.containerData;
                return containerData || (
                    this.templateType === templateTemplate ? element.content :
                    this.templateType === templateElement ? element :
                    undefined);
            } else {
                var valueToWrite = arguments[0];
                setTemplateDomData(element, {containerData: valueToWrite});
            }
        };
    
        // ---- ko.templateSources.anonymousTemplate -----
        // Anonymous templates are normally saved/retrieved as DOM nodes through "nodes".
        // For compatibility, you can also read "text"; it will be serialized from the nodes on demand.
        // Writing to "text" is still supported, but then the template data will not be available as DOM nodes.
    
        ko.templateSources.anonymousTemplate = function(element) {
            this.domElement = element;
        }
        ko.templateSources.anonymousTemplate.prototype = new ko.templateSources.domElement();
        ko.templateSources.anonymousTemplate.prototype.constructor = ko.templateSources.anonymousTemplate;
        ko.templateSources.anonymousTemplate.prototype['text'] = function(/* valueToWrite */) {
            if (arguments.length == 0) {
                var templateData = getTemplateDomData(this.domElement);
                if (templateData.textData === undefined && templateData.containerData)
                    templateData.textData = templateData.containerData.innerHTML;
                return templateData.textData;
            } else {
                var valueToWrite = arguments[0];
                setTemplateDomData(this.domElement, {textData: valueToWrite});
            }
        };
    
        ko.exportSymbol('templateSources', ko.templateSources);
        ko.exportSymbol('templateSources.domElement', ko.templateSources.domElement);
        ko.exportSymbol('templateSources.anonymousTemplate', ko.templateSources.anonymousTemplate);
    })();
    (function () {
        var _templateEngine;
        ko.setTemplateEngine = function (templateEngine) {
            if ((templateEngine != undefined) && !(templateEngine instanceof ko.templateEngine))
                throw new Error("templateEngine must inherit from ko.templateEngine");
            _templateEngine = templateEngine;
        }
    
        function invokeForEachNodeInContinuousRange(firstNode, lastNode, action) {
            var node, nextInQueue = firstNode, firstOutOfRangeNode = ko.virtualElements.nextSibling(lastNode);
            while (nextInQueue && ((node = nextInQueue) !== firstOutOfRangeNode)) {
                nextInQueue = ko.virtualElements.nextSibling(node);
                action(node, nextInQueue);
            }
        }
    
        function activateBindingsOnContinuousNodeArray(continuousNodeArray, bindingContext) {
            // To be used on any nodes that have been rendered by a template and have been inserted into some parent element
            // Walks through continuousNodeArray (which *must* be continuous, i.e., an uninterrupted sequence of sibling nodes, because
            // the algorithm for walking them relies on this), and for each top-level item in the virtual-element sense,
            // (1) Does a regular "applyBindings" to associate bindingContext with this node and to activate any non-memoized bindings
            // (2) Unmemoizes any memos in the DOM subtree (e.g., to activate bindings that had been memoized during template rewriting)
    
            if (continuousNodeArray.length) {
                var firstNode = continuousNodeArray[0],
                    lastNode = continuousNodeArray[continuousNodeArray.length - 1],
                    parentNode = firstNode.parentNode,
                    provider = ko.bindingProvider['instance'],
                    preprocessNode = provider['preprocessNode'];
    
                if (preprocessNode) {
                    invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node, nextNodeInRange) {
                        var nodePreviousSibling = node.previousSibling;
                        var newNodes = preprocessNode.call(provider, node);
                        if (newNodes) {
                            if (node === firstNode)
                                firstNode = newNodes[0] || nextNodeInRange;
                            if (node === lastNode)
                                lastNode = newNodes[newNodes.length - 1] || nodePreviousSibling;
                        }
                    });
    
                    // Because preprocessNode can change the nodes, including the first and last nodes, update continuousNodeArray to match.
                    // We need the full set, including inner nodes, because the unmemoize step might remove the first node (and so the real
                    // first node needs to be in the array).
                    continuousNodeArray.length = 0;
                    if (!firstNode) { // preprocessNode might have removed all the nodes, in which case there's nothing left to do
                        return;
                    }
                    if (firstNode === lastNode) {
                        continuousNodeArray.push(firstNode);
                    } else {
                        continuousNodeArray.push(firstNode, lastNode);
                        ko.utils.fixUpContinuousNodeArray(continuousNodeArray, parentNode);
                    }
                }
    
                // Need to applyBindings *before* unmemoziation, because unmemoization might introduce extra nodes (that we don't want to re-bind)
                // whereas a regular applyBindings won't introduce new memoized nodes
                invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node) {
                    if (node.nodeType === 1 || node.nodeType === 8)
                        ko.applyBindings(bindingContext, node);
                });
                invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node) {
                    if (node.nodeType === 1 || node.nodeType === 8)
                        ko.memoization.unmemoizeDomNodeAndDescendants(node, [bindingContext]);
                });
    
                // Make sure any changes done by applyBindings or unmemoize are reflected in the array
                ko.utils.fixUpContinuousNodeArray(continuousNodeArray, parentNode);
            }
        }
    
        function getFirstNodeFromPossibleArray(nodeOrNodeArray) {
            return nodeOrNodeArray.nodeType ? nodeOrNodeArray
                                            : nodeOrNodeArray.length > 0 ? nodeOrNodeArray[0]
                                            : null;
        }
    
        function executeTemplate(targetNodeOrNodeArray, renderMode, template, bindingContext, options) {
            options = options || {};
            var firstTargetNode = targetNodeOrNodeArray && getFirstNodeFromPossibleArray(targetNodeOrNodeArray);
            var templateDocument = (firstTargetNode || template || {}).ownerDocument;
            var templateEngineToUse = (options['templateEngine'] || _templateEngine);
            ko.templateRewriting.ensureTemplateIsRewritten(template, templateEngineToUse, templateDocument);
            var renderedNodesArray = templateEngineToUse['renderTemplate'](template, bindingContext, options, templateDocument);
    
            // Loosely check result is an array of DOM nodes
            if ((typeof renderedNodesArray.length != "number") || (renderedNodesArray.length > 0 && typeof renderedNodesArray[0].nodeType != "number"))
                throw new Error("Template engine must return an array of DOM nodes");
    
            var haveAddedNodesToParent = false;
            switch (renderMode) {
                case "replaceChildren":
                    ko.virtualElements.setDomNodeChildren(targetNodeOrNodeArray, renderedNodesArray);
                    haveAddedNodesToParent = true;
                    break;
                case "replaceNode":
                    ko.utils.replaceDomNodes(targetNodeOrNodeArray, renderedNodesArray);
                    haveAddedNodesToParent = true;
                    break;
                case "ignoreTargetNode": break;
                default:
                    throw new Error("Unknown renderMode: " + renderMode);
            }
    
            if (haveAddedNodesToParent) {
                activateBindingsOnContinuousNodeArray(renderedNodesArray, bindingContext);
                if (options['afterRender'])
                    ko.dependencyDetection.ignore(options['afterRender'], null, [renderedNodesArray, bindingContext['$data']]);
            }
    
            return renderedNodesArray;
        }
    
        function resolveTemplateName(template, data, context) {
            // The template can be specified as:
            if (ko.isObservable(template)) {
                // 1. An observable, with string value
                return template();
            } else if (typeof template === 'function') {
                // 2. A function of (data, context) returning a string
                return template(data, context);
            } else {
                // 3. A string
                return template;
            }
        }
    
        ko.renderTemplate = function (template, dataOrBindingContext, options, targetNodeOrNodeArray, renderMode) {
            options = options || {};
            if ((options['templateEngine'] || _templateEngine) == undefined)
                throw new Error("Set a template engine before calling renderTemplate");
            renderMode = renderMode || "replaceChildren";
    
            if (targetNodeOrNodeArray) {
                var firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);
    
                var whenToDispose = function () { return (!firstTargetNode) || !ko.utils.domNodeIsAttachedToDocument(firstTargetNode); }; // Passive disposal (on next evaluation)
                var activelyDisposeWhenNodeIsRemoved = (firstTargetNode && renderMode == "replaceNode") ? firstTargetNode.parentNode : firstTargetNode;
    
                return ko.dependentObservable( // So the DOM is automatically updated when any dependency changes
                    function () {
                        // Ensure we've got a proper binding context to work with
                        var bindingContext = (dataOrBindingContext && (dataOrBindingContext instanceof ko.bindingContext))
                            ? dataOrBindingContext
                            : new ko.bindingContext(dataOrBindingContext, null, null, null, { "exportDependencies": true });
    
                        var templateName = resolveTemplateName(template, bindingContext['$data'], bindingContext),
                            renderedNodesArray = executeTemplate(targetNodeOrNodeArray, renderMode, templateName, bindingContext, options);
    
                        if (renderMode == "replaceNode") {
                            targetNodeOrNodeArray = renderedNodesArray;
                            firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);
                        }
                    },
                    null,
                    { disposeWhen: whenToDispose, disposeWhenNodeIsRemoved: activelyDisposeWhenNodeIsRemoved }
                );
            } else {
                // We don't yet have a DOM node to evaluate, so use a memo and render the template later when there is a DOM node
                return ko.memoization.memoize(function (domNode) {
                    ko.renderTemplate(template, dataOrBindingContext, options, domNode, "replaceNode");
                });
            }
        };
    
        ko.renderTemplateForEach = function (template, arrayOrObservableArray, options, targetNode, parentBindingContext) {
            // Since setDomNodeChildrenFromArrayMapping always calls executeTemplateForArrayItem and then
            // activateBindingsCallback for added items, we can store the binding context in the former to use in the latter.
            var arrayItemContext;
    
            // This will be called by setDomNodeChildrenFromArrayMapping to get the nodes to add to targetNode
            var executeTemplateForArrayItem = function (arrayValue, index) {
                // Support selecting template as a function of the data being rendered
                arrayItemContext = parentBindingContext['createChildContext'](arrayValue, options['as'], function(context) {
                    context['$index'] = index;
                });
    
                var templateName = resolveTemplateName(template, arrayValue, arrayItemContext);
                return executeTemplate(null, "ignoreTargetNode", templateName, arrayItemContext, options);
            }
    
            // This will be called whenever setDomNodeChildrenFromArrayMapping has added nodes to targetNode
            var activateBindingsCallback = function(arrayValue, addedNodesArray, index) {
                activateBindingsOnContinuousNodeArray(addedNodesArray, arrayItemContext);
                if (options['afterRender'])
                    options['afterRender'](addedNodesArray, arrayValue);
    
                // release the "cache" variable, so that it can be collected by
                // the GC when its value isn't used from within the bindings anymore.
                arrayItemContext = null;
            };
    
            return ko.dependentObservable(function () {
                var unwrappedArray = ko.utils.unwrapObservable(arrayOrObservableArray) || [];
                if (typeof unwrappedArray.length == "undefined") // Coerce single value into array
                    unwrappedArray = [unwrappedArray];
    
                // Filter out any entries marked as destroyed
                var filteredArray = ko.utils.arrayFilter(unwrappedArray, function(item) {
                    return options['includeDestroyed'] || item === undefined || item === null || !ko.utils.unwrapObservable(item['_destroy']);
                });
    
                // Call setDomNodeChildrenFromArrayMapping, ignoring any observables unwrapped within (most likely from a callback function).
                // If the array items are observables, though, they will be unwrapped in executeTemplateForArrayItem and managed within setDomNodeChildrenFromArrayMapping.
                ko.dependencyDetection.ignore(ko.utils.setDomNodeChildrenFromArrayMapping, null, [targetNode, filteredArray, executeTemplateForArrayItem, options, activateBindingsCallback]);
    
            }, null, { disposeWhenNodeIsRemoved: targetNode });
        };
    
        var templateComputedDomDataKey = ko.utils.domData.nextKey();
        function disposeOldComputedAndStoreNewOne(element, newComputed) {
            var oldComputed = ko.utils.domData.get(element, templateComputedDomDataKey);
            if (oldComputed && (typeof(oldComputed.dispose) == 'function'))
                oldComputed.dispose();
            ko.utils.domData.set(element, templateComputedDomDataKey, (newComputed && newComputed.isActive()) ? newComputed : undefined);
        }
    
        ko.bindingHandlers['template'] = {
            'init': function(element, valueAccessor) {
                // Support anonymous templates
                var bindingValue = ko.utils.unwrapObservable(valueAccessor());
                if (typeof bindingValue == "string" || bindingValue['name']) {
                    // It's a named template - clear the element
                    ko.virtualElements.emptyNode(element);
                } else if ('nodes' in bindingValue) {
                    // We've been given an array of DOM nodes. Save them as the template source.
                    // There is no known use case for the node array being an observable array (if the output
                    // varies, put that behavior *into* your template - that's what templates are for), and
                    // the implementation would be a mess, so assert that it's not observable.
                    var nodes = bindingValue['nodes'] || [];
                    if (ko.isObservable(nodes)) {
                        throw new Error('The "nodes" option must be a plain, non-observable array.');
                    }
                    var container = ko.utils.moveCleanedNodesToContainerElement(nodes); // This also removes the nodes from their current parent
                    new ko.templateSources.anonymousTemplate(element)['nodes'](container);
                } else {
                    // It's an anonymous template - store the element contents, then clear the element
                    var templateNodes = ko.virtualElements.childNodes(element),
                        container = ko.utils.moveCleanedNodesToContainerElement(templateNodes); // This also removes the nodes from their current parent
                    new ko.templateSources.anonymousTemplate(element)['nodes'](container);
                }
                return { 'controlsDescendantBindings': true };
            },
            'update': function (element, valueAccessor, allBindings, viewModel, bindingContext) {
                var value = valueAccessor(),
                    options = ko.utils.unwrapObservable(value),
                    shouldDisplay = true,
                    templateComputed = null,
                    templateName;
    
                if (typeof options == "string") {
                    templateName = value;
                    options = {};
                } else {
                    templateName = options['name'];
    
                    // Support "if"/"ifnot" conditions
                    if ('if' in options)
                        shouldDisplay = ko.utils.unwrapObservable(options['if']);
                    if (shouldDisplay && 'ifnot' in options)
                        shouldDisplay = !ko.utils.unwrapObservable(options['ifnot']);
                }
    
                if ('foreach' in options) {
                    // Render once for each data point (treating data set as empty if shouldDisplay==false)
                    var dataArray = (shouldDisplay && options['foreach']) || [];
                    templateComputed = ko.renderTemplateForEach(templateName || element, dataArray, options, element, bindingContext);
                } else if (!shouldDisplay) {
                    ko.virtualElements.emptyNode(element);
                } else {
                    // Render once for this single data point (or use the viewModel if no data was provided)
                    var innerBindingContext = ('data' in options) ?
                        bindingContext.createStaticChildContext(options['data'], options['as']) :  // Given an explitit 'data' value, we create a child binding context for it
                        bindingContext;                                                        // Given no explicit 'data' value, we retain the same binding context
                    templateComputed = ko.renderTemplate(templateName || element, innerBindingContext, options, element);
                }
    
                // It only makes sense to have a single template computed per element (otherwise which one should have its output displayed?)
                disposeOldComputedAndStoreNewOne(element, templateComputed);
            }
        };
    
        // Anonymous templates can't be rewritten. Give a nice error message if you try to do it.
        ko.expressionRewriting.bindingRewriteValidators['template'] = function(bindingValue) {
            var parsedBindingValue = ko.expressionRewriting.parseObjectLiteral(bindingValue);
    
            if ((parsedBindingValue.length == 1) && parsedBindingValue[0]['unknown'])
                return null; // It looks like a string literal, not an object literal, so treat it as a named template (which is allowed for rewriting)
    
            if (ko.expressionRewriting.keyValueArrayContainsKey(parsedBindingValue, "name"))
                return null; // Named templates can be rewritten, so return "no error"
            return "This template engine does not support anonymous templates nested within its templates";
        };
    
        ko.virtualElements.allowedBindings['template'] = true;
    })();
    
    ko.exportSymbol('setTemplateEngine', ko.setTemplateEngine);
    ko.exportSymbol('renderTemplate', ko.renderTemplate);
    // Go through the items that have been added and deleted and try to find matches between them.
    ko.utils.findMovesInArrayComparison = function (left, right, limitFailedCompares) {
        if (left.length && right.length) {
            var failedCompares, l, r, leftItem, rightItem;
            for (failedCompares = l = 0; (!limitFailedCompares || failedCompares < limitFailedCompares) && (leftItem = left[l]); ++l) {
                for (r = 0; rightItem = right[r]; ++r) {
                    if (leftItem['value'] === rightItem['value']) {
                        leftItem['moved'] = rightItem['index'];
                        rightItem['moved'] = leftItem['index'];
                        right.splice(r, 1);         // This item is marked as moved; so remove it from right list
                        failedCompares = r = 0;     // Reset failed compares count because we're checking for consecutive failures
                        break;
                    }
                }
                failedCompares += r;
            }
        }
    };
    
    ko.utils.compareArrays = (function () {
        var statusNotInOld = 'added', statusNotInNew = 'deleted';
    
        // Simple calculation based on Levenshtein distance.
        function compareArrays(oldArray, newArray, options) {
            // For backward compatibility, if the third arg is actually a bool, interpret
            // it as the old parameter 'dontLimitMoves'. Newer code should use { dontLimitMoves: true }.
            options = (typeof options === 'boolean') ? { 'dontLimitMoves': options } : (options || {});
            oldArray = oldArray || [];
            newArray = newArray || [];
    
            if (oldArray.length < newArray.length)
                return compareSmallArrayToBigArray(oldArray, newArray, statusNotInOld, statusNotInNew, options);
            else
                return compareSmallArrayToBigArray(newArray, oldArray, statusNotInNew, statusNotInOld, options);
        }
    
        function compareSmallArrayToBigArray(smlArray, bigArray, statusNotInSml, statusNotInBig, options) {
            var myMin = Math.min,
                myMax = Math.max,
                editDistanceMatrix = [],
                smlIndex, smlIndexMax = smlArray.length,
                bigIndex, bigIndexMax = bigArray.length,
                compareRange = (bigIndexMax - smlIndexMax) || 1,
                maxDistance = smlIndexMax + bigIndexMax + 1,
                thisRow, lastRow,
                bigIndexMaxForRow, bigIndexMinForRow;
    
            for (smlIndex = 0; smlIndex <= smlIndexMax; smlIndex++) {
                lastRow = thisRow;
                editDistanceMatrix.push(thisRow = []);
                bigIndexMaxForRow = myMin(bigIndexMax, smlIndex + compareRange);
                bigIndexMinForRow = myMax(0, smlIndex - 1);
                for (bigIndex = bigIndexMinForRow; bigIndex <= bigIndexMaxForRow; bigIndex++) {
                    if (!bigIndex)
                        thisRow[bigIndex] = smlIndex + 1;
                    else if (!smlIndex)  // Top row - transform empty array into new array via additions
                        thisRow[bigIndex] = bigIndex + 1;
                    else if (smlArray[smlIndex - 1] === bigArray[bigIndex - 1])
                        thisRow[bigIndex] = lastRow[bigIndex - 1];                  // copy value (no edit)
                    else {
                        var northDistance = lastRow[bigIndex] || maxDistance;       // not in big (deletion)
                        var westDistance = thisRow[bigIndex - 1] || maxDistance;    // not in small (addition)
                        thisRow[bigIndex] = myMin(northDistance, westDistance) + 1;
                    }
                }
            }
    
            var editScript = [], meMinusOne, notInSml = [], notInBig = [];
            for (smlIndex = smlIndexMax, bigIndex = bigIndexMax; smlIndex || bigIndex;) {
                meMinusOne = editDistanceMatrix[smlIndex][bigIndex] - 1;
                if (bigIndex && meMinusOne === editDistanceMatrix[smlIndex][bigIndex-1]) {
                    notInSml.push(editScript[editScript.length] = {     // added
                        'status': statusNotInSml,
                        'value': bigArray[--bigIndex],
                        'index': bigIndex });
                } else if (smlIndex && meMinusOne === editDistanceMatrix[smlIndex - 1][bigIndex]) {
                    notInBig.push(editScript[editScript.length] = {     // deleted
                        'status': statusNotInBig,
                        'value': smlArray[--smlIndex],
                        'index': smlIndex });
                } else {
                    --bigIndex;
                    --smlIndex;
                    if (!options['sparse']) {
                        editScript.push({
                            'status': "retained",
                            'value': bigArray[bigIndex] });
                    }
                }
            }
    
            // Set a limit on the number of consecutive non-matching comparisons; having it a multiple of
            // smlIndexMax keeps the time complexity of this algorithm linear.
            ko.utils.findMovesInArrayComparison(notInBig, notInSml, !options['dontLimitMoves'] && smlIndexMax * 10);
    
            return editScript.reverse();
        }
    
        return compareArrays;
    })();
    
    ko.exportSymbol('utils.compareArrays', ko.utils.compareArrays);
    (function () {
        // Objective:
        // * Given an input array, a container DOM node, and a function from array elements to arrays of DOM nodes,
        //   map the array elements to arrays of DOM nodes, concatenate together all these arrays, and use them to populate the container DOM node
        // * Next time we're given the same combination of things (with the array possibly having mutated), update the container DOM node
        //   so that its children is again the concatenation of the mappings of the array elements, but don't re-map any array elements that we
        //   previously mapped - retain those nodes, and just insert/delete other ones
    
        // "callbackAfterAddingNodes" will be invoked after any "mapping"-generated nodes are inserted into the container node
        // You can use this, for example, to activate bindings on those nodes.
    
        function mapNodeAndRefreshWhenChanged(containerNode, mapping, valueToMap, callbackAfterAddingNodes, index) {
            // Map this array value inside a dependentObservable so we re-map when any dependency changes
            var mappedNodes = [];
            var dependentObservable = ko.dependentObservable(function() {
                var newMappedNodes = mapping(valueToMap, index, ko.utils.fixUpContinuousNodeArray(mappedNodes, containerNode)) || [];
    
                // On subsequent evaluations, just replace the previously-inserted DOM nodes
                if (mappedNodes.length > 0) {
                    ko.utils.replaceDomNodes(mappedNodes, newMappedNodes);
                    if (callbackAfterAddingNodes)
                        ko.dependencyDetection.ignore(callbackAfterAddingNodes, null, [valueToMap, newMappedNodes, index]);
                }
    
                // Replace the contents of the mappedNodes array, thereby updating the record
                // of which nodes would be deleted if valueToMap was itself later removed
                mappedNodes.length = 0;
                ko.utils.arrayPushAll(mappedNodes, newMappedNodes);
            }, null, { disposeWhenNodeIsRemoved: containerNode, disposeWhen: function() { return !ko.utils.anyDomNodeIsAttachedToDocument(mappedNodes); } });
            return { mappedNodes : mappedNodes, dependentObservable : (dependentObservable.isActive() ? dependentObservable : undefined) };
        }
    
        var lastMappingResultDomDataKey = ko.utils.domData.nextKey(),
            deletedItemDummyValue = ko.utils.domData.nextKey();
    
        ko.utils.setDomNodeChildrenFromArrayMapping = function (domNode, array, mapping, options, callbackAfterAddingNodes) {
            // Compare the provided array against the previous one
            array = array || [];
            options = options || {};
            var isFirstExecution = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) === undefined;
            var lastMappingResult = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) || [];
            var lastArray = ko.utils.arrayMap(lastMappingResult, function (x) { return x.arrayEntry; });
            var editScript = ko.utils.compareArrays(lastArray, array, options['dontLimitMoves']);
    
            // Build the new mapping result
            var newMappingResult = [];
            var lastMappingResultIndex = 0;
            var newMappingResultIndex = 0;
    
            var nodesToDelete = [];
            var itemsToProcess = [];
            var itemsForBeforeRemoveCallbacks = [];
            var itemsForMoveCallbacks = [];
            var itemsForAfterAddCallbacks = [];
            var mapData;
    
            function itemMovedOrRetained(editScriptIndex, oldPosition) {
                mapData = lastMappingResult[oldPosition];
                if (newMappingResultIndex !== oldPosition)
                    itemsForMoveCallbacks[editScriptIndex] = mapData;
                // Since updating the index might change the nodes, do so before calling fixUpContinuousNodeArray
                mapData.indexObservable(newMappingResultIndex++);
                ko.utils.fixUpContinuousNodeArray(mapData.mappedNodes, domNode);
                newMappingResult.push(mapData);
                itemsToProcess.push(mapData);
            }
    
            function callCallback(callback, items) {
                if (callback) {
                    for (var i = 0, n = items.length; i < n; i++) {
                        if (items[i]) {
                            ko.utils.arrayForEach(items[i].mappedNodes, function(node) {
                                callback(node, i, items[i].arrayEntry);
                            });
                        }
                    }
                }
            }
    
            for (var i = 0, editScriptItem, movedIndex; editScriptItem = editScript[i]; i++) {
                movedIndex = editScriptItem['moved'];
                switch (editScriptItem['status']) {
                    case "deleted":
                        if (movedIndex === undefined) {
                            mapData = lastMappingResult[lastMappingResultIndex];
    
                            // Stop tracking changes to the mapping for these nodes
                            if (mapData.dependentObservable) {
                                mapData.dependentObservable.dispose();
                                mapData.dependentObservable = undefined;
                            }
    
                            // Queue these nodes for later removal
                            if (ko.utils.fixUpContinuousNodeArray(mapData.mappedNodes, domNode).length) {
                                if (options['beforeRemove']) {
                                    newMappingResult.push(mapData);
                                    itemsToProcess.push(mapData);
                                    if (mapData.arrayEntry === deletedItemDummyValue) {
                                        mapData = null;
                                    } else {
                                        itemsForBeforeRemoveCallbacks[i] = mapData;
                                    }
                                }
                                if (mapData) {
                                    nodesToDelete.push.apply(nodesToDelete, mapData.mappedNodes);
                                }
                            }
                        }
                        lastMappingResultIndex++;
                        break;
    
                    case "retained":
                        itemMovedOrRetained(i, lastMappingResultIndex++);
                        break;
    
                    case "added":
                        if (movedIndex !== undefined) {
                            itemMovedOrRetained(i, movedIndex);
                        } else {
                            mapData = { arrayEntry: editScriptItem['value'], indexObservable: ko.observable(newMappingResultIndex++) };
                            newMappingResult.push(mapData);
                            itemsToProcess.push(mapData);
                            if (!isFirstExecution)
                                itemsForAfterAddCallbacks[i] = mapData;
                        }
                        break;
                }
            }
    
            // Store a copy of the array items we just considered so we can difference it next time
            ko.utils.domData.set(domNode, lastMappingResultDomDataKey, newMappingResult);
    
            // Call beforeMove first before any changes have been made to the DOM
            callCallback(options['beforeMove'], itemsForMoveCallbacks);
    
            // Next remove nodes for deleted items (or just clean if there's a beforeRemove callback)
            ko.utils.arrayForEach(nodesToDelete, options['beforeRemove'] ? ko.cleanNode : ko.removeNode);
    
            // Next add/reorder the remaining items (will include deleted items if there's a beforeRemove callback)
            for (var i = 0, nextNode = ko.virtualElements.firstChild(domNode), lastNode, node; mapData = itemsToProcess[i]; i++) {
                // Get nodes for newly added items
                if (!mapData.mappedNodes)
                    ko.utils.extend(mapData, mapNodeAndRefreshWhenChanged(domNode, mapping, mapData.arrayEntry, callbackAfterAddingNodes, mapData.indexObservable));
    
                // Put nodes in the right place if they aren't there already
                for (var j = 0; node = mapData.mappedNodes[j]; nextNode = node.nextSibling, lastNode = node, j++) {
                    if (node !== nextNode)
                        ko.virtualElements.insertAfter(domNode, node, lastNode);
                }
    
                // Run the callbacks for newly added nodes (for example, to apply bindings, etc.)
                if (!mapData.initialized && callbackAfterAddingNodes) {
                    callbackAfterAddingNodes(mapData.arrayEntry, mapData.mappedNodes, mapData.indexObservable);
                    mapData.initialized = true;
                }
            }
    
            // If there's a beforeRemove callback, call it after reordering.
            // Note that we assume that the beforeRemove callback will usually be used to remove the nodes using
            // some sort of animation, which is why we first reorder the nodes that will be removed. If the
            // callback instead removes the nodes right away, it would be more efficient to skip reordering them.
            // Perhaps we'll make that change in the future if this scenario becomes more common.
            callCallback(options['beforeRemove'], itemsForBeforeRemoveCallbacks);
    
            // Replace the stored values of deleted items with a dummy value. This provides two benefits: it marks this item
            // as already "removed" so we won't call beforeRemove for it again, and it ensures that the item won't match up
            // with an actual item in the array and appear as "retained" or "moved".
            for (i = 0; i < itemsForBeforeRemoveCallbacks.length; ++i) {
                if (itemsForBeforeRemoveCallbacks[i]) {
                    itemsForBeforeRemoveCallbacks[i].arrayEntry = deletedItemDummyValue;
                }
            }
    
            // Finally call afterMove and afterAdd callbacks
            callCallback(options['afterMove'], itemsForMoveCallbacks);
            callCallback(options['afterAdd'], itemsForAfterAddCallbacks);
        }
    })();
    
    ko.exportSymbol('utils.setDomNodeChildrenFromArrayMapping', ko.utils.setDomNodeChildrenFromArrayMapping);
    ko.nativeTemplateEngine = function () {
        this['allowTemplateRewriting'] = false;
    }
    
    ko.nativeTemplateEngine.prototype = new ko.templateEngine();
    ko.nativeTemplateEngine.prototype.constructor = ko.nativeTemplateEngine;
    ko.nativeTemplateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options, templateDocument) {
        var useNodesIfAvailable = !(ko.utils.ieVersion < 9), // IE<9 cloneNode doesn't work properly
            templateNodesFunc = useNodesIfAvailable ? templateSource['nodes'] : null,
            templateNodes = templateNodesFunc ? templateSource['nodes']() : null;
    
        if (templateNodes) {
            return ko.utils.makeArray(templateNodes.cloneNode(true).childNodes);
        } else {
            var templateText = templateSource['text']();
            return ko.utils.parseHtmlFragment(templateText, templateDocument);
        }
    };
    
    ko.nativeTemplateEngine.instance = new ko.nativeTemplateEngine();
    ko.setTemplateEngine(ko.nativeTemplateEngine.instance);
    
    ko.exportSymbol('nativeTemplateEngine', ko.nativeTemplateEngine);
    (function() {
        ko.jqueryTmplTemplateEngine = function () {
            // Detect which version of jquery-tmpl you're using. Unfortunately jquery-tmpl
            // doesn't expose a version number, so we have to infer it.
            // Note that as of Knockout 1.3, we only support jQuery.tmpl 1.0.0pre and later,
            // which KO internally refers to as version "2", so older versions are no longer detected.
            var jQueryTmplVersion = this.jQueryTmplVersion = (function() {
                if (!jQueryInstance || !(jQueryInstance['tmpl']))
                    return 0;
                // Since it exposes no official version number, we use our own numbering system. To be updated as jquery-tmpl evolves.
                try {
                    if (jQueryInstance['tmpl']['tag']['tmpl']['open'].toString().indexOf('__') >= 0) {
                        // Since 1.0.0pre, custom tags should append markup to an array called "__"
                        return 2; // Final version of jquery.tmpl
                    }
                } catch(ex) { /* Apparently not the version we were looking for */ }
    
                return 1; // Any older version that we don't support
            })();
    
            function ensureHasReferencedJQueryTemplates() {
                if (jQueryTmplVersion < 2)
                    throw new Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");
            }
    
            function executeTemplate(compiledTemplate, data, jQueryTemplateOptions) {
                return jQueryInstance['tmpl'](compiledTemplate, data, jQueryTemplateOptions);
            }
    
            this['renderTemplateSource'] = function(templateSource, bindingContext, options, templateDocument) {
                templateDocument = templateDocument || document;
                options = options || {};
                ensureHasReferencedJQueryTemplates();
    
                // Ensure we have stored a precompiled version of this template (don't want to reparse on every render)
                var precompiled = templateSource['data']('precompiled');
                if (!precompiled) {
                    var templateText = templateSource['text']() || "";
                    // Wrap in "with($whatever.koBindingContext) { ... }"
                    templateText = "{{ko_with $item.koBindingContext}}" + templateText + "{{/ko_with}}";
    
                    precompiled = jQueryInstance['template'](null, templateText);
                    templateSource['data']('precompiled', precompiled);
                }
    
                var data = [bindingContext['$data']]; // Prewrap the data in an array to stop jquery.tmpl from trying to unwrap any arrays
                var jQueryTemplateOptions = jQueryInstance['extend']({ 'koBindingContext': bindingContext }, options['templateOptions']);
    
                var resultNodes = executeTemplate(precompiled, data, jQueryTemplateOptions);
                resultNodes['appendTo'](templateDocument.createElement("div")); // Using "appendTo" forces jQuery/jQuery.tmpl to perform necessary cleanup work
    
                jQueryInstance['fragments'] = {}; // Clear jQuery's fragment cache to avoid a memory leak after a large number of template renders
                return resultNodes;
            };
    
            this['createJavaScriptEvaluatorBlock'] = function(script) {
                return "{{ko_code ((function() { return " + script + " })()) }}";
            };
    
            this['addTemplate'] = function(templateName, templateMarkup) {
                document.write("<script type='text/html' id='" + templateName + "'>" + templateMarkup + "<" + "/script>");
            };
    
            if (jQueryTmplVersion > 0) {
                jQueryInstance['tmpl']['tag']['ko_code'] = {
                    open: "__.push($1 || '');"
                };
                jQueryInstance['tmpl']['tag']['ko_with'] = {
                    open: "with($1) {",
                    close: "} "
                };
            }
        };
    
        ko.jqueryTmplTemplateEngine.prototype = new ko.templateEngine();
        ko.jqueryTmplTemplateEngine.prototype.constructor = ko.jqueryTmplTemplateEngine;
    
        // Use this one by default *only if jquery.tmpl is referenced*
        var jqueryTmplTemplateEngineInstance = new ko.jqueryTmplTemplateEngine();
        if (jqueryTmplTemplateEngineInstance.jQueryTmplVersion > 0)
            ko.setTemplateEngine(jqueryTmplTemplateEngineInstance);
    
        ko.exportSymbol('jqueryTmplTemplateEngine', ko.jqueryTmplTemplateEngine);
    })();
    }));
    }());
    })();
    
    },{}],65:[function(require,module,exports){
    //! moment.js
    //! version : 2.19.1
    //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
    //! license : MIT
    //! momentjs.com
    
    ;(function (global, factory) {
        typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
        typeof define === 'function' && define.amd ? define(factory) :
        global.moment = factory()
    }(this, (function () { 'use strict';
    
    var hookCallback;
    
    function hooks () {
        return hookCallback.apply(null, arguments);
    }
    
    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }
    
    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }
    
    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }
    
    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return (Object.getOwnPropertyNames(obj).length === 0);
        } else {
            var k;
            for (k in obj) {
                if (obj.hasOwnProperty(k)) {
                    return false;
                }
            }
            return true;
        }
    }
    
    function isUndefined(input) {
        return input === void 0;
    }
    
    function isNumber(input) {
        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }
    
    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }
    
    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }
    
    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }
    
    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }
    
        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }
    
        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }
    
        return a;
    }
    
    function createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }
    
    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false,
            parsedDateParts : [],
            meridiem        : null,
            rfc2822         : false,
            weekdayMismatch : false
        };
    }
    
    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }
    
    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;
    
            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }
    
            return false;
        };
    }
    
    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            var isNowValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.weekdayMismatch &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));
    
            if (m._strict) {
                isNowValid = isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }
    
            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            }
            else {
                return isNowValid;
            }
        }
        return m._isValid;
    }
    
    function createInvalid (flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }
    
        return m;
    }
    
    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = hooks.momentProperties = [];
    
    function copyConfig(to, from) {
        var i, prop, val;
    
        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }
    
        if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }
    
        return to;
    }
    
    var updateInProgress = false;
    
    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }
    
    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }
    
    function absFloor (number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }
    
    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;
    
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }
    
        return value;
    }
    
    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }
    
    function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }
    
    function deprecate(msg, fn) {
        var firstTime = true;
    
        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [];
                var arg;
                for (var i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (var key in arguments[0]) {
                            arg += key + ': ' + arguments[0][key] + ', ';
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }
    
    var deprecations = {};
    
    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }
    
    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;
    
    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }
    
    function set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' + (/\d{1,2}/).source);
    }
    
    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }
    
    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }
    
    var keys;
    
    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }
    
    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };
    
    function calendar (key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }
    
    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };
    
    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];
    
        if (format || !formatUpper) {
            return format;
        }
    
        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });
    
        return this._longDateFormat[key];
    }
    
    var defaultInvalidDate = 'Invalid date';
    
    function invalidDate () {
        return this._invalidDate;
    }
    
    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;
    
    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }
    
    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        ss : '%d seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };
    
    function relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }
    
    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }
    
    var aliases = {};
    
    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }
    
    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }
    
    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;
    
        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }
    
        return normalizedInput;
    }
    
    var priorities = {};
    
    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }
    
    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({unit: u, priority: priorities[u]});
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }
    
    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }
    
    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
    
    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
    
    var formatFunctions = {};
    
    var formatTokenFunctions = {};
    
    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }
    
    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }
    
    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;
    
        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }
    
        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }
    
    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }
    
        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
    
        return formatFunctions[format](m);
    }
    
    function expandFormat(format, locale) {
        var i = 5;
    
        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }
    
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }
    
        return format;
    }
    
    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999
    
    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf
    
    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z
    
    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
    
    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
    
    
    var regexes = {};
    
    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }
    
    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }
    
        return regexes[token](config._strict, config._locale);
    }
    
    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }
    
    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }
    
    var tokens = {};
    
    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }
    
    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }
    
    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }
    
    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;
    
    // FORMATTING
    
    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });
    
    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });
    
    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');
    
    // ALIASES
    
    addUnitAlias('year', 'y');
    
    // PRIORITIES
    
    addUnitPriority('year', 1);
    
    // PARSING
    
    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);
    
    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });
    
    // HELPERS
    
    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }
    
    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }
    
    // HOOKS
    
    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };
    
    // MOMENTS
    
    var getSetYear = makeGetSet('FullYear', true);
    
    function getIsLeapYear () {
        return isLeapYear(this.year());
    }
    
    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }
    
    function get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }
    
    function set$1 (mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (unit === 'FullYear' && isLeapYear(mom.year())) {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
            }
            else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }
    
    // MOMENTS
    
    function stringGet (units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }
    
    
    function stringSet (units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }
    
    function mod(n, x) {
        return ((n % x) + x) % x;
    }
    
    var indexOf;
    
    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }
    
    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
    }
    
    // FORMATTING
    
    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });
    
    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });
    
    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });
    
    // ALIASES
    
    addUnitAlias('month', 'M');
    
    // PRIORITY
    
    addUnitPriority('month', 8);
    
    // PARSING
    
    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });
    
    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });
    
    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });
    
    // LOCALES
    
    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        if (!m) {
            return isArray(this._months) ? this._months :
                this._months['standalone'];
        }
        return isArray(this._months) ? this._months[m.month()] :
            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }
    
    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort :
                this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }
    
    function handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }
    
        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }
    
    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;
    
        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }
    
        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }
    
        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }
    
    // MOMENTS
    
    function setMonth (mom, value) {
        var dayOfMonth;
    
        if (!mom.isValid()) {
            // No op
            return mom;
        }
    
        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }
    
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }
    
    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }
    
    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }
    
    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }
    
    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }
    
    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }
    
        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }
    
        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }
    
    function createDate (y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date = new Date(y, m, d, h, M, s, ms);
    
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
            date.setFullYear(y);
        }
        return date;
    }
    
    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));
    
        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
        }
        return date;
    }
    
    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
    
        return -fwdlw + fwd - 1;
    }
    
    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;
    
        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }
    
        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }
    
    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;
    
        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }
    
        return {
            week: resWeek,
            year: resYear
        };
    }
    
    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }
    
    // FORMATTING
    
    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');
    
    // ALIASES
    
    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');
    
    // PRIORITIES
    
    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);
    
    // PARSING
    
    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);
    
    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });
    
    // HELPERS
    
    // LOCALES
    
    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    
    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };
    
    function localeFirstDayOfWeek () {
        return this._week.dow;
    }
    
    function localeFirstDayOfYear () {
        return this._week.doy;
    }
    
    // MOMENTS
    
    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }
    
    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }
    
    // FORMATTING
    
    addFormatToken('d', 0, 'do', 'day');
    
    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });
    
    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });
    
    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });
    
    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');
    
    // ALIASES
    
    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');
    
    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);
    
    // PARSING
    
    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd',   function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd',   function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });
    
    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });
    
    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });
    
    // HELPERS
    
    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }
    
        if (!isNaN(input)) {
            return parseInt(input, 10);
        }
    
        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }
    
        return null;
    }
    
    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }
    
    // LOCALES
    
    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        if (!m) {
            return isArray(this._weekdays) ? this._weekdays :
                this._weekdays['standalone'];
        }
        return isArray(this._weekdays) ? this._weekdays[m.day()] :
            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
    }
    
    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }
    
    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }
    
    function handleStrictParse$1(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];
    
            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }
    
        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }
    
    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;
    
        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }
    
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }
    
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
    
            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }
    
    // MOMENTS
    
    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }
    
    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }
    
    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
    
        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.
    
        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }
    
    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }
    
    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }
    
    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }
    
    
    function computeWeekdaysParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }
    
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }
    
        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
    
        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }
    
    // FORMATTING
    
    function hFormat() {
        return this.hours() % 12 || 12;
    }
    
    function kFormat() {
        return this.hours() || 24;
    }
    
    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);
    
    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    
    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });
    
    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });
    
    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });
    
    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }
    
    meridiem('a', true);
    meridiem('A', false);
    
    // ALIASES
    
    addUnitAlias('hour', 'h');
    
    // PRIORITY
    addUnitPriority('hour', 13);
    
    // PARSING
    
    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }
    
    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('k',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);
    
    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);
    
    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });
    
    // LOCALES
    
    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }
    
    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }
    
    
    // MOMENTS
    
    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);
    
    // months
    // week
    // weekdays
    // meridiem
    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
    
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
    
        week: defaultLocaleWeek,
    
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
    
        meridiemParse: defaultLocaleMeridiemParse
    };
    
    // internal storage for locale config files
    var locales = {};
    var localeFamilies = {};
    var globalLocale;
    
    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }
    
    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;
    
        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }
    
    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                var aliasedRequire = require;
                aliasedRequire('./locale/' + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }
    
    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }
    
            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
        }
    
        return globalLocale._abbr;
    }
    
    function defineLocale (name, config) {
        if (config !== null) {
            var parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    if (!localeFamilies[config.parentLocale]) {
                        localeFamilies[config.parentLocale] = [];
                    }
                    localeFamilies[config.parentLocale].push({
                        name: name,
                        config: config
                    });
                    return null;
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));
    
            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }
    
            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);
    
    
            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }
    
    function updateLocale(name, config) {
        if (config != null) {
            var locale, parentConfig = baseConfig;
            // MERGE
            if (locales[name] != null) {
                parentConfig = locales[name]._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;
    
            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }
    
    // returns locale data
    function getLocale (key) {
        var locale;
    
        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }
    
        if (!key) {
            return globalLocale;
        }
    
        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }
    
        return chooseLocale(key);
    }
    
    function listLocales() {
        return keys(locales);
    }
    
    function checkOverflow (m) {
        var overflow;
        var a = m._a;
    
        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;
    
            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }
    
            getParsingFlags(m).overflow = overflow;
        }
    
        return m;
    }
    
    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }
    
    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }
    
    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, yearToUse;
    
        if (config._d) {
            return;
        }
    
        currentDate = currentDateArray(config);
    
        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }
    
        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
    
            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }
    
            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }
    
        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }
    
        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }
    
        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }
    
        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
    
        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    
        // check for mismatching day of week
        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== config._d.getDay()) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }
    
    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
    
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;
    
            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
    
            var curWeek = weekOfYear(createLocal(), dow, doy);
    
            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
    
            // Default to current week.
            week = defaults(w.w, curWeek.week);
    
            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }
    
    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    
    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
    
    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];
    
    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];
    
    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
    
    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;
    
        if (match) {
            getParsingFlags(config).iso = true;
    
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }
    
    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;
    
    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
        ];
    
        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }
    
        return result;
    }
    
    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }
    
    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').trim();
    }
    
    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }
    
    var obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
    };
    
    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10);
            var m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
        }
    }
    
    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i));
        if (match) {
            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }
    
            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);
    
            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    
            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }
    
    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
    
        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }
    
        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }
    
        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }
    
        // Final attempt, use Input Fallback
        hooks.createFromInputFallback(config);
    }
    
    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
        'discouraged and will be removed in an upcoming major release. Please refer to ' +
        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );
    
    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};
    
    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};
    
    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
    
        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;
    
        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
    
        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }
    
        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }
    
        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }
    
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
    
        configFromArray(config);
        checkOverflow(config);
    }
    
    
    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;
    
        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }
    
    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,
    
            scoreToBeat,
            i,
            currentScore;
    
        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }
    
        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);
    
            if (!isValid(tempConfig)) {
                continue;
            }
    
            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;
    
            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
    
            getParsingFlags(tempConfig).score = currentScore;
    
            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }
    
        extend(config, bestMoment || tempConfig);
    }
    
    function configFromObject(config) {
        if (config._d) {
            return;
        }
    
        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });
    
        configFromArray(config);
    }
    
    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }
    
        return res;
    }
    
    function prepareConfig (config) {
        var input = config._i,
            format = config._f;
    
        config._locale = config._locale || getLocale(config._l);
    
        if (input === null || (format === undefined && input === '')) {
            return createInvalid({nullInput: true});
        }
    
        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }
    
        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        }  else {
            configFromInput(config);
        }
    
        if (!isValid(config)) {
            config._d = null;
        }
    
        return config;
    }
    
    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }
    
    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};
    
        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }
    
        if ((isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
    
        return createFromConfig(c);
    }
    
    function createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }
    
    var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other < this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );
    
    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );
    
    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }
    
    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);
    
        return pickBy('isBefore', args);
    }
    
    function max () {
        var args = [].slice.call(arguments, 0);
    
        return pickBy('isAfter', args);
    }
    
    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };
    
    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];
    
    function isDurationValid(m) {
        for (var key in m) {
            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                return false;
            }
        }
    
        var unitHasDecimal = false;
        for (var i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }
    
        return true;
    }
    
    function isValid$1() {
        return this._isValid;
    }
    
    function createInvalid$1() {
        return createDuration(NaN);
    }
    
    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;
    
        this._isValid = isDurationValid(normalizedInput);
    
        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;
    
        this._data = {};
    
        this._locale = getLocale();
    
        this._bubble();
    }
    
    function isDuration (obj) {
        return obj instanceof Duration;
    }
    
    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }
    
    // FORMATTING
    
    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }
    
    offset('Z', ':');
    offset('ZZ', '');
    
    // PARSING
    
    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });
    
    // HELPERS
    
    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;
    
    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher);
    
        if (matches === null) {
            return null;
        }
    
        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);
    
        return minutes === 0 ?
          0 :
          parts[0] === '+' ? minutes : -minutes;
    }
    
    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }
    
    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }
    
    // HOOKS
    
    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};
    
    // MOMENTS
    
    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }
    
    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }
    
            this.utcOffset(input, keepLocalTime);
    
            return this;
        } else {
            return -this.utcOffset();
        }
    }
    
    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }
    
    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;
    
            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }
    
    function setOffsetToParsedOffset () {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            }
            else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }
    
    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
    
        return (this.utcOffset() - input) % 60 === 0;
    }
    
    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }
    
    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }
    
        var c = {};
    
        copyConfig(c, this);
        c = prepareConfig(c);
    
        if (c._a) {
            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }
    
        return this._isDSTShifted;
    }
    
    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }
    
    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }
    
    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }
    
    // ASP.NET json date format regex
    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;
    
    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    
    function createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;
    
        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (isNumber(input)) {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])                         * sign,
                h  : toInt(match[HOUR])                         * sign,
                m  : toInt(match[MINUTE])                       * sign,
                s  : toInt(match[SECOND])                       * sign,
                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
    
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }
    
        ret = new Duration(duration);
    
        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }
    
        return ret;
    }
    
    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;
    
    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }
    
    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};
    
        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }
    
        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));
    
        return res;
    }
    
    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }
    
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }
    
        return res;
    }
    
    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val; val = period; period = tmp;
            }
    
            val = typeof val === 'string' ? +val : val;
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }
    
    function addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);
    
        if (!mom.isValid()) {
            // No op
            return;
        }
    
        updateOffset = updateOffset == null ? true : updateOffset;
    
        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }
    
    var add      = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');
    
    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
    }
    
    function calendar$1 (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse';
    
        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
    
        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }
    
    function clone () {
        return new Moment(this);
    }
    
    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }
    
    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }
    
    function isBetween (from, to, units, inclusivity) {
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
    }
    
    function isSame (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }
    
    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input,units);
    }
    
    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input,units);
    }
    
    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            delta, output;
    
        if (!this.isValid()) {
            return NaN;
        }
    
        that = cloneWithOffset(input, this);
    
        if (!that.isValid()) {
            return NaN;
        }
    
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
    
        units = normalizeUnits(units);
    
        switch (units) {
            case 'year': output = monthDiff(this, that) / 12; break;
            case 'month': output = monthDiff(this, that); break;
            case 'quarter': output = monthDiff(this, that) / 3; break;
            case 'second': output = (this - that) / 1e3; break; // 1000
            case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
            case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
            case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
            case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default: output = this - that;
        }
    
        return asFloat ? output : absFloor(output);
    }
    
    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;
    
        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }
    
        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }
    
    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';
    
    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }
    
    function toISOString() {
        if (!this.isValid()) {
            return null;
        }
        var m = this.clone().utc();
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            return this.toDate().toISOString();
        }
        return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
    }
    
    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect () {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment';
        var zone = '';
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        var prefix = '[' + func + '("]';
        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
        var datetime = '-MM-DD[T]HH:mm:ss.SSS';
        var suffix = zone + '[")]';
    
        return this.format(prefix + year + datetime + suffix);
    }
    
    function format (inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }
    
    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }
    
    function fromNow (withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }
    
    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }
    
    function toNow (withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }
    
    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;
    
        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }
    
    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );
    
    function localeData () {
        return this._locale;
    }
    
    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'quarter':
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
            case 'date':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
        }
    
        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }
    
        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }
    
        return this;
    }
    
    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }
    
        // 'date' is an alias for 'day', so it should be considered as such.
        if (units === 'date') {
            units = 'day';
        }
    
        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }
    
    function valueOf () {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }
    
    function unix () {
        return Math.floor(this.valueOf() / 1000);
    }
    
    function toDate () {
        return new Date(this.valueOf());
    }
    
    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }
    
    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }
    
    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }
    
    function isValid$2 () {
        return isValid(this);
    }
    
    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }
    
    function invalidAt () {
        return getParsingFlags(this).overflow;
    }
    
    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }
    
    // FORMATTING
    
    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });
    
    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });
    
    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }
    
    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');
    
    // ALIASES
    
    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');
    
    // PRIORITY
    
    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);
    
    
    // PARSING
    
    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);
    
    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });
    
    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });
    
    // MOMENTS
    
    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }
    
    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }
    
    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }
    
    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    
    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }
    
    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
    
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }
    
    // FORMATTING
    
    addFormatToken('Q', 0, 'Qo', 'quarter');
    
    // ALIASES
    
    addUnitAlias('quarter', 'Q');
    
    // PRIORITY
    
    addUnitPriority('quarter', 7);
    
    // PARSING
    
    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });
    
    // MOMENTS
    
    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }
    
    // FORMATTING
    
    addFormatToken('D', ['DD', 2], 'Do', 'date');
    
    // ALIASES
    
    addUnitAlias('date', 'D');
    
    // PRIOROITY
    addUnitPriority('date', 9);
    
    // PARSING
    
    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict ?
          (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
          locale._dayOfMonthOrdinalParseLenient;
    });
    
    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });
    
    // MOMENTS
    
    var getSetDayOfMonth = makeGetSet('Date', true);
    
    // FORMATTING
    
    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');
    
    // ALIASES
    
    addUnitAlias('dayOfYear', 'DDD');
    
    // PRIORITY
    addUnitPriority('dayOfYear', 4);
    
    // PARSING
    
    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });
    
    // HELPERS
    
    // MOMENTS
    
    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }
    
    // FORMATTING
    
    addFormatToken('m', ['mm', 2], 0, 'minute');
    
    // ALIASES
    
    addUnitAlias('minute', 'm');
    
    // PRIORITY
    
    addUnitPriority('minute', 14);
    
    // PARSING
    
    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);
    
    // MOMENTS
    
    var getSetMinute = makeGetSet('Minutes', false);
    
    // FORMATTING
    
    addFormatToken('s', ['ss', 2], 0, 'second');
    
    // ALIASES
    
    addUnitAlias('second', 's');
    
    // PRIORITY
    
    addUnitPriority('second', 15);
    
    // PARSING
    
    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);
    
    // MOMENTS
    
    var getSetSecond = makeGetSet('Seconds', false);
    
    // FORMATTING
    
    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });
    
    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });
    
    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });
    
    
    // ALIASES
    
    addUnitAlias('millisecond', 'ms');
    
    // PRIORITY
    
    addUnitPriority('millisecond', 16);
    
    // PARSING
    
    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);
    
    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }
    
    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }
    
    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS
    
    var getSetMillisecond = makeGetSet('Milliseconds', false);
    
    // FORMATTING
    
    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');
    
    // MOMENTS
    
    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }
    
    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }
    
    var proto = Moment.prototype;
    
    proto.add               = add;
    proto.calendar          = calendar$1;
    proto.clone             = clone;
    proto.diff              = diff;
    proto.endOf             = endOf;
    proto.format            = format;
    proto.from              = from;
    proto.fromNow           = fromNow;
    proto.to                = to;
    proto.toNow             = toNow;
    proto.get               = stringGet;
    proto.invalidAt         = invalidAt;
    proto.isAfter           = isAfter;
    proto.isBefore          = isBefore;
    proto.isBetween         = isBetween;
    proto.isSame            = isSame;
    proto.isSameOrAfter     = isSameOrAfter;
    proto.isSameOrBefore    = isSameOrBefore;
    proto.isValid           = isValid$2;
    proto.lang              = lang;
    proto.locale            = locale;
    proto.localeData        = localeData;
    proto.max               = prototypeMax;
    proto.min               = prototypeMin;
    proto.parsingFlags      = parsingFlags;
    proto.set               = stringSet;
    proto.startOf           = startOf;
    proto.subtract          = subtract;
    proto.toArray           = toArray;
    proto.toObject          = toObject;
    proto.toDate            = toDate;
    proto.toISOString       = toISOString;
    proto.inspect           = inspect;
    proto.toJSON            = toJSON;
    proto.toString          = toString;
    proto.unix              = unix;
    proto.valueOf           = valueOf;
    proto.creationData      = creationData;
    
    // Year
    proto.year       = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    
    // Week Year
    proto.weekYear    = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    
    // Quarter
    proto.quarter = proto.quarters = getSetQuarter;
    
    // Month
    proto.month       = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    
    // Week
    proto.week           = proto.weeks        = getSetWeek;
    proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
    proto.weeksInYear    = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    
    // Day
    proto.date       = getSetDayOfMonth;
    proto.day        = proto.days             = getSetDayOfWeek;
    proto.weekday    = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear  = getSetDayOfYear;
    
    // Hour
    proto.hour = proto.hours = getSetHour;
    
    // Minute
    proto.minute = proto.minutes = getSetMinute;
    
    // Second
    proto.second = proto.seconds = getSetSecond;
    
    // Millisecond
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    
    // Offset
    proto.utcOffset            = getSetOffset;
    proto.utc                  = setOffsetToUTC;
    proto.local                = setOffsetToLocal;
    proto.parseZone            = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST                = isDaylightSavingTime;
    proto.isLocal              = isLocal;
    proto.isUtcOffset          = isUtcOffset;
    proto.isUtc                = isUtc;
    proto.isUTC                = isUtc;
    
    // Timezone
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    
    // Deprecations
    proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);
    
    function createUnix (input) {
        return createLocal(input * 1000);
    }
    
    function createInZone () {
        return createLocal.apply(null, arguments).parseZone();
    }
    
    function preParsePostFormat (string) {
        return string;
    }
    
    var proto$1 = Locale.prototype;
    
    proto$1.calendar        = calendar;
    proto$1.longDateFormat  = longDateFormat;
    proto$1.invalidDate     = invalidDate;
    proto$1.ordinal         = ordinal;
    proto$1.preparse        = preParsePostFormat;
    proto$1.postformat      = preParsePostFormat;
    proto$1.relativeTime    = relativeTime;
    proto$1.pastFuture      = pastFuture;
    proto$1.set             = set;
    
    // Month
    proto$1.months            =        localeMonths;
    proto$1.monthsShort       =        localeMonthsShort;
    proto$1.monthsParse       =        localeMonthsParse;
    proto$1.monthsRegex       = monthsRegex;
    proto$1.monthsShortRegex  = monthsShortRegex;
    
    // Week
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    
    // Day of Week
    proto$1.weekdays       =        localeWeekdays;
    proto$1.weekdaysMin    =        localeWeekdaysMin;
    proto$1.weekdaysShort  =        localeWeekdaysShort;
    proto$1.weekdaysParse  =        localeWeekdaysParse;
    
    proto$1.weekdaysRegex       =        weekdaysRegex;
    proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;
    
    // Hours
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;
    
    function get$1 (format, index, field, setter) {
        var locale = getLocale();
        var utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }
    
    function listMonthsImpl (format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }
    
        format = format || '';
    
        if (index != null) {
            return get$1(format, index, field, 'month');
        }
    
        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }
    
    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl (localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }
    
            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;
    
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }
    
            format = format || '';
        }
    
        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0;
    
        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }
    
        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }
    
    function listMonths (format, index) {
        return listMonthsImpl(format, index, 'months');
    }
    
    function listMonthsShort (format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }
    
    function listWeekdays (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }
    
    function listWeekdaysShort (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }
    
    function listWeekdaysMin (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }
    
    getSetGlobalLocale('en', {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });
    
    // Side effect imports
    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
    
    var mathAbs = Math.abs;
    
    function abs () {
        var data           = this._data;
    
        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);
    
        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);
    
        return this;
    }
    
    function addSubtract$1 (duration, input, value, direction) {
        var other = createDuration(input, value);
    
        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;
    
        return duration._bubble();
    }
    
    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1 (input, value) {
        return addSubtract$1(this, input, value, 1);
    }
    
    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1 (input, value) {
        return addSubtract$1(this, input, value, -1);
    }
    
    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }
    
    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;
    
        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }
    
        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;
    
        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;
    
        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;
    
        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;
    
        days += absFloor(hours / 24);
    
        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));
    
        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;
    
        data.days   = days;
        data.months = months;
        data.years  = years;
    
        return this;
    }
    
    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }
    
    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }
    
    function as (units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days;
        var months;
        var milliseconds = this._milliseconds;
    
        units = normalizeUnits(units);
    
        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }
    
    // TODO: Use this.as('ms')?
    function valueOf$1 () {
        if (!this.isValid()) {
            return NaN;
        }
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }
    
    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }
    
    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');
    
    function clone$1 () {
        return createDuration(this);
    }
    
    function get$2 (units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }
    
    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }
    
    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');
    
    function weeks () {
        return absFloor(this.days() / 7);
    }
    
    var round = Math.round;
    var thresholds = {
        ss: 44,         // a few seconds to seconds
        s : 45,         // seconds to minute
        m : 45,         // minutes to hour
        h : 22,         // hours to day
        d : 26,         // days to month
        M : 11          // months to year
    };
    
    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    
    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
        var duration = createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));
    
        var a = seconds <= thresholds.ss && ['s', seconds]  ||
                seconds < thresholds.s   && ['ss', seconds] ||
                minutes <= 1             && ['m']           ||
                minutes < thresholds.m   && ['mm', minutes] ||
                hours   <= 1             && ['h']           ||
                hours   < thresholds.h   && ['hh', hours]   ||
                days    <= 1             && ['d']           ||
                days    < thresholds.d   && ['dd', days]    ||
                months  <= 1             && ['M']           ||
                months  < thresholds.M   && ['MM', months]  ||
                years   <= 1             && ['y']           || ['yy', years];
    
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }
    
    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding (roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof(roundingFunction) === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }
    
    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }
    
    function humanize (withSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
    
        var locale = this.localeData();
        var output = relativeTime$1(this, !withSuffix, locale);
    
        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }
    
        return locale.postformat(output);
    }
    
    var abs$1 = Math.abs;
    
    function sign(x) {
        return ((x > 0) - (x < 0)) || +x;
    }
    
    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
    
        var seconds = abs$1(this._milliseconds) / 1000;
        var days         = abs$1(this._days);
        var months       = abs$1(this._months);
        var minutes, hours, years;
    
        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;
    
        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;
    
    
        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
        var total = this.asSeconds();
    
        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }
    
        var totalSign = total < 0 ? '-' : '';
        var ymSign = sign(this._months) !== sign(total) ? '-' : '';
        var daysSign = sign(this._days) !== sign(total) ? '-' : '';
        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
    
        return totalSign + 'P' +
            (Y ? ymSign + Y + 'Y' : '') +
            (M ? ymSign + M + 'M' : '') +
            (D ? daysSign + D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? hmsSign + h + 'H' : '') +
            (m ? hmsSign + m + 'M' : '') +
            (s ? hmsSign + s + 'S' : '');
    }
    
    var proto$2 = Duration.prototype;
    
    proto$2.isValid        = isValid$1;
    proto$2.abs            = abs;
    proto$2.add            = add$1;
    proto$2.subtract       = subtract$1;
    proto$2.as             = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds      = asSeconds;
    proto$2.asMinutes      = asMinutes;
    proto$2.asHours        = asHours;
    proto$2.asDays         = asDays;
    proto$2.asWeeks        = asWeeks;
    proto$2.asMonths       = asMonths;
    proto$2.asYears        = asYears;
    proto$2.valueOf        = valueOf$1;
    proto$2._bubble        = bubble;
    proto$2.clone          = clone$1;
    proto$2.get            = get$2;
    proto$2.milliseconds   = milliseconds;
    proto$2.seconds        = seconds;
    proto$2.minutes        = minutes;
    proto$2.hours          = hours;
    proto$2.days           = days;
    proto$2.weeks          = weeks;
    proto$2.months         = months;
    proto$2.years          = years;
    proto$2.humanize       = humanize;
    proto$2.toISOString    = toISOString$1;
    proto$2.toString       = toISOString$1;
    proto$2.toJSON         = toISOString$1;
    proto$2.locale         = locale;
    proto$2.localeData     = localeData;
    
    // Deprecations
    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang;
    
    // Side effect imports
    
    // FORMATTING
    
    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');
    
    // PARSING
    
    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });
    
    // Side effect imports
    
    
    hooks.version = '2.19.1';
    
    setHookCallback(createLocal);
    
    hooks.fn                    = proto;
    hooks.min                   = min;
    hooks.max                   = max;
    hooks.now                   = now;
    hooks.utc                   = createUTC;
    hooks.unix                  = createUnix;
    hooks.months                = listMonths;
    hooks.isDate                = isDate;
    hooks.locale                = getSetGlobalLocale;
    hooks.invalid               = createInvalid;
    hooks.duration              = createDuration;
    hooks.isMoment              = isMoment;
    hooks.weekdays              = listWeekdays;
    hooks.parseZone             = createInZone;
    hooks.localeData            = getLocale;
    hooks.isDuration            = isDuration;
    hooks.monthsShort           = listMonthsShort;
    hooks.weekdaysMin           = listWeekdaysMin;
    hooks.defineLocale          = defineLocale;
    hooks.updateLocale          = updateLocale;
    hooks.locales               = listLocales;
    hooks.weekdaysShort         = listWeekdaysShort;
    hooks.normalizeUnits        = normalizeUnits;
    hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat        = getCalendarFormat;
    hooks.prototype             = proto;
    
    return hooks;
    
    })));
    
    },{}],66:[function(require,module,exports){
    //     Underscore.js 1.8.3
    //     http://underscorejs.org
    //     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
    //     Underscore may be freely distributed under the MIT license.
    
    (function() {
    
      // Baseline setup
      // --------------
    
      // Establish the root object, `window` in the browser, or `exports` on the server.
      var root = this;
    
      // Save the previous value of the `_` variable.
      var previousUnderscore = root._;
    
      // Save bytes in the minified (but not gzipped) version:
      var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
    
      // Create quick reference variables for speed access to core prototypes.
      var
        push             = ArrayProto.push,
        slice            = ArrayProto.slice,
        toString         = ObjProto.toString,
        hasOwnProperty   = ObjProto.hasOwnProperty;
    
      // All **ECMAScript 5** native function implementations that we hope to use
      // are declared here.
      var
        nativeIsArray      = Array.isArray,
        nativeKeys         = Object.keys,
        nativeBind         = FuncProto.bind,
        nativeCreate       = Object.create;
    
      // Naked function reference for surrogate-prototype-swapping.
      var Ctor = function(){};
    
      // Create a safe reference to the Underscore object for use below.
      var _ = function(obj) {
        if (obj instanceof _) return obj;
        if (!(this instanceof _)) return new _(obj);
        this._wrapped = obj;
      };
    
      // Export the Underscore object for **Node.js**, with
      // backwards-compatibility for the old `require()` API. If we're in
      // the browser, add `_` as a global object.
      if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
          exports = module.exports = _;
        }
        exports._ = _;
      } else {
        root._ = _;
      }
    
      // Current version.
      _.VERSION = '1.8.3';
    
      // Internal function that returns an efficient (for current engines) version
      // of the passed-in callback, to be repeatedly applied in other Underscore
      // functions.
      var optimizeCb = function(func, context, argCount) {
        if (context === void 0) return func;
        switch (argCount == null ? 3 : argCount) {
          case 1: return function(value) {
            return func.call(context, value);
          };
          case 2: return function(value, other) {
            return func.call(context, value, other);
          };
          case 3: return function(value, index, collection) {
            return func.call(context, value, index, collection);
          };
          case 4: return function(accumulator, value, index, collection) {
            return func.call(context, accumulator, value, index, collection);
          };
        }
        return function() {
          return func.apply(context, arguments);
        };
      };
    
      // A mostly-internal function to generate callbacks that can be applied
      // to each element in a collection, returning the desired result  either
      // identity, an arbitrary callback, a property matcher, or a property accessor.
      var cb = function(value, context, argCount) {
        if (value == null) return _.identity;
        if (_.isFunction(value)) return optimizeCb(value, context, argCount);
        if (_.isObject(value)) return _.matcher(value);
        return _.property(value);
      };
      _.iteratee = function(value, context) {
        return cb(value, context, Infinity);
      };
    
      // An internal function for creating assigner functions.
      var createAssigner = function(keysFunc, undefinedOnly) {
        return function(obj) {
          var length = arguments.length;
          if (length < 2 || obj == null) return obj;
          for (var index = 1; index < length; index++) {
            var source = arguments[index],
                keys = keysFunc(source),
                l = keys.length;
            for (var i = 0; i < l; i++) {
              var key = keys[i];
              if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
            }
          }
          return obj;
        };
      };
    
      // An internal function for creating a new object that inherits from another.
      var baseCreate = function(prototype) {
        if (!_.isObject(prototype)) return {};
        if (nativeCreate) return nativeCreate(prototype);
        Ctor.prototype = prototype;
        var result = new Ctor;
        Ctor.prototype = null;
        return result;
      };
    
      var property = function(key) {
        return function(obj) {
          return obj == null ? void 0 : obj[key];
        };
      };
    
      // Helper for collection methods to determine whether a collection
      // should be iterated as an array or as an object
      // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
      // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
      var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
      var getLength = property('length');
      var isArrayLike = function(collection) {
        var length = getLength(collection);
        return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
      };
    
      // Collection Functions
      // --------------------
    
      // The cornerstone, an `each` implementation, aka `forEach`.
      // Handles raw objects in addition to array-likes. Treats all
      // sparse array-likes as if they were dense.
      _.each = _.forEach = function(obj, iteratee, context) {
        iteratee = optimizeCb(iteratee, context);
        var i, length;
        if (isArrayLike(obj)) {
          for (i = 0, length = obj.length; i < length; i++) {
            iteratee(obj[i], i, obj);
          }
        } else {
          var keys = _.keys(obj);
          for (i = 0, length = keys.length; i < length; i++) {
            iteratee(obj[keys[i]], keys[i], obj);
          }
        }
        return obj;
      };
    
      // Return the results of applying the iteratee to each element.
      _.map = _.collect = function(obj, iteratee, context) {
        iteratee = cb(iteratee, context);
        var keys = !isArrayLike(obj) && _.keys(obj),
            length = (keys || obj).length,
            results = Array(length);
        for (var index = 0; index < length; index++) {
          var currentKey = keys ? keys[index] : index;
          results[index] = iteratee(obj[currentKey], currentKey, obj);
        }
        return results;
      };
    
      // Create a reducing function iterating left or right.
      function createReduce(dir) {
        // Optimized iterator function as using arguments.length
        // in the main function will deoptimize the, see #1991.
        function iterator(obj, iteratee, memo, keys, index, length) {
          for (; index >= 0 && index < length; index += dir) {
            var currentKey = keys ? keys[index] : index;
            memo = iteratee(memo, obj[currentKey], currentKey, obj);
          }
          return memo;
        }
    
        return function(obj, iteratee, memo, context) {
          iteratee = optimizeCb(iteratee, context, 4);
          var keys = !isArrayLike(obj) && _.keys(obj),
              length = (keys || obj).length,
              index = dir > 0 ? 0 : length - 1;
          // Determine the initial value if none is provided.
          if (arguments.length < 3) {
            memo = obj[keys ? keys[index] : index];
            index += dir;
          }
          return iterator(obj, iteratee, memo, keys, index, length);
        };
      }
    
      // **Reduce** builds up a single result from a list of values, aka `inject`,
      // or `foldl`.
      _.reduce = _.foldl = _.inject = createReduce(1);
    
      // The right-associative version of reduce, also known as `foldr`.
      _.reduceRight = _.foldr = createReduce(-1);
    
      // Return the first value which passes a truth test. Aliased as `detect`.
      _.find = _.detect = function(obj, predicate, context) {
        var key;
        if (isArrayLike(obj)) {
          key = _.findIndex(obj, predicate, context);
        } else {
          key = _.findKey(obj, predicate, context);
        }
        if (key !== void 0 && key !== -1) return obj[key];
      };
    
      // Return all the elements that pass a truth test.
      // Aliased as `select`.
      _.filter = _.select = function(obj, predicate, context) {
        var results = [];
        predicate = cb(predicate, context);
        _.each(obj, function(value, index, list) {
          if (predicate(value, index, list)) results.push(value);
        });
        return results;
      };
    
      // Return all the elements for which a truth test fails.
      _.reject = function(obj, predicate, context) {
        return _.filter(obj, _.negate(cb(predicate)), context);
      };
    
      // Determine whether all of the elements match a truth test.
      // Aliased as `all`.
      _.every = _.all = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        var keys = !isArrayLike(obj) && _.keys(obj),
            length = (keys || obj).length;
        for (var index = 0; index < length; index++) {
          var currentKey = keys ? keys[index] : index;
          if (!predicate(obj[currentKey], currentKey, obj)) return false;
        }
        return true;
      };
    
      // Determine if at least one element in the object matches a truth test.
      // Aliased as `any`.
      _.some = _.any = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        var keys = !isArrayLike(obj) && _.keys(obj),
            length = (keys || obj).length;
        for (var index = 0; index < length; index++) {
          var currentKey = keys ? keys[index] : index;
          if (predicate(obj[currentKey], currentKey, obj)) return true;
        }
        return false;
      };
    
      // Determine if the array or object contains a given item (using `===`).
      // Aliased as `includes` and `include`.
      _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
        if (!isArrayLike(obj)) obj = _.values(obj);
        if (typeof fromIndex != 'number' || guard) fromIndex = 0;
        return _.indexOf(obj, item, fromIndex) >= 0;
      };
    
      // Invoke a method (with arguments) on every item in a collection.
      _.invoke = function(obj, method) {
        var args = slice.call(arguments, 2);
        var isFunc = _.isFunction(method);
        return _.map(obj, function(value) {
          var func = isFunc ? method : value[method];
          return func == null ? func : func.apply(value, args);
        });
      };
    
      // Convenience version of a common use case of `map`: fetching a property.
      _.pluck = function(obj, key) {
        return _.map(obj, _.property(key));
      };
    
      // Convenience version of a common use case of `filter`: selecting only objects
      // containing specific `key:value` pairs.
      _.where = function(obj, attrs) {
        return _.filter(obj, _.matcher(attrs));
      };
    
      // Convenience version of a common use case of `find`: getting the first object
      // containing specific `key:value` pairs.
      _.findWhere = function(obj, attrs) {
        return _.find(obj, _.matcher(attrs));
      };
    
      // Return the maximum element (or element-based computation).
      _.max = function(obj, iteratee, context) {
        var result = -Infinity, lastComputed = -Infinity,
            value, computed;
        if (iteratee == null && obj != null) {
          obj = isArrayLike(obj) ? obj : _.values(obj);
          for (var i = 0, length = obj.length; i < length; i++) {
            value = obj[i];
            if (value > result) {
              result = value;
            }
          }
        } else {
          iteratee = cb(iteratee, context);
          _.each(obj, function(value, index, list) {
            computed = iteratee(value, index, list);
            if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
              result = value;
              lastComputed = computed;
            }
          });
        }
        return result;
      };
    
      // Return the minimum element (or element-based computation).
      _.min = function(obj, iteratee, context) {
        var result = Infinity, lastComputed = Infinity,
            value, computed;
        if (iteratee == null && obj != null) {
          obj = isArrayLike(obj) ? obj : _.values(obj);
          for (var i = 0, length = obj.length; i < length; i++) {
            value = obj[i];
            if (value < result) {
              result = value;
            }
          }
        } else {
          iteratee = cb(iteratee, context);
          _.each(obj, function(value, index, list) {
            computed = iteratee(value, index, list);
            if (computed < lastComputed || computed === Infinity && result === Infinity) {
              result = value;
              lastComputed = computed;
            }
          });
        }
        return result;
      };
    
      // Shuffle a collection, using the modern version of the
      // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
      _.shuffle = function(obj) {
        var set = isArrayLike(obj) ? obj : _.values(obj);
        var length = set.length;
        var shuffled = Array(length);
        for (var index = 0, rand; index < length; index++) {
          rand = _.random(0, index);
          if (rand !== index) shuffled[index] = shuffled[rand];
          shuffled[rand] = set[index];
        }
        return shuffled;
      };
    
      // Sample **n** random values from a collection.
      // If **n** is not specified, returns a single random element.
      // The internal `guard` argument allows it to work with `map`.
      _.sample = function(obj, n, guard) {
        if (n == null || guard) {
          if (!isArrayLike(obj)) obj = _.values(obj);
          return obj[_.random(obj.length - 1)];
        }
        return _.shuffle(obj).slice(0, Math.max(0, n));
      };
    
      // Sort the object's values by a criterion produced by an iteratee.
      _.sortBy = function(obj, iteratee, context) {
        iteratee = cb(iteratee, context);
        return _.pluck(_.map(obj, function(value, index, list) {
          return {
            value: value,
            index: index,
            criteria: iteratee(value, index, list)
          };
        }).sort(function(left, right) {
          var a = left.criteria;
          var b = right.criteria;
          if (a !== b) {
            if (a > b || a === void 0) return 1;
            if (a < b || b === void 0) return -1;
          }
          return left.index - right.index;
        }), 'value');
      };
    
      // An internal function used for aggregate "group by" operations.
      var group = function(behavior) {
        return function(obj, iteratee, context) {
          var result = {};
          iteratee = cb(iteratee, context);
          _.each(obj, function(value, index) {
            var key = iteratee(value, index, obj);
            behavior(result, value, key);
          });
          return result;
        };
      };
    
      // Groups the object's values by a criterion. Pass either a string attribute
      // to group by, or a function that returns the criterion.
      _.groupBy = group(function(result, value, key) {
        if (_.has(result, key)) result[key].push(value); else result[key] = [value];
      });
    
      // Indexes the object's values by a criterion, similar to `groupBy`, but for
      // when you know that your index values will be unique.
      _.indexBy = group(function(result, value, key) {
        result[key] = value;
      });
    
      // Counts instances of an object that group by a certain criterion. Pass
      // either a string attribute to count by, or a function that returns the
      // criterion.
      _.countBy = group(function(result, value, key) {
        if (_.has(result, key)) result[key]++; else result[key] = 1;
      });
    
      // Safely create a real, live array from anything iterable.
      _.toArray = function(obj) {
        if (!obj) return [];
        if (_.isArray(obj)) return slice.call(obj);
        if (isArrayLike(obj)) return _.map(obj, _.identity);
        return _.values(obj);
      };
    
      // Return the number of elements in an object.
      _.size = function(obj) {
        if (obj == null) return 0;
        return isArrayLike(obj) ? obj.length : _.keys(obj).length;
      };
    
      // Split a collection into two arrays: one whose elements all satisfy the given
      // predicate, and one whose elements all do not satisfy the predicate.
      _.partition = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        var pass = [], fail = [];
        _.each(obj, function(value, key, obj) {
          (predicate(value, key, obj) ? pass : fail).push(value);
        });
        return [pass, fail];
      };
    
      // Array Functions
      // ---------------
    
      // Get the first element of an array. Passing **n** will return the first N
      // values in the array. Aliased as `head` and `take`. The **guard** check
      // allows it to work with `_.map`.
      _.first = _.head = _.take = function(array, n, guard) {
        if (array == null) return void 0;
        if (n == null || guard) return array[0];
        return _.initial(array, array.length - n);
      };
    
      // Returns everything but the last entry of the array. Especially useful on
      // the arguments object. Passing **n** will return all the values in
      // the array, excluding the last N.
      _.initial = function(array, n, guard) {
        return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
      };
    
      // Get the last element of an array. Passing **n** will return the last N
      // values in the array.
      _.last = function(array, n, guard) {
        if (array == null) return void 0;
        if (n == null || guard) return array[array.length - 1];
        return _.rest(array, Math.max(0, array.length - n));
      };
    
      // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
      // Especially useful on the arguments object. Passing an **n** will return
      // the rest N values in the array.
      _.rest = _.tail = _.drop = function(array, n, guard) {
        return slice.call(array, n == null || guard ? 1 : n);
      };
    
      // Trim out all falsy values from an array.
      _.compact = function(array) {
        return _.filter(array, _.identity);
      };
    
      // Internal implementation of a recursive `flatten` function.
      var flatten = function(input, shallow, strict, startIndex) {
        var output = [], idx = 0;
        for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
          var value = input[i];
          if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
            //flatten current level of array or arguments object
            if (!shallow) value = flatten(value, shallow, strict);
            var j = 0, len = value.length;
            output.length += len;
            while (j < len) {
              output[idx++] = value[j++];
            }
          } else if (!strict) {
            output[idx++] = value;
          }
        }
        return output;
      };
    
      // Flatten out an array, either recursively (by default), or just one level.
      _.flatten = function(array, shallow) {
        return flatten(array, shallow, false);
      };
    
      // Return a version of the array that does not contain the specified value(s).
      _.without = function(array) {
        return _.difference(array, slice.call(arguments, 1));
      };
    
      // Produce a duplicate-free version of the array. If the array has already
      // been sorted, you have the option of using a faster algorithm.
      // Aliased as `unique`.
      _.uniq = _.unique = function(array, isSorted, iteratee, context) {
        if (!_.isBoolean(isSorted)) {
          context = iteratee;
          iteratee = isSorted;
          isSorted = false;
        }
        if (iteratee != null) iteratee = cb(iteratee, context);
        var result = [];
        var seen = [];
        for (var i = 0, length = getLength(array); i < length; i++) {
          var value = array[i],
              computed = iteratee ? iteratee(value, i, array) : value;
          if (isSorted) {
            if (!i || seen !== computed) result.push(value);
            seen = computed;
          } else if (iteratee) {
            if (!_.contains(seen, computed)) {
              seen.push(computed);
              result.push(value);
            }
          } else if (!_.contains(result, value)) {
            result.push(value);
          }
        }
        return result;
      };
    
      // Produce an array that contains the union: each distinct element from all of
      // the passed-in arrays.
      _.union = function() {
        return _.uniq(flatten(arguments, true, true));
      };
    
      // Produce an array that contains every item shared between all the
      // passed-in arrays.
      _.intersection = function(array) {
        var result = [];
        var argsLength = arguments.length;
        for (var i = 0, length = getLength(array); i < length; i++) {
          var item = array[i];
          if (_.contains(result, item)) continue;
          for (var j = 1; j < argsLength; j++) {
            if (!_.contains(arguments[j], item)) break;
          }
          if (j === argsLength) result.push(item);
        }
        return result;
      };
    
      // Take the difference between one array and a number of other arrays.
      // Only the elements present in just the first array will remain.
      _.difference = function(array) {
        var rest = flatten(arguments, true, true, 1);
        return _.filter(array, function(value){
          return !_.contains(rest, value);
        });
      };
    
      // Zip together multiple lists into a single array -- elements that share
      // an index go together.
      _.zip = function() {
        return _.unzip(arguments);
      };
    
      // Complement of _.zip. Unzip accepts an array of arrays and groups
      // each array's elements on shared indices
      _.unzip = function(array) {
        var length = array && _.max(array, getLength).length || 0;
        var result = Array(length);
    
        for (var index = 0; index < length; index++) {
          result[index] = _.pluck(array, index);
        }
        return result;
      };
    
      // Converts lists into objects. Pass either a single array of `[key, value]`
      // pairs, or two parallel arrays of the same length -- one of keys, and one of
      // the corresponding values.
      _.object = function(list, values) {
        var result = {};
        for (var i = 0, length = getLength(list); i < length; i++) {
          if (values) {
            result[list[i]] = values[i];
          } else {
            result[list[i][0]] = list[i][1];
          }
        }
        return result;
      };
    
      // Generator function to create the findIndex and findLastIndex functions
      function createPredicateIndexFinder(dir) {
        return function(array, predicate, context) {
          predicate = cb(predicate, context);
          var length = getLength(array);
          var index = dir > 0 ? 0 : length - 1;
          for (; index >= 0 && index < length; index += dir) {
            if (predicate(array[index], index, array)) return index;
          }
          return -1;
        };
      }
    
      // Returns the first index on an array-like that passes a predicate test
      _.findIndex = createPredicateIndexFinder(1);
      _.findLastIndex = createPredicateIndexFinder(-1);
    
      // Use a comparator function to figure out the smallest index at which
      // an object should be inserted so as to maintain order. Uses binary search.
      _.sortedIndex = function(array, obj, iteratee, context) {
        iteratee = cb(iteratee, context, 1);
        var value = iteratee(obj);
        var low = 0, high = getLength(array);
        while (low < high) {
          var mid = Math.floor((low + high) / 2);
          if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
        }
        return low;
      };
    
      // Generator function to create the indexOf and lastIndexOf functions
      function createIndexFinder(dir, predicateFind, sortedIndex) {
        return function(array, item, idx) {
          var i = 0, length = getLength(array);
          if (typeof idx == 'number') {
            if (dir > 0) {
                i = idx >= 0 ? idx : Math.max(idx + length, i);
            } else {
                length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
            }
          } else if (sortedIndex && idx && length) {
            idx = sortedIndex(array, item);
            return array[idx] === item ? idx : -1;
          }
          if (item !== item) {
            idx = predicateFind(slice.call(array, i, length), _.isNaN);
            return idx >= 0 ? idx + i : -1;
          }
          for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
            if (array[idx] === item) return idx;
          }
          return -1;
        };
      }
    
      // Return the position of the first occurrence of an item in an array,
      // or -1 if the item is not included in the array.
      // If the array is large and already in sort order, pass `true`
      // for **isSorted** to use binary search.
      _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
      _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);
    
      // Generate an integer Array containing an arithmetic progression. A port of
      // the native Python `range()` function. See
      // [the Python documentation](http://docs.python.org/library/functions.html#range).
      _.range = function(start, stop, step) {
        if (stop == null) {
          stop = start || 0;
          start = 0;
        }
        step = step || 1;
    
        var length = Math.max(Math.ceil((stop - start) / step), 0);
        var range = Array(length);
    
        for (var idx = 0; idx < length; idx++, start += step) {
          range[idx] = start;
        }
    
        return range;
      };
    
      // Function (ahem) Functions
      // ------------------
    
      // Determines whether to execute a function as a constructor
      // or a normal function with the provided arguments
      var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
        if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
        var self = baseCreate(sourceFunc.prototype);
        var result = sourceFunc.apply(self, args);
        if (_.isObject(result)) return result;
        return self;
      };
    
      // Create a function bound to a given object (assigning `this`, and arguments,
      // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
      // available.
      _.bind = function(func, context) {
        if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
        if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
        var args = slice.call(arguments, 2);
        var bound = function() {
          return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
        };
        return bound;
      };
    
      // Partially apply a function by creating a version that has had some of its
      // arguments pre-filled, without changing its dynamic `this` context. _ acts
      // as a placeholder, allowing any combination of arguments to be pre-filled.
      _.partial = function(func) {
        var boundArgs = slice.call(arguments, 1);
        var bound = function() {
          var position = 0, length = boundArgs.length;
          var args = Array(length);
          for (var i = 0; i < length; i++) {
            args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
          }
          while (position < arguments.length) args.push(arguments[position++]);
          return executeBound(func, bound, this, this, args);
        };
        return bound;
      };
    
      // Bind a number of an object's methods to that object. Remaining arguments
      // are the method names to be bound. Useful for ensuring that all callbacks
      // defined on an object belong to it.
      _.bindAll = function(obj) {
        var i, length = arguments.length, key;
        if (length <= 1) throw new Error('bindAll must be passed function names');
        for (i = 1; i < length; i++) {
          key = arguments[i];
          obj[key] = _.bind(obj[key], obj);
        }
        return obj;
      };
    
      // Memoize an expensive function by storing its results.
      _.memoize = function(func, hasher) {
        var memoize = function(key) {
          var cache = memoize.cache;
          var address = '' + (hasher ? hasher.apply(this, arguments) : key);
          if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
          return cache[address];
        };
        memoize.cache = {};
        return memoize;
      };
    
      // Delays a function for the given number of milliseconds, and then calls
      // it with the arguments supplied.
      _.delay = function(func, wait) {
        var args = slice.call(arguments, 2);
        return setTimeout(function(){
          return func.apply(null, args);
        }, wait);
      };
    
      // Defers a function, scheduling it to run after the current call stack has
      // cleared.
      _.defer = _.partial(_.delay, _, 1);
    
      // Returns a function, that, when invoked, will only be triggered at most once
      // during a given window of time. Normally, the throttled function will run
      // as much as it can, without ever going more than once per `wait` duration;
      // but if you'd like to disable the execution on the leading edge, pass
      // `{leading: false}`. To disable execution on the trailing edge, ditto.
      _.throttle = function(func, wait, options) {
        var context, args, result;
        var timeout = null;
        var previous = 0;
        if (!options) options = {};
        var later = function() {
          previous = options.leading === false ? 0 : _.now();
          timeout = null;
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        };
        return function() {
          var now = _.now();
          if (!previous && options.leading === false) previous = now;
          var remaining = wait - (now - previous);
          context = this;
          args = arguments;
          if (remaining <= 0 || remaining > wait) {
            if (timeout) {
              clearTimeout(timeout);
              timeout = null;
            }
            previous = now;
            result = func.apply(context, args);
            if (!timeout) context = args = null;
          } else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
          }
          return result;
        };
      };
    
      // Returns a function, that, as long as it continues to be invoked, will not
      // be triggered. The function will be called after it stops being called for
      // N milliseconds. If `immediate` is passed, trigger the function on the
      // leading edge, instead of the trailing.
      _.debounce = function(func, wait, immediate) {
        var timeout, args, context, timestamp, result;
    
        var later = function() {
          var last = _.now() - timestamp;
    
          if (last < wait && last >= 0) {
            timeout = setTimeout(later, wait - last);
          } else {
            timeout = null;
            if (!immediate) {
              result = func.apply(context, args);
              if (!timeout) context = args = null;
            }
          }
        };
    
        return function() {
          context = this;
          args = arguments;
          timestamp = _.now();
          var callNow = immediate && !timeout;
          if (!timeout) timeout = setTimeout(later, wait);
          if (callNow) {
            result = func.apply(context, args);
            context = args = null;
          }
    
          return result;
        };
      };
    
      // Returns the first function passed as an argument to the second,
      // allowing you to adjust arguments, run code before and after, and
      // conditionally execute the original function.
      _.wrap = function(func, wrapper) {
        return _.partial(wrapper, func);
      };
    
      // Returns a negated version of the passed-in predicate.
      _.negate = function(predicate) {
        return function() {
          return !predicate.apply(this, arguments);
        };
      };
    
      // Returns a function that is the composition of a list of functions, each
      // consuming the return value of the function that follows.
      _.compose = function() {
        var args = arguments;
        var start = args.length - 1;
        return function() {
          var i = start;
          var result = args[start].apply(this, arguments);
          while (i--) result = args[i].call(this, result);
          return result;
        };
      };
    
      // Returns a function that will only be executed on and after the Nth call.
      _.after = function(times, func) {
        return function() {
          if (--times < 1) {
            return func.apply(this, arguments);
          }
        };
      };
    
      // Returns a function that will only be executed up to (but not including) the Nth call.
      _.before = function(times, func) {
        var memo;
        return function() {
          if (--times > 0) {
            memo = func.apply(this, arguments);
          }
          if (times <= 1) func = null;
          return memo;
        };
      };
    
      // Returns a function that will be executed at most one time, no matter how
      // often you call it. Useful for lazy initialization.
      _.once = _.partial(_.before, 2);
    
      // Object Functions
      // ----------------
    
      // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
      var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
      var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                          'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];
    
      function collectNonEnumProps(obj, keys) {
        var nonEnumIdx = nonEnumerableProps.length;
        var constructor = obj.constructor;
        var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;
    
        // Constructor is a special case.
        var prop = 'constructor';
        if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);
    
        while (nonEnumIdx--) {
          prop = nonEnumerableProps[nonEnumIdx];
          if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
            keys.push(prop);
          }
        }
      }
    
      // Retrieve the names of an object's own properties.
      // Delegates to **ECMAScript 5**'s native `Object.keys`
      _.keys = function(obj) {
        if (!_.isObject(obj)) return [];
        if (nativeKeys) return nativeKeys(obj);
        var keys = [];
        for (var key in obj) if (_.has(obj, key)) keys.push(key);
        // Ahem, IE < 9.
        if (hasEnumBug) collectNonEnumProps(obj, keys);
        return keys;
      };
    
      // Retrieve all the property names of an object.
      _.allKeys = function(obj) {
        if (!_.isObject(obj)) return [];
        var keys = [];
        for (var key in obj) keys.push(key);
        // Ahem, IE < 9.
        if (hasEnumBug) collectNonEnumProps(obj, keys);
        return keys;
      };
    
      // Retrieve the values of an object's properties.
      _.values = function(obj) {
        var keys = _.keys(obj);
        var length = keys.length;
        var values = Array(length);
        for (var i = 0; i < length; i++) {
          values[i] = obj[keys[i]];
        }
        return values;
      };
    
      // Returns the results of applying the iteratee to each element of the object
      // In contrast to _.map it returns an object
      _.mapObject = function(obj, iteratee, context) {
        iteratee = cb(iteratee, context);
        var keys =  _.keys(obj),
              length = keys.length,
              results = {},
              currentKey;
          for (var index = 0; index < length; index++) {
            currentKey = keys[index];
            results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
          }
          return results;
      };
    
      // Convert an object into a list of `[key, value]` pairs.
      _.pairs = function(obj) {
        var keys = _.keys(obj);
        var length = keys.length;
        var pairs = Array(length);
        for (var i = 0; i < length; i++) {
          pairs[i] = [keys[i], obj[keys[i]]];
        }
        return pairs;
      };
    
      // Invert the keys and values of an object. The values must be serializable.
      _.invert = function(obj) {
        var result = {};
        var keys = _.keys(obj);
        for (var i = 0, length = keys.length; i < length; i++) {
          result[obj[keys[i]]] = keys[i];
        }
        return result;
      };
    
      // Return a sorted list of the function names available on the object.
      // Aliased as `methods`
      _.functions = _.methods = function(obj) {
        var names = [];
        for (var key in obj) {
          if (_.isFunction(obj[key])) names.push(key);
        }
        return names.sort();
      };
    
      // Extend a given object with all the properties in passed-in object(s).
      _.extend = createAssigner(_.allKeys);
    
      // Assigns a given object with all the own properties in the passed-in object(s)
      // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
      _.extendOwn = _.assign = createAssigner(_.keys);
    
      // Returns the first key on an object that passes a predicate test
      _.findKey = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        var keys = _.keys(obj), key;
        for (var i = 0, length = keys.length; i < length; i++) {
          key = keys[i];
          if (predicate(obj[key], key, obj)) return key;
        }
      };
    
      // Return a copy of the object only containing the whitelisted properties.
      _.pick = function(object, oiteratee, context) {
        var result = {}, obj = object, iteratee, keys;
        if (obj == null) return result;
        if (_.isFunction(oiteratee)) {
          keys = _.allKeys(obj);
          iteratee = optimizeCb(oiteratee, context);
        } else {
          keys = flatten(arguments, false, false, 1);
          iteratee = function(value, key, obj) { return key in obj; };
          obj = Object(obj);
        }
        for (var i = 0, length = keys.length; i < length; i++) {
          var key = keys[i];
          var value = obj[key];
          if (iteratee(value, key, obj)) result[key] = value;
        }
        return result;
      };
    
       // Return a copy of the object without the blacklisted properties.
      _.omit = function(obj, iteratee, context) {
        if (_.isFunction(iteratee)) {
          iteratee = _.negate(iteratee);
        } else {
          var keys = _.map(flatten(arguments, false, false, 1), String);
          iteratee = function(value, key) {
            return !_.contains(keys, key);
          };
        }
        return _.pick(obj, iteratee, context);
      };
    
      // Fill in a given object with default properties.
      _.defaults = createAssigner(_.allKeys, true);
    
      // Creates an object that inherits from the given prototype object.
      // If additional properties are provided then they will be added to the
      // created object.
      _.create = function(prototype, props) {
        var result = baseCreate(prototype);
        if (props) _.extendOwn(result, props);
        return result;
      };
    
      // Create a (shallow-cloned) duplicate of an object.
      _.clone = function(obj) {
        if (!_.isObject(obj)) return obj;
        return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
      };
    
      // Invokes interceptor with the obj, and then returns obj.
      // The primary purpose of this method is to "tap into" a method chain, in
      // order to perform operations on intermediate results within the chain.
      _.tap = function(obj, interceptor) {
        interceptor(obj);
        return obj;
      };
    
      // Returns whether an object has a given set of `key:value` pairs.
      _.isMatch = function(object, attrs) {
        var keys = _.keys(attrs), length = keys.length;
        if (object == null) return !length;
        var obj = Object(object);
        for (var i = 0; i < length; i++) {
          var key = keys[i];
          if (attrs[key] !== obj[key] || !(key in obj)) return false;
        }
        return true;
      };
    
    
      // Internal recursive comparison function for `isEqual`.
      var eq = function(a, b, aStack, bStack) {
        // Identical objects are equal. `0 === -0`, but they aren't identical.
        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
        if (a === b) return a !== 0 || 1 / a === 1 / b;
        // A strict comparison is necessary because `null == undefined`.
        if (a == null || b == null) return a === b;
        // Unwrap any wrapped objects.
        if (a instanceof _) a = a._wrapped;
        if (b instanceof _) b = b._wrapped;
        // Compare `[[Class]]` names.
        var className = toString.call(a);
        if (className !== toString.call(b)) return false;
        switch (className) {
          // Strings, numbers, regular expressions, dates, and booleans are compared by value.
          case '[object RegExp]':
          // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
          case '[object String]':
            // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
            // equivalent to `new String("5")`.
            return '' + a === '' + b;
          case '[object Number]':
            // `NaN`s are equivalent, but non-reflexive.
            // Object(NaN) is equivalent to NaN
            if (+a !== +a) return +b !== +b;
            // An `egal` comparison is performed for other numeric values.
            return +a === 0 ? 1 / +a === 1 / b : +a === +b;
          case '[object Date]':
          case '[object Boolean]':
            // Coerce dates and booleans to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a === +b;
        }
    
        var areArrays = className === '[object Array]';
        if (!areArrays) {
          if (typeof a != 'object' || typeof b != 'object') return false;
    
          // Objects with different constructors are not equivalent, but `Object`s or `Array`s
          // from different frames are.
          var aCtor = a.constructor, bCtor = b.constructor;
          if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                                   _.isFunction(bCtor) && bCtor instanceof bCtor)
                              && ('constructor' in a && 'constructor' in b)) {
            return false;
          }
        }
        // Assume equality for cyclic structures. The algorithm for detecting cyclic
        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    
        // Initializing stack of traversed objects.
        // It's done here since we only need them for objects and arrays comparison.
        aStack = aStack || [];
        bStack = bStack || [];
        var length = aStack.length;
        while (length--) {
          // Linear search. Performance is inversely proportional to the number of
          // unique nested structures.
          if (aStack[length] === a) return bStack[length] === b;
        }
    
        // Add the first object to the stack of traversed objects.
        aStack.push(a);
        bStack.push(b);
    
        // Recursively compare objects and arrays.
        if (areArrays) {
          // Compare array lengths to determine if a deep comparison is necessary.
          length = a.length;
          if (length !== b.length) return false;
          // Deep compare the contents, ignoring non-numeric properties.
          while (length--) {
            if (!eq(a[length], b[length], aStack, bStack)) return false;
          }
        } else {
          // Deep compare objects.
          var keys = _.keys(a), key;
          length = keys.length;
          // Ensure that both objects contain the same number of properties before comparing deep equality.
          if (_.keys(b).length !== length) return false;
          while (length--) {
            // Deep compare each member
            key = keys[length];
            if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
          }
        }
        // Remove the first object from the stack of traversed objects.
        aStack.pop();
        bStack.pop();
        return true;
      };
    
      // Perform a deep comparison to check if two objects are equal.
      _.isEqual = function(a, b) {
        return eq(a, b);
      };
    
      // Is a given array, string, or object empty?
      // An "empty" object has no enumerable own-properties.
      _.isEmpty = function(obj) {
        if (obj == null) return true;
        if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
        return _.keys(obj).length === 0;
      };
    
      // Is a given value a DOM element?
      _.isElement = function(obj) {
        return !!(obj && obj.nodeType === 1);
      };
    
      // Is a given value an array?
      // Delegates to ECMA5's native Array.isArray
      _.isArray = nativeIsArray || function(obj) {
        return toString.call(obj) === '[object Array]';
      };
    
      // Is a given variable an object?
      _.isObject = function(obj) {
        var type = typeof obj;
        return type === 'function' || type === 'object' && !!obj;
      };
    
      // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
      _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
        _['is' + name] = function(obj) {
          return toString.call(obj) === '[object ' + name + ']';
        };
      });
    
      // Define a fallback version of the method in browsers (ahem, IE < 9), where
      // there isn't any inspectable "Arguments" type.
      if (!_.isArguments(arguments)) {
        _.isArguments = function(obj) {
          return _.has(obj, 'callee');
        };
      }
    
      // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
      // IE 11 (#1621), and in Safari 8 (#1929).
      if (typeof /./ != 'function' && typeof Int8Array != 'object') {
        _.isFunction = function(obj) {
          return typeof obj == 'function' || false;
        };
      }
    
      // Is a given object a finite number?
      _.isFinite = function(obj) {
        return isFinite(obj) && !isNaN(parseFloat(obj));
      };
    
      // Is the given value `NaN`? (NaN is the only number which does not equal itself).
      _.isNaN = function(obj) {
        return _.isNumber(obj) && obj !== +obj;
      };
    
      // Is a given value a boolean?
      _.isBoolean = function(obj) {
        return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
      };
    
      // Is a given value equal to null?
      _.isNull = function(obj) {
        return obj === null;
      };
    
      // Is a given variable undefined?
      _.isUndefined = function(obj) {
        return obj === void 0;
      };
    
      // Shortcut function for checking if an object has a given property directly
      // on itself (in other words, not on a prototype).
      _.has = function(obj, key) {
        return obj != null && hasOwnProperty.call(obj, key);
      };
    
      // Utility Functions
      // -----------------
    
      // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
      // previous owner. Returns a reference to the Underscore object.
      _.noConflict = function() {
        root._ = previousUnderscore;
        return this;
      };
    
      // Keep the identity function around for default iteratees.
      _.identity = function(value) {
        return value;
      };
    
      // Predicate-generating functions. Often useful outside of Underscore.
      _.constant = function(value) {
        return function() {
          return value;
        };
      };
    
      _.noop = function(){};
    
      _.property = property;
    
      // Generates a function for a given object that returns a given property.
      _.propertyOf = function(obj) {
        return obj == null ? function(){} : function(key) {
          return obj[key];
        };
      };
    
      // Returns a predicate for checking whether an object has a given set of
      // `key:value` pairs.
      _.matcher = _.matches = function(attrs) {
        attrs = _.extendOwn({}, attrs);
        return function(obj) {
          return _.isMatch(obj, attrs);
        };
      };
    
      // Run a function **n** times.
      _.times = function(n, iteratee, context) {
        var accum = Array(Math.max(0, n));
        iteratee = optimizeCb(iteratee, context, 1);
        for (var i = 0; i < n; i++) accum[i] = iteratee(i);
        return accum;
      };
    
      // Return a random integer between min and max (inclusive).
      _.random = function(min, max) {
        if (max == null) {
          max = min;
          min = 0;
        }
        return min + Math.floor(Math.random() * (max - min + 1));
      };
    
      // A (possibly faster) way to get the current timestamp as an integer.
      _.now = Date.now || function() {
        return new Date().getTime();
      };
    
       // List of HTML entities for escaping.
      var escapeMap = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;',
        '`': '&#x60;'
      };
      var unescapeMap = _.invert(escapeMap);
    
      // Functions for escaping and unescaping strings to/from HTML interpolation.
      var createEscaper = function(map) {
        var escaper = function(match) {
          return map[match];
        };
        // Regexes for identifying a key that needs to be escaped
        var source = '(?:' + _.keys(map).join('|') + ')';
        var testRegexp = RegExp(source);
        var replaceRegexp = RegExp(source, 'g');
        return function(string) {
          string = string == null ? '' : '' + string;
          return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
        };
      };
      _.escape = createEscaper(escapeMap);
      _.unescape = createEscaper(unescapeMap);
    
      // If the value of the named `property` is a function then invoke it with the
      // `object` as context; otherwise, return it.
      _.result = function(object, property, fallback) {
        var value = object == null ? void 0 : object[property];
        if (value === void 0) {
          value = fallback;
        }
        return _.isFunction(value) ? value.call(object) : value;
      };
    
      // Generate a unique integer id (unique within the entire client session).
      // Useful for temporary DOM ids.
      var idCounter = 0;
      _.uniqueId = function(prefix) {
        var id = ++idCounter + '';
        return prefix ? prefix + id : id;
      };
    
      // By default, Underscore uses ERB-style template delimiters, change the
      // following template settings to use alternative delimiters.
      _.templateSettings = {
        evaluate    : /<%([\s\S]+?)%>/g,
        interpolate : /<%=([\s\S]+?)%>/g,
        escape      : /<%-([\s\S]+?)%>/g
      };
    
      // When customizing `templateSettings`, if you don't want to define an
      // interpolation, evaluation or escaping regex, we need one that is
      // guaranteed not to match.
      var noMatch = /(.)^/;
    
      // Certain characters need to be escaped so that they can be put into a
      // string literal.
      var escapes = {
        "'":      "'",
        '\\':     '\\',
        '\r':     'r',
        '\n':     'n',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
      };
    
      var escaper = /\\|'|\r|\n|\u2028|\u2029/g;
    
      var escapeChar = function(match) {
        return '\\' + escapes[match];
      };
    
      // JavaScript micro-templating, similar to John Resig's implementation.
      // Underscore templating handles arbitrary delimiters, preserves whitespace,
      // and correctly escapes quotes within interpolated code.
      // NB: `oldSettings` only exists for backwards compatibility.
      _.template = function(text, settings, oldSettings) {
        if (!settings && oldSettings) settings = oldSettings;
        settings = _.defaults({}, settings, _.templateSettings);
    
        // Combine delimiters into one regular expression via alternation.
        var matcher = RegExp([
          (settings.escape || noMatch).source,
          (settings.interpolate || noMatch).source,
          (settings.evaluate || noMatch).source
        ].join('|') + '|$', 'g');
    
        // Compile the template source, escaping string literals appropriately.
        var index = 0;
        var source = "__p+='";
        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
          source += text.slice(index, offset).replace(escaper, escapeChar);
          index = offset + match.length;
    
          if (escape) {
            source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
          } else if (interpolate) {
            source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
          } else if (evaluate) {
            source += "';\n" + evaluate + "\n__p+='";
          }
    
          // Adobe VMs need the match returned to produce the correct offest.
          return match;
        });
        source += "';\n";
    
        // If a variable is not specified, place data values in local scope.
        if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';
    
        source = "var __t,__p='',__j=Array.prototype.join," +
          "print=function(){__p+=__j.call(arguments,'');};\n" +
          source + 'return __p;\n';
    
        try {
          var render = new Function(settings.variable || 'obj', '_', source);
        } catch (e) {
          e.source = source;
          throw e;
        }
    
        var template = function(data) {
          return render.call(this, data, _);
        };
    
        // Provide the compiled source as a convenience for precompilation.
        var argument = settings.variable || 'obj';
        template.source = 'function(' + argument + '){\n' + source + '}';
    
        return template;
      };
    
      // Add a "chain" function. Start chaining a wrapped Underscore object.
      _.chain = function(obj) {
        var instance = _(obj);
        instance._chain = true;
        return instance;
      };
    
      // OOP
      // ---------------
      // If Underscore is called as a function, it returns a wrapped object that
      // can be used OO-style. This wrapper holds altered versions of all the
      // underscore functions. Wrapped objects may be chained.
    
      // Helper function to continue chaining intermediate results.
      var result = function(instance, obj) {
        return instance._chain ? _(obj).chain() : obj;
      };
    
      // Add your own custom functions to the Underscore object.
      _.mixin = function(obj) {
        _.each(_.functions(obj), function(name) {
          var func = _[name] = obj[name];
          _.prototype[name] = function() {
            var args = [this._wrapped];
            push.apply(args, arguments);
            return result(this, func.apply(_, args));
          };
        });
      };
    
      // Add all of the Underscore functions to the wrapper object.
      _.mixin(_);
    
      // Add all mutator Array functions to the wrapper.
      _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
          var obj = this._wrapped;
          method.apply(obj, arguments);
          if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
          return result(this, obj);
        };
      });
    
      // Add all accessor Array functions to the wrapper.
      _.each(['concat', 'join', 'slice'], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
          return result(this, method.apply(this._wrapped, arguments));
        };
      });
    
      // Extracts the result from a wrapped and chained object.
      _.prototype.value = function() {
        return this._wrapped;
      };
    
      // Provide unwrapping proxy for some methods used in engine operations
      // such as arithmetic and JSON stringification.
      _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
    
      _.prototype.toString = function() {
        return '' + this._wrapped;
      };
    
      // AMD registration happens at the end for compatibility with AMD loaders
      // that may not enforce next-turn semantics on modules. Even though general
      // practice for AMD registration is to be anonymous, underscore registers
      // as a named module because, like jQuery, it is a base library that is
      // popular enough to be bundled in a third party lib, but not be part of
      // an AMD load request. Those cases could generate an error when an
      // anonymous define() is called outside of a loader request.
      if (typeof define === 'function' && define.amd) {
        define('underscore', [], function() {
          return _;
        });
      }
    }.call(this));
    
    },{}],67:[function(require,module,exports){
    // Init style shamelessly stolen from jQuery http://jquery.com
    var Froogaloop = (function(){
        // Define a local copy of Froogaloop
        function Froogaloop(iframe) {
            // The Froogaloop object is actually just the init constructor
            return new Froogaloop.fn.init(iframe);
        }
    
        var eventCallbacks = {},
            hasWindowEvent = false,
            isReady = false,
            slice = Array.prototype.slice,
            playerOrigin = '*';
    
        Froogaloop.fn = Froogaloop.prototype = {
            element: null,
    
            init: function(iframe) {
                if (typeof iframe === "string") {
                    iframe = document.getElementById(iframe);
                }
    
                this.element = iframe;
    
                return this;
            },
    
            /*
             * Calls a function to act upon the player.
             *
             * @param {string} method The name of the Javascript API method to call. Eg: 'play'.
             * @param {Array|Function} valueOrCallback params Array of parameters to pass when calling an API method
             *                                or callback function when the method returns a value.
             */
            api: function(method, valueOrCallback) {
                if (!this.element || !method) {
                    return false;
                }
    
                var self = this,
                    element = self.element,
                    target_id = element.id !== '' ? element.id : null,
                    params = !isFunction(valueOrCallback) ? valueOrCallback : null,
                    callback = isFunction(valueOrCallback) ? valueOrCallback : null;
    
                // Store the callback for get functions
                if (callback) {
                    storeCallback(method, callback, target_id);
                }
    
                postMessage(method, params, element);
                return self;
            },
    
            /*
             * Registers an event listener and a callback function that gets called when the event fires.
             *
             * @param eventName (String): Name of the event to listen for.
             * @param callback (Function): Function that should be called when the event fires.
             */
            addEvent: function(eventName, callback) {
                if (!this.element) {
                    return false;
                }
    
                var self = this,
                    element = self.element,
                    target_id = element.id !== '' ? element.id : null;
    
    
                storeCallback(eventName, callback, target_id);
    
                // The ready event is not registered via postMessage. It fires regardless.
                if (eventName != 'ready') {
                    postMessage('addEventListener', eventName, element);
                }
                else if (eventName == 'ready' && isReady) {
                    callback.call(null, target_id);
                }
    
                return self;
            },
    
            /*
             * Unregisters an event listener that gets called when the event fires.
             *
             * @param eventName (String): Name of the event to stop listening for.
             */
            removeEvent: function(eventName) {
                if (!this.element) {
                    return false;
                }
    
                var self = this,
                    element = self.element,
                    target_id = element.id !== '' ? element.id : null,
                    removed = removeCallback(eventName, target_id);
    
                // The ready event is not registered
                if (eventName != 'ready' && removed) {
                    postMessage('removeEventListener', eventName, element);
                }
            }
        };
    
        /**
         * Handles posting a message to the parent window.
         *
         * @param method (String): name of the method to call inside the player. For api calls
         * this is the name of the api method (api_play or api_pause) while for events this method
         * is api_addEventListener.
         * @param params (Object or Array): List of parameters to submit to the method. Can be either
         * a single param or an array list of parameters.
         * @param target (HTMLElement): Target iframe to post the message to.
         */
        function postMessage(method, params, target) {
            if (!target.contentWindow.postMessage) {
                return false;
            }
    
            var data = JSON.stringify({
                method: method,
                value: params
            });
    
            target.contentWindow.postMessage(data, playerOrigin);
        }
    
        /**
         * Event that fires whenever the window receives a message from its parent
         * via window.postMessage.
         */
        function onMessageReceived(event) {
            var data, method;
    
            try {
                data = JSON.parse(event.data);
                method = data.event || data.method;
            }
            catch(e)  {
                //fail silently... like a ninja!
            }
    
            if (method == 'ready' && !isReady) {
                isReady = true;
            }
    
            // Handles messages from the vimeo player only
            if (!(/^https?:\/\/player.vimeo.com/).test(event.origin)) {
                return false;
            }
    
            if (playerOrigin === '*') {
                playerOrigin = event.origin;
            }
    
            var value = data.value,
                eventData = data.data,
                target_id = target_id === '' ? null : data.player_id,
    
                callback = getCallback(method, target_id),
                params = [];
    
            if (!callback) {
                return false;
            }
    
            if (value !== undefined) {
                params.push(value);
            }
    
            if (eventData) {
                params.push(eventData);
            }
    
            if (target_id) {
                params.push(target_id);
            }
    
            return params.length > 0 ? callback.apply(null, params) : callback.call();
        }
    
    
        /**
         * Stores submitted callbacks for each iframe being tracked and each
         * event for that iframe.
         *
         * @param eventName (String): Name of the event. Eg. api_onPlay
         * @param callback (Function): Function that should get executed when the
         * event is fired.
         * @param target_id (String) [Optional]: If handling more than one iframe then
         * it stores the different callbacks for different iframes based on the iframe's
         * id.
         */
        function storeCallback(eventName, callback, target_id) {
            if (target_id) {
                if (!eventCallbacks[target_id]) {
                    eventCallbacks[target_id] = {};
                }
                eventCallbacks[target_id][eventName] = callback;
            }
            else {
                eventCallbacks[eventName] = callback;
            }
        }
    
        /**
         * Retrieves stored callbacks.
         */
        function getCallback(eventName, target_id) {
            if (target_id) {
                return eventCallbacks[target_id][eventName];
            }
            else {
                return eventCallbacks[eventName];
            }
        }
    
        function removeCallback(eventName, target_id) {
            if (target_id && eventCallbacks[target_id]) {
                if (!eventCallbacks[target_id][eventName]) {
                    return false;
                }
                eventCallbacks[target_id][eventName] = null;
            }
            else {
                if (!eventCallbacks[eventName]) {
                    return false;
                }
                eventCallbacks[eventName] = null;
            }
    
            return true;
        }
    
        function isFunction(obj) {
            return !!(obj && obj.constructor && obj.call && obj.apply);
        }
    
        function isArray(obj) {
            return toString.call(obj) === '[object Array]';
        }
    
        // Give the init function the Froogaloop prototype for later instantiation
        Froogaloop.fn.init.prototype = Froogaloop.fn;
    
        // Listens for the message event.
        // W3C
        if (window.addEventListener) {
            window.addEventListener('message', onMessageReceived, false);
        }
        // IE
        else {
            window.attachEvent('onmessage', onMessageReceived);
        }
    
        // Expose froogaloop to the global object
        return (window.Froogaloop = window.$f = Froogaloop);
    
    })();
    
    },{}]},{},[1]);
    